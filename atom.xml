<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gilgameshzzz.github.io/"/>
  <updated>2020-05-30T14:15:23.428Z</updated>
  <id>http://gilgameshzzz.github.io/</id>
  
  <author>
    <name>Amadeus</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java lambda表达式</title>
    <link href="http://gilgameshzzz.github.io/2020/05/30/java%E7%9A%84lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://gilgameshzzz.github.io/2020/05/30/java的lambda表达式/</id>
    <published>2020-05-29T16:00:00.000Z</published>
    <updated>2020-05-30T14:15:23.428Z</updated>
    
    <content type="html"><![CDATA[<p>Lambda表达式：引入函数式编程的风格，不是所有的引用数据类型都可以使用lambda表达式<br>只有SAM接口（函数式接口）类型的形参，变量才可以赋值为Lambda表达式。<br>函数式接口：SAM(Single Abstract Method)表示该接口<strong>只有一个抽象方法</strong>的接口。当然这个接口可以有默认方法和静态方法等成员。如Runable、Comparable<t>, Iterable、reflect、FileFilter</t></p><p>JDK1.8建议，这样的接口加一个注解标记@FunctionalInterface</p><h3 id="一、消费型接口-，-特点：有参无返回值"><a href="#一、消费型接口-，-特点：有参无返回值" class="headerlink" title="一、消费型接口 ， 特点：有参无返回值"></a>一、消费型接口 ， 特点：有参无返回值</h3><p>1、最基本的代表： Consumer<t> :  void accept(T t)<br>2、其他变形   BiConsumer: void accept(T t, U u)<br>例如：集合java.util.Collection系列的集合在JDK1.8之后增加的方法<br>default void forEach(Consumer&lt;? super T&gt; action)</t></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConsumer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"hello"</span>);</span><br><span class="line">        list.add(<span class="string">"hello world"</span>);</span><br><span class="line">        list.add(<span class="string">"hello java"</span>);</span><br><span class="line">        list.add(<span class="string">"hello lambda"</span>);</span><br><span class="line">        <span class="comment">// foreach循环</span></span><br><span class="line">        <span class="keyword">for</span> (String str:list)&#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// forEach 方法就是等价于foreach循环</span></span><br><span class="line">        list.forEach(t -&gt; System.out.println(t));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="二、供给型接口-抽象方法：无参有返回值"><a href="#二、供给型接口-抽象方法：无参有返回值" class="headerlink" title="二、供给型接口  抽象方法：无参有返回值"></a>二、供给型接口  抽象方法：无参有返回值</h3><p>1、最基本的代表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;T&gt;： T get()</span><br></pre></td></tr></table></figure></p><p>2、其他变型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BooleanSupplier  boolean  getAsBoolean()</span><br><span class="line">DoubleSupplier   double   getAsDouble()</span><br><span class="line">IntSupplier         int         getAsInt()</span><br><span class="line">LongSupplier       long       getAsLong()</span><br></pre></td></tr></table></figure></p><p>StreamAPI: Stream是一个数据流<br>javc.util.stream包Stream类型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">generate</span><span class="params">(Supplier&lt;T&gt; s)</span></span></span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestSupplier</span></span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 产生generate, 产生随机数</span></span><br><span class="line">        Stream&lt;Double&gt; stream = Stream.generate(() -&gt; Math.random());</span><br><span class="line">        stream.forEach(t-&gt; System.out.println(t));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、判断型（断定型）接口-返回值都为布尔值"><a href="#三、判断型（断定型）接口-返回值都为布尔值" class="headerlink" title="三、判断型（断定型）接口 , 返回值都为布尔值"></a>三、判断型（断定型）接口 , 返回值都为布尔值</h3><p>  抽象方法：boolean  test(参数)<br>   1、最基本的代表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;T&gt; boolean test(T t)</span><br></pre></td></tr></table></figure></p><p>  2、其他的变形<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BiPredicate&lt;T,U&gt;  boolean        test(T t,U u)</span><br><span class="line">DoublePredicate  boolean         test(double value)</span><br><span class="line">ntPredicate        boolean         test(int value)</span><br><span class="line">LongPredicate      boolean         test(long value)</span><br></pre></td></tr></table></figure></p><pre><code>例如： java.util.Collection&lt;E&gt;default boolean removeIf(Predicate&lt;? super E&gt;filter)</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestPredicate</span></span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除3的倍数元素</span></span><br><span class="line">        <span class="comment">//第一种</span></span><br><span class="line"><span class="comment">//        Iterator&lt;Integer&gt; iterator = list.iterator();</span></span><br><span class="line"><span class="comment">//        while (iterator.hasNext())&#123;</span></span><br><span class="line"><span class="comment">//            Integer next = iterator.next();</span></span><br><span class="line"><span class="comment">//            if (next%3 ==0)&#123;</span></span><br><span class="line"><span class="comment">//                iterator.remove();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">// 第二种</span></span><br><span class="line">        list.removeIf(t-&gt; t%<span class="number">3</span> ==<span class="number">0</span>);</span><br><span class="line">        list.forEach(t -&gt; System.out.println(t));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、功能型接口-抽象方法：有参有返回值"><a href="#四、功能型接口-抽象方法：有参有返回值" class="headerlink" title="四、功能型接口   抽象方法：有参有返回值"></a>四、功能型接口   抽象方法：有参有返回值</h3><p> 1、最基本的代表：Function&lt;T, R&gt; R apply(T t)<br>Lambda表达式是给函数式接口的形参或变量赋值用的，为了给这个函数式接口的抽象方法传递代码用<br>语法格式：<br>（形参列表） -&gt;{lambda体}  解释：<br>（形参列表）就是函数式接口的抽象方法的形参列表。<br>{lambda体}就是函数式接口的抽象方法的方法体。<br>说明：1、当（形参列表）是空参时，那么（）是不能省略的<br>2、当（形参列表）是非空参的，并且类型是确定的或者可以推断的，那么形参的数据类型可以省略<br>3、当（形参列表）是非空参的，并且只有一个形参，并且类型也省略了，那么此时()也可以省略，如果类型没有省略，那么()也不能省略。<br>4、如果{lambda体} 不止一个语句，那么{}不能省略，并且每一个语句都要；结束<br>5、如果{lambda体}只有一个语句，那么{}和；可以省略且同时省略<br>6、如果有返回值，用return返回,且只有一个return语句时，return、{}、；都同时省略<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">       ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       list.add(<span class="string">"hello"</span>);</span><br><span class="line">       list.add(<span class="string">"hello world"</span>);</span><br><span class="line">       list.add(<span class="string">"hello java"</span>);</span><br><span class="line">       list.add(<span class="string">"hello lambda"</span>);</span><br><span class="line">      <span class="comment">//用匿名内部类给Consumer接口的形参赋值</span></span><br><span class="line">       list.forEach(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">               System.out.println(s);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="comment">// forEach 方法就是等价于foreach循环</span></span><br><span class="line">       <span class="comment">//  list.forEach((t) -&gt; &#123;System.out.println(t)&#125;;); 省略后</span></span><br><span class="line">       list.forEach(t -&gt; System.out.println(t));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Lambda表达式：引入函数式编程的风格，不是所有的引用数据类型都可以使用lambda表达式&lt;br&gt;只有SAM接口（函数式接口）类型的形参，变量才可以赋值为Lambda表达式。&lt;br&gt;函数式接口：SAM(Single Abstract Method)表示该接口&lt;strong
      
    
    </summary>
    
    
      <category term="java" scheme="http://gilgameshzzz.github.io/tags/java/"/>
    
      <category term="lambda" scheme="http://gilgameshzzz.github.io/tags/lambda/"/>
    
  </entry>
  
  <entry>
    <title>Java集合，泛型，spring注解、事务的一些问题</title>
    <link href="http://gilgameshzzz.github.io/2020/04/24/java%E9%9B%86%E5%90%88/"/>
    <id>http://gilgameshzzz.github.io/2020/04/24/java集合/</id>
    <published>2020-04-23T16:00:00.000Z</published>
    <updated>2020-04-24T15:24:59.886Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java-集合类之间的继承关系"><a href="#java-集合类之间的继承关系" class="headerlink" title="java 集合类之间的继承关系"></a>java 集合类之间的继承关系</h2><p>Java的集合类主要由两个接口派生而出：Collection和Map,Collection和Map是Java集合框架的根接口。代表了两种不同的数据结构：集合和映射表。</p><p><img src="\img\collection.png" alt="collection"></p><p>图中，ArrayList,HashSet,LinkedList,TreeSet是我们经常会有用到的已实现的集合类。</p><p>Map实现类用于保存具有映射关系的数据。Map保存的每项数据都是key-value对，也就是由key和value两个值组成。Map里的key是不可重复的，key用户标识集合里的每项数据。</p><p><img src="\img\map.png" alt="map"></p><h2 id="迭代器的作用"><a href="#迭代器的作用" class="headerlink" title="迭代器的作用"></a>迭代器的作用</h2><p>由于Java中数据容器众多，而对数据容器的操作在很多时候都具有极大的共性，于是Java采用了迭代器为各种容器提供公共的操作接口</p><p><strong>解耦效果</strong>：使用迭代器iterator可以使对容器的遍历操作完全与其底层相隔离，可以到达极好的解耦效果</p><p>iterator方法返回一个实现了Iterator接口的对象，作用是依次访问集合中的元素，Iterator<e>接口包含3个方法：</e></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">boolean hasNext();  # 如果任有元素可以迭代，则返回true.</span><br><span class="line">E next();  # 返回迭代的下一个元素</span><br><span class="line">void remove(); # 从迭代器指向的collection中移除迭代器返回的最后一个元素(可选操作)</span><br></pre></td></tr></table></figure><p>通过多次调用next()方法可遍历集合中的所有元素，需要注意的是需要在调用next()之前调用hasNext()方法，并在hasNext()返回true的时候才可以调用next().</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        List&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"C++"</span>);</span><br><span class="line">        list.add(<span class="string">"python"</span>);</span><br><span class="line">        list.add(<span class="string">"java"</span>);</span><br><span class="line">        <span class="keyword">for</span>(Iterator&lt;String&gt; it=list.iterator();it.hasNext();)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">            <span class="keyword">if</span>(xxx)&#123;</span><br><span class="line">              list.remove();<span class="comment">//翻车写法</span></span><br><span class="line">              it.remove();<span class="comment">//正确写法</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>遍历集合时删除特定元素一定要用Iterator的remove,别用集合自带的remove。会报错：</p><p><font size="4" color="red">java.util.ConcurrentModificationException</font><br>在集合内部维护一个字段modCount用于记录集合被修改的次数，每当集合内部结构发生变化(add,remove，set)时，<font size="4" color="red">modCount</font>+1。　　<br>在迭代器内部也维护一个字段<font size="4" color="red">expectedModCount</font>，同样记录当前集合修改的次数，初始化为集合的modCount值。当我们在调用Iterator进行遍历操作时，如果有其他线程修改list会出现<font size="4" color="red">modCount!=expectedModCount</font>的情况，就会报并发修改异常<font size="4" color="red">java.util.ConcurrentModificationException</font><img src="\img\ConcurrentModificationException.png" alt="ConcurrentModificationException"></p><h2 id="集合的排序"><a href="#集合的排序" class="headerlink" title="集合的排序"></a>集合的排序</h2><p>java集合的工具类Collections中提供了两种排序的方法,分别是:</p><ol><li><p>Collections.sort(List list)</p></li><li><p>Collections.sort(List list,Comparator c)</p></li></ol><p>第一种称为自然排序,参与排序的对象需实现comparable接口,<strong>缺点会入侵代码</strong></p><p>第二种叫定制排序,或自定义排序,需编写匿名内部类,先new一个Comparator接口的比较器对象,优点不用修改排序对象代码，例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(ordered, <span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student t1, Student t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (t1.getOrder() - t2.getOrder());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>java8函数式排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据学生身高排序</span></span><br><span class="line">list.sort(Comparator.comparing(Student::getHeight).reversed())</span><br></pre></td></tr></table></figure><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">fun</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">fun2</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="\img\泛型.png" alt></p><p><strong>泛型类的方法</strong>和<strong>泛型方法</strong>区别：</p><ul><li>一个是在实例化对象才确认下来的 【泛型类的方法】</li><li>一个是在方法调用时确认下来的 【泛型方法】</li></ul><h3 id="普通泛型类的方法"><a href="#普通泛型类的方法" class="headerlink" title="普通泛型类的方法"></a>普通泛型类的方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虽然方法中使用了泛型，但这并不是泛型方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">fun</span><span class="params">(T t)</span></span>&#123;           <span class="comment">// 可以接收任意类型的数据</span></span><br><span class="line">    <span class="keyword">return</span> t;                <span class="comment">// 直接把参数返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加static会编译错误</p><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>可以加static</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个&lt;T&gt;修饰的方法才是真的泛型方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">fun2</span><span class="params">(T t)</span></span>&#123;          <span class="comment">// 可以接收任意类型的数据</span></span><br><span class="line">    <span class="keyword">return</span> t;                           <span class="comment">// 直接把参数返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型方法总结"><a href="#泛型方法总结" class="headerlink" title="泛型方法总结"></a>泛型方法总结</h3><ul><li><strong>泛型类，是在 【实例化类】 的时候指明泛型的具体类型；</strong></li><li><strong>泛型方法，是在调用方法的时候指明泛型的具体类型</strong> ，注意跟类实例化没关系了。</li><li><strong>泛型方法可以加static,普通的泛型类的方法是不可以的</strong></li></ul><h3 id="使用泛型方法好处"><a href="#使用泛型方法好处" class="headerlink" title="使用泛型方法好处"></a>使用泛型方法好处</h3><ul><li>因为泛型方法类型可以<strong>灵活的传入参数类型</strong>，不像泛型类的方法实例化后就固定掉了。</li><li>每次调用泛型方法入参类型都可以灵活的变化，可以看我的例子</li><li>泛型方法支持static</li></ul><h2 id="spring注解、事务传播机制"><a href="#spring注解、事务传播机制" class="headerlink" title="spring注解、事务传播机制"></a>spring注解、事务传播机制</h2><h3 id="7种事务的传播机制（可通过spring配置或注解来设置）"><a href="#7种事务的传播机制（可通过spring配置或注解来设置）" class="headerlink" title="7种事务的传播机制（可通过spring配置或注解来设置）"></a><strong>7种事务的传播机制（可通过spring配置或注解来设置）</strong></h3><ol><li>REQUIRED（默认）：支持使用当前事务，如果当前事务不存在，创建一个新事务。</li><li>SUPPORTS：支持使用当前事务，如果当前事务不存在，则不使用事务。</li><li>MANDATORY：中文翻译为强制，支持使用当前事务，如果当前事务不存在，则抛出Exception。</li><li>REQUIRES_NEW：创建一个新事务，如果当前事务存在，把当前事务挂起。</li><li>NOT_SUPPORTED：无事务执行，如果当前事务存在，把当前事务挂起。</li><li>NEVER：无事务执行，如果当前有事务则抛出Exception。</li><li>NESTED：嵌套事务，如果当前事务存在，那么在嵌套的事务中执行。如果当前事务不存在，则表现跟REQUIRED一样。</li></ol><h3 id="事务注解失效的例子"><a href="#事务注解失效的例子" class="headerlink" title="事务注解失效的例子"></a>事务注解失效的例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WePageManagerServiceImpl</span> <span class="keyword">implements</span> <span class="title">WePageManagerService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pagePublish</span><span class="params">(MysRequest request)</span> </span>&#123;</span><br><span class="line">        PublishHandler(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span>(rollbackFor = Exception.class)</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ProcResult&lt;String&gt; <span class="title">PublishHandler</span><span class="params">(WePagePublishRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//多表dao操作......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决方案：把事务代码下沉-用一个类去单独处理"><a href="#解决方案：把事务代码下沉-用一个类去单独处理" class="headerlink" title="解决方案：把事务代码下沉,用一个类去单独处理"></a>解决方案：把事务代码下沉,用一个类去单独处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WePageManagerServiceImpl</span> <span class="keyword">implements</span> <span class="title">WePageManagerService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyTransaction myTransaction;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pagePublish</span><span class="params">(MysRequest request)</span> </span>&#123;</span><br><span class="line">       myTransaction.pagePublishHandler(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span>(rollbackFor = Throwable.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTransactionImpl</span> <span class="keyword">implements</span> <span class="title">MyTransaction</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ProcResult&lt;String&gt; <span class="title">pagePublishHandler</span><span class="params">(WePagePublishRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//多表dao操作......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Transactional<strong>失效原因分析：自身调用导致失败</strong></p><p>在应用系统调用声明@Transactional 的目标方法时，Spring Framework 默认使用 AOP 代理，在代码运行时生成一个代理对象，再由这个代理对象来统一管理，当在Service实现类直接调用内部方法时，其本质是通过this对象来调用的方法，而不是代理对象，因为会出现事务失效的情况</p><p>总结一句话，<strong>自身调用没有经过 Spring 的代理类</strong></p><p><strong>事务失效3种常见原因</strong></p><ul><li>自身调用（面试最爱问啦）</li><li>异常被吃</li><li>异常抛出类型</li></ul><p><a href="https://mp.weixin.qq.com/s?__biz=MzA4NzQ0Njc4Ng==&amp;mid=2247485704&amp;idx=1&amp;sn=403faac580b5a4df8c0ad52d488fb59d&amp;chksm=90380d65a74f847352f3792aeefd09f34cf28f082400917f9b1fdf26cfac435a54316eb0b328&amp;scene=126&amp;sessionid=1587719861&amp;key=7a384acef7f5f4afc36c937135ad3926050d02aac9b3af4026ce6c49b54f270785f99728e6452babd861dad566b8da26113447843f7b3af55909d5433fc983cb16da5e89a312efa70eeb8f6929f428cf&amp;ascene=1&amp;uin=Mjg5MjMxNTQxMA%3D%3D&amp;devicetype=Windows+10&amp;version=62080079&amp;lang=zh_CN&amp;exportkey=A11GMdesik4lH9%2FEA1zySOc%3D&amp;pass_ticket=cCRSLB2olzvtMXc6W%2FhQRmQOmaS%2BKEBVtkxlBUyxsIgb%2BL42ZloZw3WsR1GhVEfM" target="_blank" rel="noopener">参考内容-微信</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;java-集合类之间的继承关系&quot;&gt;&lt;a href=&quot;#java-集合类之间的继承关系&quot; class=&quot;headerlink&quot; title=&quot;java 集合类之间的继承关系&quot;&gt;&lt;/a&gt;java 集合类之间的继承关系&lt;/h2&gt;&lt;p&gt;Java的集合类主要由两个接口派生而
      
    
    </summary>
    
    
      <category term="Java" scheme="http://gilgameshzzz.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java并发-AQS-ReentrantLock</title>
    <link href="http://gilgameshzzz.github.io/2020/04/22/java%E5%B9%B6%E5%8F%91AQS/"/>
    <id>http://gilgameshzzz.github.io/2020/04/22/java并发AQS/</id>
    <published>2020-04-21T16:00:00.000Z</published>
    <updated>2020-04-22T05:59:11.030Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在<code>synchronized</code>未优化之前，我们在编码中使用最多的同步工具类应该是<code>ReentrantLock</code>类，<code>ReentrantLock</code>拥有优化后<code>synchronized</code>关键字的性能，又提供了更多的灵活性。相比<code>synchronized</code>，他在功能上更加强大，具有等待可中断，公平锁以及绑定多个条件等<code>synchronized</code>不具备的功能。</p><h2 id="ReentrantLock-与AQS-AbstractQueuedSynchronizer-的关系"><a href="#ReentrantLock-与AQS-AbstractQueuedSynchronizer-的关系" class="headerlink" title="ReentrantLock 与AQS(AbstractQueuedSynchronizer)的关系"></a>ReentrantLock 与AQS(AbstractQueuedSynchronizer)的关系</h2><p>在使用<font size="4" color="#FF1493">ReentrantLock </font>类时，第一步实例化 <strong>new ReentrantLock()</strong>,他的实例化源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过名字可以看出是公平锁和非公平锁的实现，默认情况下<font size="4" color="#FF1493">ReentrantLock</font>使用非公平锁，那么<font size="4" color="#FF1493">sync</font>字段是怎么实现的？看sync的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;......&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;......&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;......&#125;</span><br></pre></td></tr></table></figure><p>到这里就发现了<code>AbstractQueuedSynchronizer</code>类，公平锁和非公平锁其实都是在<code>AbstractQueuedSynchronizer</code>的基础上实现的，也就是AQS。AQS提供了<code>ReentrantLock</code>实现的基础。</p><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>AQS全称<code>AbstractQueuedSynchronizer</code>，翻译为抽象队列同步器，他是构建JUC包下并发工具类的基础框架，提供了可中断锁，超时锁，独占锁，共享锁等等，它没有利用高级机器指令，也没有利用JDK编译时的特殊处理，仅仅是一个普通的类，就实现了并发的控制。</p><h4 id="功能特点："><a href="#功能特点：" class="headerlink" title="功能特点："></a>功能特点：</h4><p><strong>1、等待中断</strong>。synchronized不可以被中断，指的是synchronized等待不可中断，一旦进入阻塞状态，就无法被中断。只能通过调用的方法抛出InterruptedException异常，那么它就可以被中断，不抛出InterruptedException的方法是不可中断的。</p><p><strong>2、锁超时</strong>。AQS支持超时锁，可以指定一个时间，如果指定时间内没有获取锁，就直接退出获取锁。</p><p><strong>3、非阻塞</strong>。尝试获取锁失败，并不进入阻塞状态，而是直接返回，那这个线程也有机会释放曾经持有的锁。</p><p>AQS底层采用的是状态标志位（state变量）+ FIFO队列的方式来记录获取锁、释放锁、竞争锁等一系列操作。对于AQS而言,其中的<strong>state变量可以看做是锁</strong>，队列采用的是先进先出的双向链表，<strong>state共享状态变量表示锁状态</strong>，内部使用CAS对state进行原子操作修改来完成锁状态变更（锁的持有和释放）。<br><img src="\img\AQS.png" alt></p><h3 id="AQS核心"><a href="#AQS核心" class="headerlink" title="AQS核心"></a>AQS核心</h3><h4 id="状态state"><a href="#状态state" class="headerlink" title="状态state"></a>状态state</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;    </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">  <span class="keyword">return</span> state;    </span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;        </span><br><span class="line">  state = newState;    </span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;        </span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>state状态这里还是比较简单的，使用volatile修饰，保证state变量的可见性， setState(int newState)方法只是用作给state进行初始化，而compareAndSetState(int expect, int update)用作了在运行期间对state变量的修改。</p><p>为什么要单独多出来一个compareAndSetState方法对state变量进行修改呢？</p><p>因为对共享变量的赋值，不是原子操作需要额外的锁同步，我们可能想到使用synchronized来保证原子性，但是<strong>synchronizedh会使线程阻塞</strong>，导致线程上下文的切换，影响其性能。这里采用的是CAS无锁操作，但是CAS也是有不足的，它会进行自旋操作，这样也会对CPU的资源造成浪费。</p><h4 id="同步队列FIFO"><a href="#同步队列FIFO" class="headerlink" title="同步队列FIFO"></a>同步队列FIFO</h4><p>AQS会把没有争抢到锁的线程包装成Node节点，加入队列中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;   </span><br><span class="line">    <span class="comment">//标记节点是共享模式    </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();    </span><br><span class="line"> <span class="comment">//标记节点是独占的    </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;   </span><br><span class="line">    <span class="comment">//代表此节点的线程取消了争抢资源    </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;     </span><br><span class="line">    <span class="comment">//表示当前node的后继节点对应的线程需要被唤醒    </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;    </span><br><span class="line">    <span class="comment">//这两个状态和condition有关系，这里先不说condition    </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;       </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;   </span><br><span class="line">    <span class="comment">// 取值为上面的1、-1、-2、-3 或者 0    </span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;    </span><br><span class="line">    <span class="keyword">volatile</span> Node prev;    </span><br><span class="line">    <span class="keyword">volatile</span> Node next;   </span><br><span class="line">    <span class="comment">//等待线程   </span></span><br><span class="line"> <span class="keyword">volatile</span> Thread thread;    </span><br><span class="line">    Node nextWaiter;    </span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">       <span class="keyword">return</span> nextWaiter == SHARED;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;        </span><br><span class="line">        Node p = prev;        </span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)           </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();       </span><br><span class="line">        <span class="keyword">else</span>            </span><br><span class="line">            <span class="keyword">return</span> p;    </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    Node() &#123;       </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//线程入队。    </span></span><br><span class="line">    Node(Thread thread, Node mode) &#123;    </span><br><span class="line">        <span class="comment">// Used by addWaiter        </span></span><br><span class="line">        <span class="keyword">this</span>.nextWaiter = mode;        </span><br><span class="line">        <span class="keyword">this</span>.thread = thread;    </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//使用condition用到    </span></span><br><span class="line">    Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; </span><br><span class="line">        <span class="comment">// Used by Condition       </span></span><br><span class="line">        <span class="keyword">this</span>.waitStatus = waitStatus;       </span><br><span class="line">        <span class="keyword">this</span>.thread = thread;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步队列是AQS的核心，用来实现线程的阻塞和唤醒操作，waitStatus它表示了当前Node所代表的线程的等待锁的状态，在独占锁模式下，我们只需要关注CANCELLED、SIGNAL两种状态即可。nextWaiter属性，它在独占锁模式下永远为null，仅仅起到一个标记作用。</p><p><img src="\img\queue.png" alt></p><h4 id="独占锁、共享锁"><a href="#独占锁、共享锁" class="headerlink" title="独占锁、共享锁"></a>独占锁、共享锁</h4><p>AQS定义两种资源共享方式</p><ul><li>Exclusive （独占模式）：只有一个线程能访问共享资源。如 ReentrantLock</li><li>Share（共享模式）：多个线程可同时访问共享资源，如Semaphore/CountDownLatch）</li></ul><p>在独占模式下和synchronized实现的效果是一样的，一次只能有一个线程访问。state 等于0 代表没有线程持有锁，大于0代表有线程持有当前锁。这个值可以大于1，是因为<strong>锁可以重入，每次重入都加上 1，也需要对应的多次释放</strong>。即上锁多少次，就要解锁多少次。</p><p>在共享模式下，state的值代表着有多少个许可，但是它在每个具体的工具类里的应用还是有一些差别的。</p><h3 id="ReentrantLock独占锁"><a href="#ReentrantLock独占锁" class="headerlink" title="ReentrantLock独占锁"></a>ReentrantLock独占锁</h3><p>实现锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ReentrantLock的lock方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用了Sync中的lock抽象方法</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Performs &#123;<span class="doctag">@link</span> Lock#lock&#125;. The main reason for subclassing</span></span><br><span class="line"><span class="comment">        * is to allow fast path for nonfair version.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Sync</code>类的<code>lock()</code>方法是一个抽象方法，<code>NonfairSync()</code>和<code>FairSync()</code>分别对<code>lock()</code>方法进行了实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非公平锁的lock实现</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">        * acquire on failure.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) <span class="comment">//插队操作，首先尝试CAS获取锁，0为锁空闲</span></span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread()); <span class="comment">//获取锁成功后设置当前线程为占有锁线程</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公平锁的lock实现</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>区别</strong>：<code>NonfairSync()</code>会先进行一个CAS操作，将一个state状态从0设置到1，这个也就是上面所说的非公平锁的“插队”操作，前面讲过CAS操作默认是原子性的，这样就保证了设置的线程安全性。</p><p>看看跟state有关的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The synchronization state.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>state变量是一个<code>volatile</code>修饰的<code>int</code>类型变量，这样就保证了这个变量在多线程环境下的可见性。从变量的注释“The synchronization state”可以看出state代表了一个同步状态。再回到上面的<code>lock()</code>方法，在设置成功之后，调用了<code>setExclusiveOwnerThread</code>方法将当前线程设置给了一个私有的变量，这个变量代表了当前获取锁的线程，放到了AQS的父类<code>AbstractOwnableSynchronizer</code>类中实现。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1、AQS中用state属性表示锁，在ReentranLock中当state = 1 获取锁，state = 0代表释放锁， state&gt;1代表重入锁。exclusiveOwnerThread属性代表了占有锁的线程。</p><p>2、addWaiter负责将当前等待锁的线程包装成Node,并成功地添加到队列的末尾，这一点是由它调用的enq方法保证的，enq方法同时还负责在队列为空时初始化队列。</p><p>3、acquireQueued方法用于在Node成功入队后，继续尝试获取锁（取决于Node的前驱节点是不是head），或者将线程挂起</p><p>4、shouldParkAfterFailedAcquire方法用于保证当前线程的前驱节点的waitStatus属性值为SIGNAL,从而保证了自己挂起后，前驱节点会负责在合适的时候唤醒自己。</p><p>5、parkAndCheckInterrupt方法用于挂起当前线程，并检查中断状态。</p><p>6、如果最终成功获取了锁，线程会从lock()方法返回，继续往下执行；否则，线程会阻塞等待。</p><p><a href="https://juejin.im/post/5b7235e951882560ed075893#heading-2" target="_blank" rel="noopener">参考链接1-掘金</a></p><p><a href="https://juejin.im/post/5e9d3f01518825739b2d4866#heading-16" target="_blank" rel="noopener">参考链接2-掘金</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在&lt;code&gt;synchronized&lt;/code&gt;未优化之前，我们在编码中使用最多的同步工具类应该是&lt;code&gt;ReentrantLock
      
    
    </summary>
    
    
      <category term="Java" scheme="http://gilgameshzzz.github.io/tags/Java/"/>
    
      <category term="并发" scheme="http://gilgameshzzz.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>二叉树算法题</title>
    <link href="http://gilgameshzzz.github.io/2020/04/20/%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95/"/>
    <id>http://gilgameshzzz.github.io/2020/04/20/搜索二叉树算法/</id>
    <published>2020-04-19T16:00:00.000Z</published>
    <updated>2020-04-20T15:39:19.595Z</updated>
    
    <content type="html"><![CDATA[<p><strong>二叉搜索树（BST）</strong>又称二叉查找树或二叉排序树。若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉搜索</p><h2 id="问题：已知一个搜索二叉树，后序遍历的数组posArr，请根据posArr-重建出整棵数，返回新建树的头节点"><a href="#问题：已知一个搜索二叉树，后序遍历的数组posArr，请根据posArr-重建出整棵数，返回新建树的头节点" class="headerlink" title="问题：已知一个搜索二叉树，后序遍历的数组posArr，请根据posArr,重建出整棵数，返回新建树的头节点"></a>问题：已知一个搜索二叉树，后序遍历的数组posArr，请根据posArr,重建出整棵数，返回新建树的头节点</h2><p>例如 数组posArr= [2,4,3,6,7,8,5],建出二叉树：<img src="C:\Code\hexo_blog\source\img\posArr二叉树.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PosArrayToBST</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> Node left;</span><br><span class="line">        <span class="keyword">public</span> Node right;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">startPosArrayToBST</span><span class="params">(<span class="keyword">int</span>[] posArr)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> process(posArr, <span class="number">0</span>, posArr.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用posArr[L....R]这些数字，来建树，返回建好的树的头节点</span></span><br><span class="line">    <span class="comment">// 递归</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] posArr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L&gt;R)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 头节点的数为R的数，即posArr最后的数为头节点</span></span><br><span class="line">        Node head = <span class="keyword">new</span> Node(posArr[R]);</span><br><span class="line">        <span class="keyword">if</span> (L == R)&#123;   <span class="comment">// 说明该树只有一个节点</span></span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>  M = L -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = L;</span><br><span class="line">        <span class="keyword">int</span> right = R;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">            <span class="comment">// 等同于 mid = (L+R)/2,之所以用位移，是因为位移更快，除法底层更复杂</span></span><br><span class="line">            <span class="comment">// int 范围 -21亿~21亿，L+R过大时有溢出风险， 所以用 L + （R - L）</span></span><br><span class="line">            <span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (posArr[mid] &lt; posArr[R])&#123;</span><br><span class="line">                M = mid;</span><br><span class="line">                left = mid +<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head.left = process(posArr, L, M);</span><br><span class="line">        head.right = process(posArr, M+<span class="number">1</span>, R-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>M = L -1 原因：当二叉树既有左子树，又有右子树，M会改变，初始值无所谓，但当二叉树只有左边时（[1,2,3,4,5]），M最后的结果就为R-1，后续的递归 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">head.right = process(posArr, M+<span class="number">1</span>, R-<span class="number">1</span>);</span><br><span class="line"><span class="comment">// M = R -1 ;上面的结构就变为：</span></span><br><span class="line">head.right = process(posArr, R, R-<span class="number">1</span>); <span class="comment">// 无效head.right = null;</span></span><br></pre></td></tr></table></figure><p>右边同理。等同于</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(M == -<span class="number">1</span>)&#123;</span><br><span class="line">    head.right = process(posArr, L, R-<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(M == R-<span class="number">1</span>)&#123;</span><br><span class="line">    head.left = process(posArr, L, R-<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    head.left = process(posArr, L, M);</span><br><span class="line">    head.right = process(posArr, M+<span class="number">1</span>, R-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上算法，最坏情况下时间复杂度 O(N * ㏒₂N)</p><h2 id="问题二：给定长度为m的字符串aim-以及一个长度为n的字符串str。问能否在str中找到一个长度为m的连续子串，使得这个子串刚好由aim的m个字符组成，顺序无所谓，返回任意满足条件的一个子串的起始位置，未找到返回-1。"><a href="#问题二：给定长度为m的字符串aim-以及一个长度为n的字符串str。问能否在str中找到一个长度为m的连续子串，使得这个子串刚好由aim的m个字符组成，顺序无所谓，返回任意满足条件的一个子串的起始位置，未找到返回-1。" class="headerlink" title="问题二：给定长度为m的字符串aim,以及一个长度为n的字符串str。问能否在str中找到一个长度为m的连续子串，使得这个子串刚好由aim的m个字符组成，顺序无所谓，返回任意满足条件的一个子串的起始位置，未找到返回-1。"></a>问题二：给定长度为m的字符串aim,以及一个长度为n的字符串str。问能否在str中找到一个长度为m的连续子串，使得这个子串刚好由aim的m个字符组成，顺序无所谓，返回任意满足条件的一个子串的起始位置，未找到返回-1。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">containExactly</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 时间复杂度 O（N^3 * logN） 不行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">wayOne</span><span class="params">(String s, String a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || a == <span class="keyword">null</span> || s.length() &lt; a.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] aim = a.toCharArray();</span><br><span class="line">        System.out.println(<span class="string">"aim 的值为"</span> + aim);</span><br><span class="line">        Arrays.sort(aim);</span><br><span class="line">        <span class="comment">// aim 排完序</span></span><br><span class="line">        String aimSort = String.valueOf(aim);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> L = <span class="number">0</span>; L&lt; s.length(); L++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> R = L; R &lt; s.length(); R++)&#123;</span><br><span class="line">                <span class="comment">// substring 获取的范围是 [ )</span></span><br><span class="line">                <span class="keyword">char</span>[] cur = s.substring(L, R+<span class="number">1</span>).toCharArray();</span><br><span class="line">                Arrays.sort(cur);</span><br><span class="line">                System.out.println(cur);</span><br><span class="line">                String curSort = String.valueOf(cur);</span><br><span class="line">                <span class="keyword">if</span> (curSort.equals(aimSort))&#123;</span><br><span class="line">                    <span class="keyword">return</span> L;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下面这个复杂度低</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">wayTwo</span><span class="params">(String s, String a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || a == <span class="keyword">null</span> || s.length() &lt; a.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] aim = a.toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">int</span> M = aim.length;</span><br><span class="line">        <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">            count[aim[i]] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> inValidTimes = <span class="number">0</span>, R = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 先让窗口拥有M个字符</span></span><br><span class="line">        <span class="keyword">for</span> (; R&lt; M; R++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count[str[R]]-- &lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                inValidTimes++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(inValidTimes);</span><br><span class="line">        <span class="comment">// R==M  [0...M-1]</span></span><br><span class="line">        <span class="comment">// 第一次形成长度为M 的窗口</span></span><br><span class="line">        <span class="keyword">for</span>(; R &lt; str.length; R++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (inValidTimes == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> R-M;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count[str[R]]-- &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                inValidTimes++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count[str[R - M]]++ &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                inValidTimes--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> inValidTimes == <span class="number">0</span> ? R - M : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String string = <span class="string">"abcdabcdsfcas"</span>;</span><br><span class="line">        String a = <span class="string">"abc"</span>;</span><br><span class="line">        <span class="keyword">int</span> result = wayTwo(string, a);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二解释：假设 aim = “acabb”, str = “caabcb”, M为aim的长度，值为5，count 记录aim每一个字符出现的次数，即第一个for循环。第二个for循环， str 前 M个字符在count列表出现的次数，刚好减掉aim在count列表里次数的值，则说明str前M个字符符合要求，如果不符合则进入第三个for循环，判断str中[1…M]的字符是否满足要求，否则再次进入第三个for循环，判断str中的[2….M+1]字符是否满足要求。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;二叉搜索树（BST）&lt;/strong&gt;又称二叉查找树或二叉排序树。若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉搜索&lt;/p&gt;
&lt;h2 id=&quot;问题：已
      
    
    </summary>
    
    
      <category term="算法" scheme="http://gilgameshzzz.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="http://gilgameshzzz.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>计算机缓存的替换策略（算法）</title>
    <link href="http://gilgameshzzz.github.io/2020/04/17/%E7%BC%93%E5%AD%98%E6%9B%BF%E6%8D%A2%E7%AD%96%E7%95%A5/"/>
    <id>http://gilgameshzzz.github.io/2020/04/17/缓存替换策略/</id>
    <published>2020-04-16T16:00:00.000Z</published>
    <updated>2020-04-19T15:03:36.441Z</updated>
    
    <content type="html"><![CDATA[<p>目前替换策略有四种算法：</p><h3 id="随机算法"><a href="#随机算法" class="headerlink" title="随机算法"></a>随机算法</h3><h4 id="双向链表python实现"><a href="#双向链表python实现" class="headerlink" title="双向链表python实现"></a>双向链表python实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.value = value</span><br><span class="line">        self.prev = <span class="keyword">None</span></span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        val = <span class="string">f'<span class="subst">&#123;&#123;&#123;self.key&#125;</span> : <span class="subst">&#123;self.value&#125;</span>&#125;&#125;'</span></span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        val = <span class="string">f'<span class="subst">&#123;&#123;&#123;self.key&#125;</span> : <span class="subst">&#123;self.value&#125;</span>&#125;&#125;'</span></span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkedList</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capaity=<span class="number">0xffff</span>)</span>:</span></span><br><span class="line">        self.capaity = capaity</span><br><span class="line">        self.head = <span class="keyword">None</span></span><br><span class="line">        self.tail = <span class="keyword">None</span></span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 从头部添加</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_head</span><span class="params">(self, node: Node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.head:</span><br><span class="line">            self.head = node</span><br><span class="line">            self.tail = node</span><br><span class="line">            self.head.next = <span class="keyword">None</span></span><br><span class="line">            self.head.prev = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node.next = self.head</span><br><span class="line">            self.head.prev = node</span><br><span class="line">            self.head = node</span><br><span class="line">            self.head.prev = <span class="keyword">None</span></span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 从尾部添加</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_tail</span><span class="params">(self, node: Node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.tail:</span><br><span class="line">            self.tail = node</span><br><span class="line">            self.head = node</span><br><span class="line">            self.tail.next = <span class="keyword">None</span></span><br><span class="line">            self.tail.prev = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.tail.next = node</span><br><span class="line">            node.prev = self.tail</span><br><span class="line">            self.tail = node</span><br><span class="line">            self.tail.next = <span class="keyword">None</span></span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 从尾部删除</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">del_tail</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.tail:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        node = self.tail</span><br><span class="line">        <span class="keyword">if</span> node.prev:</span><br><span class="line">            self.tail = node.prev</span><br><span class="line">            self.tail.next = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.tail = self.head = <span class="keyword">None</span></span><br><span class="line">        self.size -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 从头部删除</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">del_head</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.head:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        node = self.head</span><br><span class="line">        <span class="keyword">if</span> node.next:</span><br><span class="line">            self.head = node.next</span><br><span class="line">            self.head.prev = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.tail = self.head = <span class="keyword">None</span></span><br><span class="line">        self.size -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 从任意节点删除</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, node: Node)</span>:</span></span><br><span class="line">        <span class="comment"># 如果node= None ,默认删除尾部节点</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            node = self.tail</span><br><span class="line">        <span class="keyword">if</span> node == self.tail:</span><br><span class="line">            self.__del_tail()</span><br><span class="line">        <span class="keyword">elif</span> node == self.head:</span><br><span class="line">            self.__del_head()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node.prev.next = node.next</span><br><span class="line">            node.next.prev = node.prev</span><br><span class="line">            self.size -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print</span><span class="params">(self)</span>:</span></span><br><span class="line">        p = self.head</span><br><span class="line">        line = <span class="string">""</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            line += <span class="string">"%s"</span> % p</span><br><span class="line">            p = p.next</span><br><span class="line">            <span class="keyword">if</span> p:</span><br><span class="line">                line += <span class="string">"=&gt;"</span></span><br><span class="line">        print(line)</span><br></pre></td></tr></table></figure><h3 id="先进先出算法（FIFO）"><a href="#先进先出算法（FIFO）" class="headerlink" title="先进先出算法（FIFO）"></a>先进先出算法（FIFO）</h3><p>✦把缓存看作是一个先进先出的队列</p><p>✦优先替换最先进入队列的字块</p><p><img src="\img\FIFO.png" alt></p><p>python 实现代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> DoubleLinkedList <span class="keyword">import</span> DoubleLinkedList, Node</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FIFOCache</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity)</span>:</span></span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line">        self.map = &#123;&#125;</span><br><span class="line">        self.list = DoubleLinkedList(self.capacity)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.map:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node: Node = self.map.get(key)</span><br><span class="line">            <span class="keyword">return</span> node.value</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.capacity == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"容量为0"</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.map:</span><br><span class="line">            node: Node = self.map.get(key)</span><br><span class="line">            self.list.remove(node)</span><br><span class="line">            node.value = value</span><br><span class="line">            self.list.add_tail(node)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> self.size == self.capacity:</span><br><span class="line">                node = self.list.del_tail()</span><br><span class="line">                <span class="keyword">del</span> self.map[node.key]</span><br><span class="line">                self.size -= <span class="number">1</span></span><br><span class="line">            node = Node(key, value)</span><br><span class="line">            self.list.add_tail(node)</span><br><span class="line">            self.map[key] = node</span><br><span class="line">            self.size += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.list.print()</span><br></pre></td></tr></table></figure><h3 id="最不经常使用算法（LFU）"><a href="#最不经常使用算法（LFU）" class="headerlink" title="最不经常使用算法（LFU）"></a>最不经常使用算法（LFU）</h3><p>✦优先淘汰最不经常使用的字块</p><p>✦需要额外的空间记录字块的使用频率</p><p>✦ 同频率节点按FIFO算法淘汰</p><p><img src="\img\LFU.png" alt></p><p><img src="\img\LFU2.png" alt></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> DoubleLinkedList <span class="keyword">import</span> DoubleLinkedList, Node</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUNode</span><span class="params">(Node)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        self.freq = <span class="number">0</span>  <span class="comment"># 频率</span></span><br><span class="line">        super(LFUNode, self).__init__(key, value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity)</span>:</span></span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.map = &#123;&#125;</span><br><span class="line">        <span class="comment"># key :频率  value: 频率对应的双向链表</span></span><br><span class="line">        self.freq_map = dict()</span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 更新节点频率的操作</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_freq</span><span class="params">(self, node: LFUNode)</span>:</span></span><br><span class="line">        freq = node.freq</span><br><span class="line">        <span class="comment"># 删除</span></span><br><span class="line">        node = self.freq_map[freq].remove(node)</span><br><span class="line">        <span class="keyword">if</span> self.freq_map[freq].size == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">del</span> self.freq_map[freq]</span><br><span class="line">        <span class="comment"># 更新</span></span><br><span class="line">        freq += <span class="number">1</span></span><br><span class="line">        node.freq = freq</span><br><span class="line">        <span class="keyword">if</span> freq <span class="keyword">not</span> <span class="keyword">in</span> self.freq_map:</span><br><span class="line">            self.freq_map[freq] = DoubleLinkedList()</span><br><span class="line">        self.freq_map[freq].add_tail(node)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.map:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        node = self.map.get(key)</span><br><span class="line">        self.update_freq(node)</span><br><span class="line">        <span class="keyword">return</span> node.value</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.capacity == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"容量为0"</span></span><br><span class="line">        <span class="comment"># 缓存命中</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.map:</span><br><span class="line">            node = self.map.get(key)</span><br><span class="line">            node.value = value</span><br><span class="line">            self.update_freq(node)</span><br><span class="line">        <span class="comment"># 缓存没命中</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> self.capacity == self.size:</span><br><span class="line">                min_freq = min(self.freq_map)</span><br><span class="line">                node = self.freq_map[min_freq].del_tail()</span><br><span class="line">                <span class="keyword">del</span> self.map[node.key]</span><br><span class="line">                self.size -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            node = LFUNode(key, value)</span><br><span class="line">            node.freq = <span class="number">1</span></span><br><span class="line">            self.map[key] = node</span><br><span class="line">            <span class="keyword">if</span> node.freq <span class="keyword">not</span> <span class="keyword">in</span> self.freq_map:</span><br><span class="line">                self.freq_map[node.freq] = DoubleLinkedList()</span><br><span class="line">            node = self.freq_map[node.freq].add_tail(node)</span><br><span class="line">            self.size += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"***************"</span>)</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> self.freq_map.items():</span><br><span class="line">            print(<span class="string">f"频率= <span class="subst">&#123;k&#125;</span>"</span>)</span><br><span class="line">            self.freq_map[k].print()</span><br></pre></td></tr></table></figure><h3 id="最近最少使用算法（LRU）"><a href="#最近最少使用算法（LRU）" class="headerlink" title="最近最少使用算法（LRU）"></a>最近最少使用算法（LRU）</h3><p>✦优先淘汰一段时间内没有使用的字块</p><p>✦有多种实现方法，一般使用双向链表</p><p>✦把当前访问节点置于链表前面（保证链表头部节点是最近使用的）</p><p>✦缓存淘汰时，把链表尾部的节点淘汰即可</p><p><img src="\img\LRU列子.png" alt></p><p>python 代码实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> DoubleLinkedList <span class="keyword">import</span> DoubleLinkedList, Node</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity)</span>:</span></span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.map = &#123;&#125;</span><br><span class="line">        self.list = DoubleLinkedList(self.capacity)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.map:</span><br><span class="line">            node: Node = self.map[key]</span><br><span class="line">            self.list.remove(node)</span><br><span class="line">            self.list.add_head(node)</span><br><span class="line">            <span class="keyword">return</span> node.value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.map:</span><br><span class="line">            node: Node = self.map.get(key)</span><br><span class="line">            self.list.remove(node)</span><br><span class="line">            node.value = value</span><br><span class="line">            self.list.add_head(node)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node = Node(key, value)</span><br><span class="line">            <span class="comment"># 缓存已经满了</span></span><br><span class="line">            <span class="keyword">if</span> self.list.capacity &lt;= self.list.size:</span><br><span class="line">                old_node = self.list.del_tail()</span><br><span class="line">                self.map.pop(old_node.key)</span><br><span class="line">        </span><br><span class="line">            <span class="comment"># 缓存没满</span></span><br><span class="line">            self.list.add_head(node)</span><br><span class="line">            self.map[key] = node</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.list.print()</span><br></pre></td></tr></table></figure><h4 id="LRU-问题：时间复杂度？-多线程下怎么优化"><a href="#LRU-问题：时间复杂度？-多线程下怎么优化" class="headerlink" title="LRU  问题：时间复杂度？ 多线程下怎么优化?"></a>LRU  问题：时间复杂度？ 多线程下怎么优化?</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目前替换策略有四种算法：&lt;/p&gt;
&lt;h3 id=&quot;随机算法&quot;&gt;&lt;a href=&quot;#随机算法&quot; class=&quot;headerlink&quot; title=&quot;随机算法&quot;&gt;&lt;/a&gt;随机算法&lt;/h3&gt;&lt;h4 id=&quot;双向链表python实现&quot;&gt;&lt;a href=&quot;#双向链表python实现&quot;
      
    
    </summary>
    
    
      <category term="python" scheme="http://gilgameshzzz.github.io/tags/python/"/>
    
      <category term="算法" scheme="http://gilgameshzzz.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>初识Netty</title>
    <link href="http://gilgameshzzz.github.io/2020/04/15/Netty/"/>
    <id>http://gilgameshzzz.github.io/2020/04/15/Netty/</id>
    <published>2020-04-14T16:00:00.000Z</published>
    <updated>2020-04-19T15:02:22.348Z</updated>
    
    <content type="html"><![CDATA[<h3 id="I-O-模型基本说明"><a href="#I-O-模型基本说明" class="headerlink" title="I/O 模型基本说明"></a>I/O 模型基本说明</h3><p>1、I/O 模型简单的理解：就是用什么样的通道进行数据的发送和接收，很大程度上决定了程序通信的性能</p><p>2、Java共支持3种网络编程模型/IO模式：BIO、NIO、AIO</p><h4 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h4><p>3、Java BIO ： 同步并阻塞(<strong>传统阻塞型</strong>)，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销 </p><p><img src="\img\BIO工作原理.png" alt></p><p><strong>BIO流程：</strong></p><p>1)服务器端启动一个ServerSocket</p><p>2)客户端启动Socket对服务器进行通信，默认情况下服务器端需要对每个客户 建立一个线程与之通讯</p><p>3)客户端发出请求后, 先咨询服务器是否有线程响应，如果没有则会等待，或者被拒绝</p><p>4)如果有响应，客户端线程会等待请求结束后，在继续执行</p><p><strong>缺点分析：</strong></p><p>1)每个请求都需要创建独立的线程，与对应的客户端进行数据 Read，业务处理，数据 Write 。</p><p>2)当并发数较大时，需要<strong>创建大量线程来处理连接</strong>，系统资源占用较大。</p><p>3)连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在 Read 操作上，造成线程资源浪费</p><h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><p>4、Java NIO ： <strong>同步非阻塞</strong>，服务器实现模式为一个线程处理多个请求(连接)，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求就进行处理 【简单示意图】</p><p>①NIO 有三大核心部分：<font size="4" color="#0000FF">Channel(通道)<strong>，</strong>Buffer(缓冲区)<strong>, </strong>Selector(选择器）</font></p><p>②NIO是 面向 <font size="4" color="#FF1493">缓冲区 ，或者面向块 </font>编程的。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性，使用它可以提供<strong>非阻塞</strong>式的高伸缩性网络</p><p>③HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级</p><p><img src="\img\NIO.png" alt="NIO"></p><p><strong>NIO存在的问题</strong></p><p>1) NIO 的类库和 API 繁杂，使用麻烦：需要熟练掌握 Selector、ServerSocketChannel、SocketChannel、ByteBuffer 等。</p><p>2) 需要具备其他的额外技能：要熟悉 Java 多线程编程，因为 NIO 编程涉及到 Reactor 模式，你必须对多线程和网络编程非常熟悉，才能编写出高质量的 NIO 程序。</p><p>3) 开发工作量和难度都非常大：例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常流的处理等等。</p><p>4) JDK NIO 的 Bug：例如臭名昭著的 Epoll Bug，它会导致 Selector 空轮询，最终导致 CPU 100%。直到 JDK 1.7 版本该问题仍旧存在，没有被根本解决</p><h4 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h4><p>5、Java AIO(NIO.2) ： <strong>异步非阻塞</strong>，AIO 引入异步通道的概念，采用了 Proactor 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用</p><p>①、JDK 7 引入了 Asynchronous I/O，即 AIO。在进行 I/O 编程中，常用到两种模式：Reactor和 Proactor。Java 的 NIO 就是 Reactor，当有事件触发时，服务器端得到通知，进行相应的处理</p><p>②、AIO 即 NIO2.0，叫做异步不阻塞的 IO。AIO 引入异步通道的概念，采用了 Proactor 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用</p><p>③、目前 AIO 还没有广泛应用，Netty 也是基于NIO, 而不是AIO</p><h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><h4 id="传统阻塞I-O模型"><a href="#传统阻塞I-O模型" class="headerlink" title="传统阻塞I/O模型"></a>传统阻塞I/O模型</h4><p><img src="\img\传统IO.png" alt></p><p>黄色的框表示对象， 蓝色的框表示线程，白色的框表示方法(API)。</p><p><strong>存在的问题：</strong>1、当并发数很大，就会创建大量的线程，占用很大系统资源</p><p>2、连接创建后，如果当前线程暂时没有数据可读，该线程会阻塞在read 操作，造成线程资源浪费</p><h4 id="Reactor"><a href="#Reactor" class="headerlink" title="Reactor"></a>Reactor</h4><p>主要针对传统2个缺点：基于 I/O 复用模型、基于线程池复用线程资源</p><p><strong>Reactor单线程</strong></p><p><img src="\img\Reactor单线程.png" alt></p><p><strong>优缺点：</strong></p><p>1)<strong>优点：</strong> 模型简单，没有多线程、进程通信、竞争的问题，全部都在一个线程中完成</p><p>2)<strong>缺点：</strong>性能问题，只有一个线程，无法完全发挥多核 CPU 的性能。Handler 在处理某个连接上的业务时，整个进程无法处理其他连接事件，很容易导致性能瓶颈</p><p>3)<strong>缺点：</strong>可靠性问题，线程意外终止，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障</p><p>4)<strong>使用场景：</strong>客户端的数量有限，业务处理非常快速，比如 Redis在业务处理的时间复杂度 O(1) 的情况</p><p><strong>Reactor多线程</strong></p><p><img src="\img\Reactor多线程.png" alt></p><p><strong>优缺点</strong></p><p>1)<strong>优点：</strong>可以充分的利用多核cpu 的处理能力</p><p>2)<strong>缺点：</strong>多线程数据共享和访问比较复杂， reactor 处理所有的事件的监听和响应，在单线程运行， 在高并发场景容易出现性能瓶颈.</p><p><strong>Reactor主从模型</strong></p><p>主从Reactor多线程：多个acceptor的NIO线程池用于接受客户端的连接</p><p><img src="\img\Reactor主从模型.png" alt></p><p><strong>优缺点</strong></p><p>1)<strong>优点：</strong>父线程与子线程的数据交互简单职责明确，父线程只需要接收新连接，子线程完成后续的业务处理。</p><p>2)<strong>优点：</strong>父线程与子线程的数据交互简单，Reactor 主线程只需要把新连接传给子线程，子线程无需返回数据。</p><p>3)<strong>缺点：</strong>编程复杂度较高</p><p><strong>结合实例：</strong>这种模型在许多项目中广泛使用，包括 Nginx 主从 Reactor 多进程模型，Memcached 主从多线程，Netty 主从多线程模型的支持</p><h4 id="种模式用生活案例来理解"><a href="#种模式用生活案例来理解" class="headerlink" title="种模式用生活案例来理解"></a>种模式用生活案例来理解</h4><p>1)单 Reactor 单线程，前台接待员和服务员是同一个人，全程为顾客服</p><p>2)单 Reactor 多线程，1 个前台接待员，多个服务员，接待员只负责接待</p><p>3)主从 Reactor 多线程，多个前台接待员，多个服务生</p><h3 id="Netty介绍"><a href="#Netty介绍" class="headerlink" title="Netty介绍"></a>Netty介绍</h3><p>Netty是一个异步的、基于事件驱动的网络应用框架，用以快速开发高性能、高可靠性的网络 IO 程序。</p><p>Netty主要针对在TCP协议下，面向Clients端的高并发应用，或者Peer-to-Peer场景下的大量数据持续传输的应用。</p><p>Netty本质是一个NIO框架，适用于服务器通讯相关的多种应用场景</p><p><strong>优点：</strong> 并发高 - NIO（非阻塞IO）、传输快-零拷贝</p><h3 id="Netty-的零拷贝"><a href="#Netty-的零拷贝" class="headerlink" title="Netty 的零拷贝"></a>Netty 的零拷贝</h3><h4 id="传统意义的拷贝"><a href="#传统意义的拷贝" class="headerlink" title="传统意义的拷贝"></a>传统意义的拷贝</h4><p>在发送数据的时候，传统的实现方式是：</p><p>File.read(bytes)；Socket.send(bytes)<br>这种方式需要四次数据拷贝和四次上下文切换：</p><ol><li><p>数据从磁盘读取到内核的read buffer</p></li><li><p>数据从内核缓冲区拷贝到用户缓冲区</p></li><li>数据从用户缓冲区拷贝到内核的socket buffer</li><li>数据从内核的socket buffer拷贝到网卡接口（硬件）的缓冲区</li></ol><h4 id="零拷贝的概念"><a href="#零拷贝的概念" class="headerlink" title="零拷贝的概念"></a>零拷贝的概念</h4><p>明显上面的第二步和第三步是没有必要的，通过java的FileChannel.transferTo方法，可以避免上面两次多余的拷贝（当然这需要底层操作系统支持）</p><ol><li><p>调用transferTo,数据从文件由DMA引擎拷贝到内核read buffer</p></li><li><p>接着DMA从内核read buffer将数据拷贝到网卡接口buffer</p></li></ol><p>上面的两次操作都不需要CPU参与，所以就达到了零拷贝。</p><h4 id="Netty中的零拷贝"><a href="#Netty中的零拷贝" class="headerlink" title="Netty中的零拷贝"></a>Netty中的零拷贝</h4><p>主要体现在三个方面：</p><p><strong>1、bytebuffer</strong></p><p>Netty发送和接收消息主要使用bytebuffer，bytebuffer使用对外内存（DirectMemory）直接进行Socket读写。</p><p>原因：如果使用传统的堆内存进行Socket读写，JVM会将堆内存buffer拷贝一份到直接内存中然后再写入socket，多了一次缓冲区的内存拷贝。DirectMemory中可以直接通过DMA发送到网卡接口</p><p><strong>2、Composite Buffers</strong></p><p>传统的ByteBuffer，如果需要将两个ByteBuffer中的数据组合到一起，我们需要首先创建一个size=size1+size2大小的新的数组，然后将两个数组中的数据拷贝到新的数组中。但是使用Netty提供的组合ByteBuf，就可以避免这样的操作，因为CompositeByteBuf并没有真正将多个Buffer组合起来，而是保存了它们的引用，从而避免了数据的拷贝，实现了零拷贝。</p><p><strong>3、对于FileChannel.transferTo的使用</strong></p><p>Netty中使用了FileChannel的transferTo方法，该方法依赖于操作系统实现零拷贝。</p><h3 id="Netty工作原理示意图"><a href="#Netty工作原理示意图" class="headerlink" title="Netty工作原理示意图"></a>Netty工作原理示意图</h3><p><img src="\img\Netty工作.png" alt></p><p>1、Netty抽象出两组线程池 BossGroup 专门负责接收客户端的连接, WorkerGroup 专门负责网络的读写</p><p>2、BossGroup 和 WorkerGroup 类型都是 NioEventLoopGroup</p><p>3、NioEventLoopGroup 相当于一个事件循环组, 这个组中含有多个事件循环 ，每一个事件循环是 NioEventLoop</p><p>4、NioEventLoop 表示一个不断循环的执行处理任务的线程， 每个NioEventLoop 都有一个selector , 用于监听绑定在其上的socket的网络通讯</p><p>5、NioEventLoopGroup 可以有多个线程, 即可以含有多个NioEventLoop</p><p>6、每个Boss NioEventLoop 循环执行的步骤有3步</p><p>1).轮询accept 事件</p><p>2).处理accept 事件 , 与client建立连接 , 生成NioScocketChannel , 并将其注册到某个worker NIOEventLoop 上的 selector</p><p>3).处理任务队列的任务 ， 即 runAllTasks</p><p>7、每个 Worker NIOEventLoop 循环执行的步骤</p><p>1).轮询read, write 事件</p><p>2).处理i/o事件， 即read , write 事件，在对应NioScocketChannel 处理</p><p>3).处理任务队列的任务 ， 即 runAllTasks</p><p>8、 每个Worker NIOEventLoop  处理业务时，会使用pipeline(管道), pipeline 中包含了 channel , 即通过pipeline 可以获取到对应通道, 管道中维护了很多的 处理器</p><h4 id="Netty执行流程"><a href="#Netty执行流程" class="headerlink" title="Netty执行流程"></a>Netty执行流程</h4><p><strong>服务端：</strong></p><p><img src="\img\Netty服务端.png" alt></p><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     <span class="comment">// 创建BossGroup和WorkerGoup两个线程组</span></span><br><span class="line">     <span class="comment">// bossGoup只是处理连接请求，真正和客户端业务处理，会交给workerGoup完成</span></span><br><span class="line">     <span class="comment">// 两个都是无限循环</span></span><br><span class="line">     <span class="comment">// bossGroup、workerGoup含有的子线程(NioEventLoop)个数默认微实际CPU核数*2</span></span><br><span class="line">     EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">     EventLoopGroup workerGoup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">     <span class="comment">//创建服务器端的启动对象，配置参数</span></span><br><span class="line">     ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">     <span class="comment">//使用链式编程来进行设置</span></span><br><span class="line">     <span class="keyword">try</span>&#123;</span><br><span class="line">         bootstrap.group(bossGroup, workerGoup) <span class="comment">//设置两个线程组</span></span><br><span class="line">             .channel(NioServerSocketChannel.class) <span class="comment">//使用NioSocketChannel作为服务器的通道实现</span></span><br><span class="line">             .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>) <span class="comment">// 设置线程队列得到连接个数</span></span><br><span class="line">             .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>) <span class="comment">// 设置保持活动连接状态</span></span><br><span class="line">             .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123; <span class="comment">//创建一个通道测试对象，匿名对象</span></span><br><span class="line">                 <span class="comment">// 给pipeline设置处理器</span></span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                     ch.pipeline().addLast(<span class="keyword">new</span> NettyServerHandler());</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;); <span class="comment">// 给workerGoup的EventLoop对应的管道设置处理器</span></span><br><span class="line">         System.out.println(<span class="string">"。。。。服务器已启动。。。。"</span>);</span><br><span class="line">         <span class="comment">// 绑定一个端口并且同步，生成了一个ChannelFuture对象</span></span><br><span class="line">         ChannelFuture cf = bootstrap.bind(<span class="number">6668</span>).sync(); <span class="comment">// 启动服务器并绑定端口</span></span><br><span class="line">         <span class="comment">// 对关闭通道进行监听</span></span><br><span class="line">         cf.channel().closeFuture().sync();</span><br><span class="line">     &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">         bossGroup.shutdownGracefully();</span><br><span class="line">         workerGoup.shutdownGracefully();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、创建ServerBootStrap实例</p><p>2、设置并绑定Reactor线程池：EventLoopGroup，EventLoop就是处理所有注册到本线程的Selector上面的Channel</p><p>3、设置并绑定服务端的channel</p><p>4、创建处理网络事件的ChannelPipeline和handler，网络时间以流的形式在其中流转，handler完成多数的功能定制：比如编解码 SSl安全认证</p><p>5、绑定并启动监听端口</p><p>6、当轮训到准备就绪的channel后，由Reactor线程：NioEventLoop执行pipline中的方法，最终调度并执行channelHandler </p><p><strong>客户端：</strong></p><p><img src="\img\Netty客户端.png" alt></p><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 客户端需要一个事件循环组</span></span><br><span class="line">    EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建客户端启动对象</span></span><br><span class="line">        <span class="comment">// 注意客户段使用的不是ServerBootstrap 而是bootstrap</span></span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        <span class="comment">//设置相关参数</span></span><br><span class="line">        bootstrap.group(group) <span class="comment">// 设置线程组</span></span><br><span class="line">            .channel(NioSocketChannel.class)  <span class="comment">// 设置客户端通道的实现类（反射）</span></span><br><span class="line">            .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> NettyClientHandler()); <span class="comment">// 加入自己的处理器</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        System.out.println(<span class="string">"客户端 ok//"</span>);</span><br><span class="line">        <span class="comment">// 启动客户端去连接服务器端，关于ChannelFuture要分析，涉及到netty异步模型</span></span><br><span class="line">        ChannelFuture channelFuture = bootstrap.connect(<span class="string">"127.0.0.1"</span>, <span class="number">6668</span>).sync();</span><br><span class="line">        <span class="comment">// 给关闭通道进行监听</span></span><br><span class="line">        channelFuture.channel().closeFuture().sync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        group.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://juejin.im/post/5bdaf8ea6fb9a0227b02275a" target="_blank" rel="noopener">参考链接 –掘金</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;I-O-模型基本说明&quot;&gt;&lt;a href=&quot;#I-O-模型基本说明&quot; class=&quot;headerlink&quot; title=&quot;I/O 模型基本说明&quot;&gt;&lt;/a&gt;I/O 模型基本说明&lt;/h3&gt;&lt;p&gt;1、I/O 模型简单的理解：就是用什么样的通道进行数据的发送和接收，很大程度
      
    
    </summary>
    
    
      <category term="Java" scheme="http://gilgameshzzz.github.io/tags/Java/"/>
    
      <category term="Netty" scheme="http://gilgameshzzz.github.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>MyBatisPlus入门</title>
    <link href="http://gilgameshzzz.github.io/2020/04/14/MyBatisPlusLearning/"/>
    <id>http://gilgameshzzz.github.io/2020/04/14/MyBatisPlusLearning/</id>
    <published>2020-04-13T16:00:00.000Z</published>
    <updated>2020-04-19T15:13:05.023Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><p>使用第三方组件：<br><br>1、导入对应的依赖<br>2、研究依赖如何配置<br>3、代码如何编写<br>4、提高扩展技术能力<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">步骤</span><br></pre></td></tr></table></figure></p><p>1、创建数据库，2、创建数据表，3、编写项目，初始化项目，4、导入依赖,注意<strong>不要同时导入Mybatis和MyBatis-plus</strong><br>引入 spring-boot-starter、spring-boot-starter-test、mybatis-plus-boot-starter、lombok、h2 依赖：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- lombok --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 数据库驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- mybatisPlus 并不是官方的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.1.tmp<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>Mysql 5和8驱动不同5：com.mysql.jdbc.Driver;<br>8：com.mysql.cj.jdbc.Driver、需要增加时区的配置（驱动8兼容mysql 5版本）<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mysql 8</span></span><br><span class="line"><span class="string">spring.datasource.username=root</span></span><br><span class="line"><span class="string">spring.datasource.password=123456</span></span><br><span class="line"><span class="string">spring.datasource.url=jdbc:mysql://localhost:3306/数据库?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2B8</span></span><br><span class="line"><span class="string">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure></p><h4 id="主键生成策略"><a href="#主键生成策略" class="headerlink" title="主键生成策略"></a>主键生成策略</h4><p>分布式系统唯一id生成：<a href="https://www.cnblogs.com/haoxinyue/p/5208136.html" target="_blank" rel="noopener">https://www.cnblogs.com/haoxinyue/p/5208136.html</a></p><h4 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h4><p>snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。</p><h2 id="代码自动生成器"><a href="#代码自动生成器" class="headerlink" title="代码自动生成器"></a>代码自动生成器</h2><p>MyBatis-Plus 从 3.0.3 之后移除了代码生成器与模板引擎的默认依赖，需要手动添加相关依赖：<br>添加 代码生成器 依赖<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.1.tmp<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>添加 模板引擎 依赖，MyBatis-Plus 支持 Velocity（默认）、Freemarker、Beetl，用户可以选择自己熟悉的模板引擎，如果都不满足您的要求，可以采用自定义模板引擎。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.velocity<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>velocity-engine-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xkcoding.helloworld;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.DbType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.FieldFill;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.IdType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.AutoGenerator;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.DataSourceConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.GlobalConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.PackageConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.StrategyConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.po.TableFill;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.rules.DateType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码自动生成器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoGeneratorCode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AutoGenerator mpg = <span class="keyword">new</span> AutoGenerator();</span><br><span class="line">        <span class="comment">// 配置策略</span></span><br><span class="line">        <span class="comment">//1、全局策略</span></span><br><span class="line">        GlobalConfig gc = <span class="keyword">new</span> GlobalConfig();</span><br><span class="line">        String projectPath = System.getProperty(<span class="string">"user.dir"</span>);</span><br><span class="line">        gc.setOutputDir(projectPath+<span class="string">"/src/main/java"</span>); <span class="comment">// 设置生成地址</span></span><br><span class="line">        gc.setAuthor(<span class="string">"Amadeus"</span>);  <span class="comment">// 设置作者</span></span><br><span class="line">        gc.setOpen(<span class="keyword">false</span>); <span class="comment">//文件创建好是否打开文件管理器</span></span><br><span class="line">        gc.setFileOverride(<span class="keyword">false</span>); <span class="comment">// 是否覆盖文件</span></span><br><span class="line">        gc.setServiceName(<span class="string">"%sService"</span>); <span class="comment">//去Service的I 前缀</span></span><br><span class="line">        gc.setIdType(IdType.ID_WORKER);</span><br><span class="line">        gc.setDateType(DateType.ONLY_DATE);</span><br><span class="line">        gc.setSwagger2(<span class="keyword">true</span>);</span><br><span class="line">        mpg.setGlobalConfig(gc);</span><br><span class="line">        <span class="comment">// 设置数据源</span></span><br><span class="line">        DataSourceConfig dsc = <span class="keyword">new</span> DataSourceConfig();</span><br><span class="line">        dsc.setUrl(<span class="string">"jdbc:mysql://localhost:3306/muxin-dev?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2B8"</span>);</span><br><span class="line">        dsc.setDriverName(<span class="string">"com.mysql.cj.jdbc.Driver"</span>);</span><br><span class="line">        dsc.setUsername(<span class="string">"root"</span>);</span><br><span class="line">        dsc.setPassword(<span class="string">"密码"</span>);</span><br><span class="line">        dsc.setDbType(DbType.MYSQL); <span class="comment">// 数据库类型</span></span><br><span class="line">        mpg.setDataSource(dsc);</span><br><span class="line">        <span class="comment">// 包的配置  生成哪些包</span></span><br><span class="line">        PackageConfig pc = <span class="keyword">new</span> PackageConfig();</span><br><span class="line">        pc.setModuleName(<span class="string">"blog"</span>); <span class="comment">// 模块名</span></span><br><span class="line">        pc.setParent(<span class="string">"com.xkcoding.helloworld"</span>); <span class="comment">// 生成在哪个包下</span></span><br><span class="line">        pc.setEntity(<span class="string">"entity"</span>); <span class="comment">// 生成实体 models</span></span><br><span class="line">        pc.setMapper(<span class="string">"mapper"</span>);</span><br><span class="line">        pc.setService(<span class="string">"service"</span>);</span><br><span class="line">        pc.setController(<span class="string">"controller"</span>);</span><br><span class="line">        mpg.setPackageInfo(pc);</span><br><span class="line">        <span class="comment">// 策略配置</span></span><br><span class="line">        StrategyConfig strategy = <span class="keyword">new</span> StrategyConfig();</span><br><span class="line">        strategy.setInclude(<span class="string">"user"</span>); <span class="comment">// 设置要映射的表名，可以写多个</span></span><br><span class="line">         strategy.setTablePrefix(<span class="keyword">new</span> String[] &#123; <span class="string">"user_"</span> &#125;);<span class="comment">// 此处可以修改为表的前缀</span></span><br><span class="line">        strategy.setNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">        strategy.setColumnNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">        strategy.setEntityLombokModel(<span class="keyword">true</span>); <span class="comment">// 自动lombok</span></span><br><span class="line">        strategy.setLogicDeleteFieldName(<span class="string">"deleted"</span>); <span class="comment">// 设置逻辑删除</span></span><br><span class="line">        <span class="comment">// 自动填充配置</span></span><br><span class="line">        TableFill gmtCreate = <span class="keyword">new</span> TableFill(<span class="string">"gmt_create"</span>, FieldFill.INSERT);</span><br><span class="line">        TableFill gmtModified = <span class="keyword">new</span> TableFill(<span class="string">"gmt_modified"</span>, FieldFill.INSERT_UPDATE);</span><br><span class="line">        ArrayList&lt;TableFill&gt; tableFills = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        tableFills.add(gmtCreate);</span><br><span class="line">        tableFills.add(gmtModified);</span><br><span class="line">        strategy.setTableFillList(tableFills);</span><br><span class="line">        <span class="comment">// 乐观锁</span></span><br><span class="line">        strategy.setVersionFieldName(<span class="string">"version"</span>);</span><br><span class="line">        strategy.setRestControllerStyle(<span class="keyword">true</span>);</span><br><span class="line">        strategy.setControllerMappingHyphenStyle(<span class="keyword">true</span>); <span class="comment">// localhost:8080/hello_id_2</span></span><br><span class="line">        mpg.setStrategy(strategy);</span><br><span class="line">        mpg.execute(); <span class="comment">// 执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;快速入门&quot;&gt;&lt;a href=&quot;#快速入门&quot; class=&quot;headerlink&quot; title=&quot;快速入门&quot;&gt;&lt;/a&gt;快速入门&lt;/h1&gt;&lt;p&gt;使用第三方组件：&lt;br&gt;&lt;br&gt;1、导入对应的依赖&lt;br&gt;2、研究依赖如何配置&lt;br&gt;3、代码如何编写&lt;br&gt;4、提高扩展技
      
    
    </summary>
    
    
      <category term="Java" scheme="http://gilgameshzzz.github.io/tags/Java/"/>
    
      <category term="MyBatisPlus" scheme="http://gilgameshzzz.github.io/tags/MyBatisPlus/"/>
    
  </entry>
  
  <entry>
    <title>Java常见面试题</title>
    <link href="http://gilgameshzzz.github.io/2020/04/14/javaQuestions/"/>
    <id>http://gilgameshzzz.github.io/2020/04/14/javaQuestions/</id>
    <published>2020-04-13T16:00:00.000Z</published>
    <updated>2020-04-24T10:22:48.857Z</updated>
    
    <content type="html"><![CDATA[<p>================================<br></p><h4 id="设计模式分为：创建型模式（单例、工厂、抽象工厂）、结构型模式（代理、组合、装饰）、行为型模式（策略、模板方法、迭代器）"><a href="#设计模式分为：创建型模式（单例、工厂、抽象工厂）、结构型模式（代理、组合、装饰）、行为型模式（策略、模板方法、迭代器）" class="headerlink" title="设计模式分为：创建型模式（单例、工厂、抽象工厂）、结构型模式（代理、组合、装饰）、行为型模式（策略、模板方法、迭代器）"></a>设计模式分为：创建型模式（单例、工厂、抽象工厂）、结构型模式（代理、组合、装饰）、行为型模式（策略、模板方法、迭代器）</h4><p>================================<br>问：请解释一下对象的创建过程?(半初始化)</p><p>答：1、申请内存，<strong>给对象里的成员变量设为默认值</strong>(半初始化)，<br><br>2、调用对象的构造方法，再给对象里的成员变量设初始值，<br><br>3、将变量名与对象进行关联<br></p><p><img src="/img/Object.png" alt="image-20200331140607400"></p><p>===============================<br></p><p>DCL（Double Check Lock）单例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mgr</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Mgr Instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Mgr <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Mgr.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(Instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Mgr();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>===============================<br><br>网站是如何进行访问的：<br><br>1、输入一个域名，回车；<br><br>2、检查本机的hosts配置文件下有没有这个域名映射；有就返回对应的ip地址<br><br>没有，就去DNS服务器找，找到返回，找不到就返回找不到<br><br>===========Jvm=================<br></p><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>类加载器：作用加载Class文件<br><br>1、虚拟机自带的加载器<br><br>2、启动类（根）加载器<br><br>3、扩展类加载器<br><br>4、应用程序加载器<br><br>双亲委派机制：主要是为了安全；<br><br><strong>是什么：</strong> 当某个类加载器需要加载某个.class文件时，它首先把这个任务委托给他的上级类加载器，递归这个操作，如果上级的类加载器没有加载，自己才会去加载这个类。 <br><br><strong>作用：</strong> 1、防止重复加载同一个.class。通过委托去向上面问一问，加载过了，就不用再加载一遍。保证数据安全。<br><br>2、保证核心.class不能被篡改。通过委托方式，不会去篡改核心.clas，即使篡改也不会去加载，即使加载也不会是同一个.class对象了。不同的加载器加载同一个.class也不是同一个Class对象。这样保证了Class执行安全。<br></p><p>App（系统类加载器） –&gt;Ext（标准扩展类加载器） –&gt;BOOT（启动类加载器）<br><br>1、类加载器收到类加载的请求<br><br>2、将这个请求向上委托给父类加载器去完成，一直向上委托，直到启动类加载器<br><br>3、启动加载器检查是否能够加载当前这个类，能加载就结束，使用当前的加载器，否则，抛出异常，通知子加载器进行加载<br><br>4、重复步骤3；<br>常见错误 class NOt Found~</p><h2 id="native"><a href="#native" class="headerlink" title="native"></a>native</h2><p>凡是带了native关键字的，说明java的作用范围达不到了，会去调用底层C语言的库。会进入本地方法栈，调用本地方法本地接口 JNI </p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区是被所有线程共享的。主要存储<strong>静态变量，常量，类信息、运行时的常量池存在方法区，但是实例变量存在堆内存中，和方法区无关，</strong> 也就是存储 static、final、Class、常量池</p><p>===============================</p><h1 id="问题一：请谈谈你对volatile的理解"><a href="#问题一：请谈谈你对volatile的理解" class="headerlink" title="问题一：请谈谈你对volatile的理解"></a>问题一：请谈谈你对volatile的理解</h1><p>一、volatile 是java虚拟机提供的轻量级的同步机制；<strong>有三大特性：</strong> 1.保证可见性；2.不保证原子性；3.禁止指令重排（volatile实现禁止指令重排优化，从而避免多线程环境下程序出现<strong>乱序</strong>执行的现象）<br><br>二、JMM(java内存模型java Memory Model) <strong>特性：可见性，原子性，有序性</strong><br><em>在变量前加上volatile，一个线程对这个变量进行修改，就及时通知其他线程，主物理内存的变量值已经被修改，其他线程的变量值就修改了</em></p><p><img src="/img/java线程.png" alt="JMM模型"></p><p>本身是一种抽象的概念<strong>并不真实存在</strong>，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。</p><h3 id="JMM关于同步的规定："><a href="#JMM关于同步的规定：" class="headerlink" title="JMM关于同步的规定："></a>JMM关于同步的规定：</h3><p>1、线程解锁前，必须把共享变量的值刷新回主内存；<br><br>2、线程加锁前，必须读取主内存的最新值到自己的工作内存；<br><br>3、加锁解锁是同一把锁；</p><p>由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存（或称栈空间），工作内存是每个线程的私有数据区域，而java内存模型中规定所有变量都存储在<strong>主内存</strong>，主内存是共享内存区域，所有线程都可以访问，<strong>但线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存</strong>，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程无法访问对方的工作内存，线程间的通信必须通过主内存来完成。</p><h3 id="重排"><a href="#重排" class="headerlink" title="重排"></a>重排</h3><p>计算机在执行程序时，为了提高性能，编译器和处理器的常常会对<strong>指令做重排</strong>，分三种：1、单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致；<br>2、处理器在进行重排序时必须要考虑指令之间的<strong>数据依赖性</strong>；<br>3、多线程环境中线程<em>交替执行</em>，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测。</p><p>源代码 –&gt;编译器优化的重排 –&gt;指令并行的重排 –&gt; 内存系统的重排 –&gt;最终执行的指令</p><h3 id="如何禁止指令重排"><a href="#如何禁止指令重排" class="headerlink" title="如何禁止指令重排"></a>如何禁止指令重排</h3><p>内存屏障（Memory Barrier）又称内存栅栏，是一个CPU指令，它的作用有两个：<br>1、保证特定操作的执行顺序；<br>2、保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）<br><strong>通过插入内存屏障就禁止在内存屏障前后的指令执行重排序优化</strong>，内存屏障另一个作用是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本（保证可见性）</p><h2 id="在哪些方面用到volatile？"><a href="#在哪些方面用到volatile？" class="headerlink" title="在哪些方面用到volatile？"></a>在哪些方面用到volatile？</h2><h3 id="单例模式DCL代码"><a href="#单例模式DCL代码" class="headerlink" title="单例模式DCL代码"></a>单例模式DCL代码</h3><h3 id="单例模式volatile分析"><a href="#单例模式volatile分析" class="headerlink" title="单例模式volatile分析"></a>单例模式volatile分析</h3><p><strong>DCL(双端检锁)机制不一定线程安全，原始是有指令重排序的存在（某一个线程执行到第一次检测，读取到的instance不为null时，instance的引用对象可能没有<em>完成初始化</em>。），加入volatile可以禁止指令重排</strong><br>指令重排只会保证串行语义的执行的一致性（单线程），但并不会关系多线程间的语义一致性。<strong>所以当一条线程访问instance不为null时，由于instance实例未必已初始化完成，也就造成了线程安全问题。</strong></p><h1 id="问题二：CAS"><a href="#问题二：CAS" class="headerlink" title="问题二：CAS"></a>问题二：CAS</h1><p>CAS的全称为 Compare-And-Swap，它是一条CPU并发原语。它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的。</p><p><strong>总结</strong>：CAS比较当前工作内存中的值和主内存中的值，如果相同则执行规定操作，否则继续比较直到主内存和工作内存中的值一致为止。</p><p><strong>CAS应用</strong>：CAS有3个操作数，内存值V，旧的预期值A，要修改的更新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</p><h3 id="CAS底层原理"><a href="#CAS底层原理" class="headerlink" title="CAS底层原理"></a>CAS底层原理</h3><p>CAS并发原语体现在Java中的sun.misc.Unsafe类中的各个方法。调用Unsafe类中的CAS方法，JVM会实现出CAS汇编指令，完全依赖于<strong>硬件</strong>的功能。<strong>并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成所谓的数据不一致问题。</strong></p><p>1、Unsafe 是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地（native）方法来访问，Unsafe 相当于一个后门，基于该类可以直接操作特定内存的数据。Unsafe类存在于sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，因为Java中CAS操作的执行依赖于Unsafe类的方法。<br><strong>注意Unsafe类中的所有方法都是native修饰的，也就是说Unsafe类中的方法都直接调用操作系统底层资源执行相应任务</strong><br><br>2、变量valueOffset，表示该变量值在内存中的偏移地址，因为Unsafe就是根据<strong>内存偏移地址获取数据</strong>的。<br><br>3、变量value用volatile修饰，保证了多线程之间的内存可见性</p><p><img src="/img/1.png" alt><br><img src="/img/2.png" alt><br><img src="/img/3.png" alt></p><h3 id="CAS缺点："><a href="#CAS缺点：" class="headerlink" title="CAS缺点："></a>CAS缺点：</h3><p>1、循环时间长，开销大<br>2、只能保证一个共享变量的原子操作<br>3、引出ABA问题</p><hr><p>CAS —&gt;Unsafe —&gt;CAS底层思想 —&gt;ABA —&gt; 原子引用更新 —&gt; 如何规避ABA问题</p><hr><h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><p>CAS会导致“ABA问题”<br>CAS算法实现一个重要前提需要提取内存中某时刻的数据并在当下时刻比较并替换，那么在这个时间差类会导致数据的变化。</p><p>比如说：一个线程one从内存位置v取出A，这时候另一个线程two也从内存取出A，并且线程two进行了一些操作将值变为B，然后线程two又将V位置的数据变为A，这个时候线程one进行CAS操作发现内存中仍然是A，然后线程one操作成功。<strong>尽管线程one的CAS操作成功，但不代表这个过程就是没有问题的。</strong></p><h3 id="解决ABA问题"><a href="#解决ABA问题" class="headerlink" title="解决ABA问题"></a>解决ABA问题</h3><p>–理解原子引用+新增一种机制，就是修改版本号（类似时间戳）–</p><h1 id="问题三-ArrayList线程不安全，请编写一个不安全的case-并给出解决方案。-map，set也不安全"><a href="#问题三-ArrayList线程不安全，请编写一个不安全的case-并给出解决方案。-map，set也不安全" class="headerlink" title="问题三 ArrayList线程不安全，请编写一个不安全的case,并给出解决方案。(map，set也不安全)"></a>问题三 ArrayList线程不安全，请编写一个不安全的case,并给出解决方案。(map，set也不安全)</h1><p><em>HashSet底层是HashMap, set在使用add方法时（实际使用map.put方法），之所以只用传一个参数，是因为传入的值被当作key,而value是一个默认的PRESENT的object。CopyOnWriteArraySet底层是CopyOnWriteArrayList</em></p><p>解决map线程不安全，可以用ConcurrentHashMap;<br>之所以不安全，是因为add方法没有加锁<br>常见异常：java.util.ConcurrentModificationException</p><h3 id="1、故障现象："><a href="#1、故障现象：" class="headerlink" title="1、故障现象："></a>1、故障现象：</h3><p>java.util.ConcurrentModificationException</p><h3 id="2、导致原因-并发争抢修改；"><a href="#2、导致原因-并发争抢修改；" class="headerlink" title="2、导致原因:并发争抢修改；"></a>2、导致原因:并发争抢修改；</h3><h3 id="3、解决方案"><a href="#3、解决方案" class="headerlink" title="3、解决方案"></a>3、解决方案</h3><p>① 使用vector,加了锁，并发性下降： new vector&lt;&gt;();<br><br>② 使用Collections.synchronizedList(new ArrayList&lt;&gt;());<br><br>③ 使用 new CopyOnWriteArrayList&lt;&gt;();<br><br>  CopyOnWrite容器即写时复制的容器，往一个容器添加元素时，先将当前容器进行copy,复制新的容器object[]newElements,然后新的容器里添加元素，添加完成后再将原容器的引用指向新的容器，这样的好处是可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素，所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器；</p><h1 id="问题四-公平锁-非公平锁-可重入锁-递归锁-自旋锁谈谈你的理解，请手写一个自旋锁："><a href="#问题四-公平锁-非公平锁-可重入锁-递归锁-自旋锁谈谈你的理解，请手写一个自旋锁：" class="headerlink" title="问题四 公平锁/非公平锁/可重入锁/递归锁/自旋锁谈谈你的理解，请手写一个自旋锁："></a>问题四 公平锁/非公平锁/可重入锁/递归锁/自旋锁谈谈你的理解，请手写一个自旋锁：</h1><h2 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h2><p>指多个线程按照申请锁的顺序来获取锁，类似排队打饭，先来后到。</p><h2 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h2><p>指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁，在高并发的情况下，有可能会造成优先级反转或者饥饿现象（有一个线程一个锁也没有获取到）。</p><p>并发包中ReentrantLock的创建可以指定构造函数的Boolean类型来得到公平锁或非公平锁，默认是非公平锁。</p><h3 id="关于两者的区别"><a href="#关于两者的区别" class="headerlink" title="关于两者的区别"></a>关于两者的区别</h3><p><strong>公平锁</strong>：就是公平，在并发环境中，每个线程在获取锁时会先查看此锁维护并等待队列。<br><br><strong>非公平锁</strong>：上来就直接尝试占有锁，如果尝试失败，就再采用类似公平锁那种方式。<br>非公平锁的优点在于吞吐量比公平锁大，对于Synchronized而言，也是一种非公平锁。</p><h2 id="可重入锁（又名递归锁）"><a href="#可重入锁（又名递归锁）" class="headerlink" title="可重入锁（又名递归锁）"></a>可重入锁（又名递归锁）</h2><p>指同一线程外层函数获得锁之后，内层递归函数仍然能获取该锁的代码，在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁，也就是说<strong>线程可以进入任何一个它已经拥有的锁所同步着的代码块。</strong><br>ReentrantLock/Synchronized就是一个典型的可重入锁，可重入锁最大的作用是避免死锁。（加锁几次，解锁几次，程序不会报错，解锁少一次程序就会卡死）</p><h2 id="自旋锁-Spinlock"><a href="#自旋锁-Spinlock" class="headerlink" title="自旋锁(Spinlock)"></a>自旋锁(Spinlock)</h2><p>指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU.(CAS就是自旋锁)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Unsafe.getAndAddInt</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> var5</span><br><span class="line">  <span class="keyword">do</span>&#123;</span><br><span class="line">    var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">  &#125;<span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1,var2,var5,var5+var4));</span><br><span class="line">  <span class="keyword">return</span> var5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="独占锁（写锁）-共享锁（读锁）-互斥锁"><a href="#独占锁（写锁）-共享锁（读锁）-互斥锁" class="headerlink" title="独占锁（写锁）/共享锁（读锁）/互斥锁"></a>独占锁（写锁）/共享锁（读锁）/互斥锁</h2><p><strong>独占锁</strong>：指该锁一次只能被一个线程所持有。对ReentrantLock和Synchronized而言都是独占锁。<br><br><strong>共享锁</strong>：指该锁可被多个线程所持有。对ReentrantReadWriteLock其读锁是共享锁，其写锁是独占锁。读锁、共享锁可保证并发读是非常高效的，读写，写读，写写的过程是互斥的。</p><h1 id="问题五-CountDownLatch-CyclicBarrier-Semaphore使用过吗？"><a href="#问题五-CountDownLatch-CyclicBarrier-Semaphore使用过吗？" class="headerlink" title="问题五 CountDownLatch/CyclicBarrier/Semaphore使用过吗？"></a>问题五 CountDownLatch/CyclicBarrier/Semaphore使用过吗？</h1><p><strong>CountDownLatch</strong>:让一些线程阻塞直到另一些线程完成一系列操作后才被唤醒；<br>CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，调用线程会被阻塞。其他线程调用countDown方法会将计数器减1（调用countDown方法的线程不会阻塞），当计数器值为0时，因调用await方法被阻塞的线程就会被唤醒，继续执行。</p><p><strong>CyclicBarrier</strong>:字面意思是可循环（Cylic）使用的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活，线程进入屏障通过CyclicBarrier的await()方法。（与CountDownLatch相反）</p><p><strong>Semaphore</strong>:信号量主要用于两个目的，一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制。</p><h1 id="问题六：阻塞队列"><a href="#问题六：阻塞队列" class="headerlink" title="问题六：阻塞队列"></a>问题六：阻塞队列</h1><p><strong>ArrayBlockingQueue</strong>:是一个基于数组结构的有界限阻塞队列，此队列按FIFO(先进先出)原则对元素进行排序。</p><p><strong>LinkedBlockingQueue</strong>:是一个基于链表结构的阻塞队列，此队列按FIFO排序元素，吞吐量通常要高于ArrayBlockingQueue。</p><p><strong>SynchronousQueue</strong>:一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue。</p><p><strong>阻塞队列</strong>：<br>顾名思义，首先它是一个队列，一个阻塞队列在数据结构作用如下图：<br><img src="/img/BlockingQueue.png" alt><br>当阻塞队列是空时，从队列获取元素的操作将会被阻塞(试图从空的阻塞队列中获取元素的线程将会被阻塞，直到其他的线程往空的队列插入新的元素)；</p><p>当阻塞队列是满时，往队列添加元素的操作将会被阻塞(试图往已满的阻塞队列添加新元素的线程同样也会被阻塞，直到其他的线程从队列删除一个或多个元素或者清空队列，使队列变得空闲后新增)。</p><h2 id="为什么需要BlockingQueue"><a href="#为什么需要BlockingQueue" class="headerlink" title="为什么需要BlockingQueue"></a>为什么需要BlockingQueue</h2><p>好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都一手包办了。不需要兼顾效率和线程安全。</p><p><strong>种类分析</strong>：<br><br><strong>ArrayBlockingQueue</strong>:有数组结构组成的有界阻塞队列；<br><br><strong>LinkedBlockingQueue</strong>：由链表结构组成的有界（但大小默认值为Integer.MAX_VALUE）阻塞队列；<br><br>PriorityBlockingQueue:支持优先级排序的无界阻塞队列；<br><br>DelayQueue：使用优先级队列实现的延迟无界阻塞队列；<br><br><strong>SynchronousQueue</strong>：不存储元素的阻塞队列，也即单个元素的队列；<br><br>LinkedTransferQueue:由链表结构组成的无界阻塞队列；<br><br>LinkedBlockingDeque:由链表结构组成的双向阻塞队列。</p><p>BlockingQueue核心方法:<br><img src="/img/BlockingQueueMethod.png" alt><br><img src="/img/4.png" alt></p><h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p>SynchronousQueue没有容量，与其他BlockingQueue不同，SynchronousQueue是一个不存储元素的BlockingQueue。每一个put操作必须要等待一个take操作，否则不能继续添加元素，反之亦然。</p><h3 id="用在哪里"><a href="#用在哪里" class="headerlink" title="用在哪里"></a>用在哪里</h3><h4 id="生产者消费模式"><a href="#生产者消费模式" class="headerlink" title="生产者消费模式"></a>生产者消费模式</h4><p>多线程的判断用while判断，用if会出现虚假唤醒现象。</p><h1 id="问题：Synchronized和lock有什么区别，用新的lock有什么好处？"><a href="#问题：Synchronized和lock有什么区别，用新的lock有什么好处？" class="headerlink" title="问题：Synchronized和lock有什么区别，用新的lock有什么好处？"></a>问题：Synchronized和lock有什么区别，用新的lock有什么好处？</h1><p><strong>1、原始构成：</strong><br>synchronized是关键字属于JVM层面，monitorenter(底层是通过monitor对象来完成，其实wait/notify等方法也依赖于monitor)<br><br>Lock是具体类（Java.util.concurrent.locks.lock）是api层面的锁.<br><br><strong>2、使用方法：</strong><br>synchronized 不需要用户去手动释放锁，当synchronized代码执行完成后系统会自动让线程释放对锁的占用。<br>ReentrantLock则需要手动释放锁，若没有主动释放锁，就有可能导致出现死锁现象，需要lock()和unLock()方法配合try/finally语句块来完成。<br><br><strong>3、等待是否可中断：</strong><br>synchronized不可中断，除非抛出异常或者正常运行完成<br>ReentrantLock可中断：①设置超时方法trylock(long timeout,TimeUnit unit)。②lockInterruptibly()放代码块中，调用interrupt()方法可中断<br><br><strong>4、加锁是否公平：</strong><br><br>synchronized非公平锁<br><br>ReentrantLock两者都可以，默认非公平锁，构造方法可以传入Boolean值，true为公平锁，false为非公平锁。<br><br><strong>5、锁绑定多个条件Condition</strong><br><br>synchronized没有<br><br>ReentrantLock用来实现分组唤醒需要唤醒的线程们，可以精确唤醒，而不是像synchronized要么随机唤醒一个线程，要么全部唤醒。</p><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>线程池做的工作主要是控制运行线程的数量，<strong>处理过程中将任务放入队列</strong>，然后在线程创建后启动这些任务，<strong>如果线程数量超过了最大数量的线程，超出的线程就要排队等候</strong>，等待其他线程执行完毕，再从队列中取出任务来执行。<br><br>线程池主要特点或优势：<strong>线程复用，控制最大并发数量，管理线程</strong><br><br>或者:<br><br>①：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。<br><br>②：提高响应速度。当任务到达时，任务可以不需要等到线程创建，能立即执行。<br><br>③：提高线程的可管理性，线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。<br><br>java中的线程池是通过Executor框架实现的，该框架中用到了Executor，Executors,ExecutorService,ThreadPoolExecutor这几个类。（底类是ThreadPoolExecutor）<br></p><h2 id="java-使用多线程的方式"><a href="#java-使用多线程的方式" class="headerlink" title="java 使用多线程的方式:"></a>java 使用多线程的方式:</h2><p>①继承线程类，②使用Runable接口(没有返回值，不抛异常)，③使用Callable接口(有返回值，会抛异常)，④使用线程池<br><br><br>1.Callable规定的方法是call()，而Runnable规定的方法是run().<br><br>2.Callable的任务执行后可返回值，而Runnable的任务是不能返回值的。<br><br>3.call() 方法可抛出异常，而run() 方法是不能抛出异常的。<br><br>4.运行Callable任务可拿到一个Future对象， Future表示异步计算的结果。<br>它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。<br><br>5.通过Future对象可了解任务执行情况，可取消任务的执行，还可获取任务执行的结果。<br><br>6.Callable是类似于Runnable的接口，实现Callable接口的类和实现Runnable的类都是可被其它线程执行的任务。  </p><h3 id="Executors重点方法："><a href="#Executors重点方法：" class="headerlink" title="Executors重点方法："></a>Executors重点方法：</h3><p>Executors.newFixedThreadPool(),自己写开多少个线程,常用于执行长期的任务，性能好很多<br><br>Executors.newSingleThreadExecutor只开启一个线程，常用于一个任务一个任务执行的场景<br><br>Executors.newCachedThreadPool(),系统自己决定开多少线程。常用于执行很多短期异步的小程序或者负载较轻的服务。</p><h3 id="线程池的七大参数："><a href="#线程池的七大参数：" class="headerlink" title="线程池的七大参数："></a>线程池的七大参数：</h3><p>corePoolSize:线程池中的常驻核心线程数；<br><br>maximumPoolSize：线程池能同时执行的最大线程数，必须大于等于1；<br><br>keepAliveTime:多余的空闲线程存活时间（只有当线程池中的线程数大于corePool Size时，才会起作用）；<br><br>unit:keepAliveTime的单位<br><br>workQueue:任务队列，被提交但尚未被执行的任务；<br><br>threadFactory:表示生成线程池中工作线程的线程工厂，用于创建线程一般默认的即可；<br><br>handler；拒绝策略，当队列满了且工作线程大于等于最大线程数时如何来拒绝请求执行的Runable请求策略<br><br><strong>拒绝策略</strong>：AbortPolicy(默认)：直接抛出RejectedExecutionException异常阻止系统正常运行；<br><br>CallerRunsPolicy:”调用者运行”一种调节机制，该策略既不会抛弃任务，也不会抛出异常；而是将某些任务回退到调用者。（如果是main线程调用线程池，则线程池任务队列满了后，某些任务会由main线程处理。）<br><br>DiscardOldestPolicy:抛出队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交，<br><br>DiscardPolicy:直接丢弃任务，不予任何处理也不抛出异常。(如果允许任务丢失，这是最好的策略)</p><h3 id="问题：在生产中，你用Executors的哪个方法创建线程池"><a href="#问题：在生产中，你用Executors的哪个方法创建线程池" class="headerlink" title="问题：在生产中，你用Executors的哪个方法创建线程池"></a>问题：在生产中，你用Executors的哪个方法创建线程池</h3><p>答：都不用。线程池通过ThreadPoolExecutor方式创建。<br>Executors返回的线程池对象的弊端如下：<br>FixedThreadPool和SingleThreadPool:允许的请求队列长度为Inter.MAX_VALUE,可能会堆积大量的请求，从而导致OOM。<br>CachedThreadPool和ScheduleThreadPool:<br>允许的创建线程数量为Inter.MAX_VALUE,可能会堆积大量的线程，从而导致OOM。</p><h3 id="合理配置线程池的线程数"><a href="#合理配置线程池的线程数" class="headerlink" title="合理配置线程池的线程数"></a>合理配置线程池的线程数</h3><p><strong>CPU密集型</strong>：该任务需要大量的运算，没有阻塞，CPU一直运行，CPU密集型任务配置尽可能少的线程数量，CPU核数+1个线程的线程池。<br><br><strong>IO密集型</strong>：由于不是一直在执行任务，则应配置尽可能多的线程，如CPU核数*2；如果大部分线程都阻塞，故需要多配置线程数：CPU核数/1-阻塞系数，阻塞系数在0.8~0.9之间。<br></p><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>指两个或两个以上的进程执行过程中，因争夺资源而造成的一种互相等待的现象。</p><h3 id="查找死锁"><a href="#查找死锁" class="headerlink" title="查找死锁"></a>查找死锁</h3><p>终端输入jps -l，查看java进程的编号，再使用jstack 进程编号</p><h1 id="CPU占用过高定位分析"><a href="#CPU占用过高定位分析" class="headerlink" title="CPU占用过高定位分析"></a>CPU占用过高定位分析</h1><p>步骤：先用top命令找到CPU占比最高的；ps -ef 或者jps进一步定位，得知是一个怎么样的后台程序；定位到具体线程或代码（ps -mp 进程 -o THREAD,tid,time;参数解释：-m 显示所有的线程， -p pid进程使用CPU的时间， -o 该参数后是用户自定义格式）；将需要的线程ID转换为16进制格式（英文小写格式），<del>然后printf”%x\n” 有问题的线程id</del>;jstack 进程ID | grep tid(16进制线程ID小写英文)</p><h1 id="问题-token和JWT存在什么区别"><a href="#问题-token和JWT存在什么区别" class="headerlink" title="问题 token和JWT存在什么区别"></a>问题 token和JWT存在什么区别</h1><p>相同点： 都是访问资源的令牌，都可以记录用户的信息。<br><br>不同点：<strong>token需要查库验证token是否有效。而JWT不用查库或者少查库，直接在服务端进行校验</strong>，因为用户的信息及加密信息在第二部分payload和第三部分签证中已经生成，只要在服务段进行校验就行。<br>token验证流程：<br><br>1.把用户的账号密码发到后端；<br>2.后端进行校验，校验成功生成token，把token发送到客户端；<br>3.客户段自己保存token，再次请求就要在http协议的请求头中带着token去访问服务端，和在服务端保存的token信息进行比对校验；</p><p><br>JWT验证流程：<br></p><ol><li>在头部信息中声明加密算法和常量， 然后把header使用json转化为字符串</li><li>在载荷中声明用户信息，同时还有一些其他的内容；再次使用json 把载荷部分进行转化，转化为字符串</li><li>使用在header中声明的加密算法和每个项目随机生成的secret来进行加密， 把第一步分字符串和第二部分的字符串进行加密， 生成新的字符串。词字符串是独一无二的。</li><li>解密的时候，只要客户端带着JWT来发起请求，服务端就直接使用secret进行解密。</li></ol><h1 id="单点登录SSO-Single-Sign-On"><a href="#单点登录SSO-Single-Sign-On" class="headerlink" title="单点登录SSO(Single Sign On)"></a>单点登录SSO(Single Sign On)</h1><p>指在多系统应用群中登录一个系统，便可在其他所有系统中得到授权而无需再次登录。包括单点登录和单点注销。<br><br>sso需要一个独立的认证中心，只有认证中心能接受用户的用户名密码等安全信息，其他系统不提供登录入口，只接受认证中心的间接授权。间接授权通过令牌实现，sso认证中心验证用户的用户名密码没问题，创建授权令牌，在接下来的跳转过程中，授权令牌作为参数发送给各个子系统，子系统拿到令牌，即得到了授权，可以借此创建局部会话，局部会话登录方式与单系统的登录方式相同。</p><h3 id="验证过程"><a href="#验证过程" class="headerlink" title="验证过程"></a>验证过程<br></h3><p>用户访问系统1的受保护资源，系统1发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数;sso认证中心发现用户未登录，将用户引导至登录页面;用户输入用户名密码提交登录申请;sso认证中心校验用户信息，创建用户与sso认证中心之间的会话，称为全局会话，同时创建授权令牌。sso认证中心带着令牌跳转会最初的请求地址（系统1），系统1拿到令牌，去sso认证中心校验令牌是否有效，sso认证中心校验令牌，返回有效，注册系统1，系统1使用该令牌创建与用户的会话，称为局部会话，返回受保护资源。</p><p>用户访问系统2的受保护资源，系统2发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数，sso认证中心发现用户已登录，跳转回系统2的地址，并附上令牌，系统2拿到令牌，去sso认证中心校验令牌是否有效。sso认证中心校验令牌，返回有效，注册系统2，系统2使用该令牌创建与用户的局部会话，返回受保护资源。</p><p>用户登录成功之后，会与sso认证中心及各个子系统建立会话，用户与sso认证中心建立的会话称为全局会话，用户与各个子系统建立的会话称为局部会话，局部会话建立之后，用户访问子系统受保护资源将不再通过sso认证中心，全局会话与局部会话有如下约束关系：<br><br>局部会话存在，全局会话一定存在；<br><br>全局会话存在，局部会话不一定存在；<br><br>全局会话销毁，局部会话必须销毁。</p><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><p>通常而言，微服务架构是一种架构模式，或者说一种架构风格。它<strong>提倡将单一的应用程序划分成一组小的服务，彻底地去耦合</strong>，每个服务运行在其独立的进程内，服务之间互相协调，互相配置.<br></p><p><strong>优点：</strong><br>每个服务足够内聚，足够小，易理解，松耦合，能使用不同的语言开发，易于和第三方集成。<br><br><strong>缺点：</strong><br>开发人员要处理分布式系统的复杂性，多服务运维难度，随着服务的增加，运维压力也在增大，系统部署依赖，服务通信成本。</p><h4 id="微服务技术栈"><a href="#微服务技术栈" class="headerlink" title="微服务技术栈"></a>微服务技术栈</h4><table><thead><tr><th style="text-align:center">微服务条目</th><th style="text-align:center">落地技术</th></tr></thead><tbody><tr><td style="text-align:center">服务开发</td><td style="text-align:center">SpringBoot,Spring,SpringMVC</td></tr><tr><td style="text-align:center">服务配置与管理</td><td style="text-align:center">NetFlix公司的Archaius,阿里的Diamond</td></tr><tr><td style="text-align:center">服务注册与发现</td><td style="text-align:center">Eureka，Consul，Zookeeper</td></tr><tr><td style="text-align:center">服务调用</td><td style="text-align:center">Rest，RPC，gRPC</td></tr><tr><td style="text-align:center">服务熔断器</td><td style="text-align:center">Hystix,Envoy</td></tr><tr><td style="text-align:center">负载均衡</td><td style="text-align:center">Ribbon，Nginx</td></tr><tr><td style="text-align:center">服务接口地调用(客户端调用服务的简化工具)</td><td style="text-align:center">Feign</td></tr><tr><td style="text-align:center">消息队列</td><td style="text-align:center">Kafka，RabbitMQ，ActiveMQ</td></tr><tr><td style="text-align:center">服务配置中心管理</td><td style="text-align:center">SpringCloudConfig,Chef</td></tr><tr><td style="text-align:center">服务路由（API网关）</td><td style="text-align:center">Zuul</td></tr><tr><td style="text-align:center">服务监控</td><td style="text-align:center">Zabbix，Nagios，Metrics，Specatator</td></tr><tr><td style="text-align:center">全链路追踪</td><td style="text-align:center">Zipkin，Brave，Dapper</td></tr><tr><td style="text-align:center">服务部署</td><td style="text-align:center">Docker，OpenStack,Kubernetes</td></tr><tr><td style="text-align:center">数据流操作开发包</td><td style="text-align:center">SpringCloud Stream(封装与Redis,Rabbit,Kafka等发送接受消息)</td></tr><tr><td style="text-align:center">事件消息总线</td><td style="text-align:center">SpringCloud Bus</td></tr></tbody></table><p>===============================</p><h1 id="一-Java-基础模块"><a href="#一-Java-基础模块" class="headerlink" title="一. Java 基础模块"></a>一. Java 基础模块</h1><h2 id="类初始化过程"><a href="#类初始化过程" class="headerlink" title="类初始化过程"></a>类初始化过程</h2><p>1、一个类要创建实例需要先加载并初始化该类<br><br>    ⭐main方法所在的类需要先加载和初始化<br><br>2、一个子类要初始化需要先初始化分类<br><br>3、一个类初始化就是执行&lt; clinit &gt;()方法<br><br>⭐&lt; clinit &gt;()方法由静态类变量显示赋值代码和静态代码块组成<br><br>⭐类变量显示赋值代码和静态代码块从上到下顺序执行<br><br>⭐ &lt; clinit &gt;()方法只执行一次</p><h2 id="实例初始化过程"><a href="#实例初始化过程" class="headerlink" title="实例初始化过程"></a>实例初始化过程</h2><p>1、实例初始化就是执行&lt; init &gt;()方法<br>※ &lt; init &gt;()方法可能重载有多个，有几个构造器就有几个&lt; init &gt;()方法。<br>※&lt; init &gt;()方法由非静态实例变量显示赋值代码和非静态代码块、对应构造器代码组成。<br>※ 非静态实例变量显示赋值代码块和非静态代码块代码从上到下顺序执行，而对应构造器的代码最后执行。</p><h1 id="哪些方法不可以被重写"><a href="#哪些方法不可以被重写" class="headerlink" title="哪些方法不可以被重写"></a>哪些方法不可以被重写</h1><p>final方法，静态方法，private等子类中不可见方法</p><h1 id="局部变量与成员变量的区别："><a href="#局部变量与成员变量的区别：" class="headerlink" title="局部变量与成员变量的区别："></a>局部变量与成员变量的区别：</h1><p>1、作用域：<br><br>局部变量：从声明处开始，到所属的 } 结束；<br><br>实例变量：在当前类中“this.”(可省略)，在其他类中“对象名.”访问<br><br>类变量：在当前类中“类名.”（可省略），在其他类中“类名.”或“对象名.”访问。<br><br>2、生命周期：<br><br>局部变量：每一个线程，每一次调用执行都是新的生命周期<br><br>实例变量：随着对象的创建而初始化，随着对象的被回收而消亡，每个对象的实例变量是独立的<br><br>类变量：随着类的初始化而初始化，随着类的卸载而消亡，该类的所有对象的类变量都是共享的。<br>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s;  <span class="comment">// 成员变量，类变量</span></span><br><span class="line">    <span class="keyword">int</span> i;  <span class="comment">// 成员变量，实例变量</span></span><br><span class="line">    <span class="keyword">int</span> j;  <span class="comment">// 成员变量，实例变量</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>; <span class="comment">// 非静态代码块中的局部变量i</span></span><br><span class="line">        i++;</span><br><span class="line">        j++;</span><br><span class="line">        s++;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> j)</span></span>&#123; <span class="comment">// 形参，局部变量j</span></span><br><span class="line">        j++;</span><br><span class="line">        i++;</span><br><span class="line">        s++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123; <span class="comment">// 形参，局部变量，args</span></span><br><span class="line">      Exam obj1 = <span class="keyword">new</span> Exam(); <span class="comment">//局部变量，obj1</span></span><br><span class="line">      Exam obj2 = <span class="keyword">new</span> Exam(); <span class="comment">//局部变量，obj2</span></span><br><span class="line">      obj1.test(<span class="number">10</span>);</span><br><span class="line">      obj1.test(<span class="number">20</span>);</span><br><span class="line">      obj2.test(<span class="number">30</span>);</span><br><span class="line">      System.out.println(obj1.i +<span class="string">","</span>+obj1.j+<span class="string">","</span>+obj1.s);</span><br><span class="line">      System.out.println(obj2.i +<span class="string">","</span>+obj2.j+<span class="string">","</span>+obj2.s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码结果为：2，1，5和1，1，5</p><h2 id="1-JDK-和-JRE-有什么区别？"><a href="#1-JDK-和-JRE-有什么区别？" class="headerlink" title="1.JDK 和 JRE 有什么区别？"></a>1.JDK 和 JRE 有什么区别？</h2><p>JDK：Java Development Kit 的简称，JDK是整个JAVA的核心，包括了Java运行环境JRE，一堆Java工具和Java基础的类库。通过JDK,开发人员将源码文件(java文件)编译成字节码文件(class文件)。<br>JRE：Java Runtime Environment 的简称，Java 运行环境，不含开发环境，即没有编译器和调试器。将class文件加载到内存准备运行。</p><h2 id="2-和-equals-的区别是什么？"><a href="#2-和-equals-的区别是什么？" class="headerlink" title="2.== 和 equals 的区别是什么？"></a>2.== 和 equals 的区别是什么？</h2><p>== 解读:<br>对于基本类型和引用类型 == 的作用效果是不同的，如下所示：</p><p>基本类型：比较的是值是否相同；<br>引用类型：比较的是引用是否相同；<br>代码示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String x = <span class="string">"string"</span>;</span><br><span class="line">String y = <span class="string">"string"</span>;</span><br><span class="line">String z = <span class="keyword">new</span> String(<span class="string">"string"</span>);</span><br><span class="line">System.out.println(x==y); <span class="comment">// true</span></span><br><span class="line">System.out.println(x==z); <span class="comment">// false</span></span><br><span class="line">System.out.println(x.equals(y)); <span class="comment">// true</span></span><br><span class="line">System.out.println(x.equals(z)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>代码解读：因为 x 和 y 指向的是同一个引用，所以 == 也是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true。</p><p>equals 解读:<br>equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。看下面的代码就明白了。</p><p>首先来看默认情况下 equals 比较一个有相同值的对象，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Cat c1 = <span class="keyword">new</span> Cat(<span class="string">"精彩猿笔记"</span>);</span><br><span class="line">Cat c2 = <span class="keyword">new</span> Cat(<span class="string">"精彩猿笔记"</span>);</span><br><span class="line">System.out.println(c1.equals(c2)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><p>输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>原来 equals 本质上就是 ==。<br>那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"精彩猿笔记"</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"精彩猿笔记"</span>);</span><br><span class="line">System.out.println(s1.equals(s2)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">           String anotherString = (String) anObject;</span><br><span class="line">           <span class="keyword">int</span> n = value.length;</span><br><span class="line">           <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">               <span class="keyword">char</span> v1[] = value;</span><br><span class="line">               <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">               <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">               <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                   i++;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。<br>总结 ：== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p><h2 id="3-两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？"><a href="#3-两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？" class="headerlink" title="3.两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？"></a>3.两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？</h2><p>不对，(1)如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；(2)如果两个对象的hashCode相同，它们并不一定相同。<br>代码示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"精彩"</span>;</span><br><span class="line">String str2 = <span class="string">"笔记"</span>;</span><br><span class="line">System. out. println(String. format(<span class="string">"str1：%d | str2：%d"</span>, str1. hashCode(),str2. hashCode()));</span><br><span class="line">System. out. println(str1. equals(str2));</span><br></pre></td></tr></table></figure></p><p>执行的结果：<br>str1：1179395 | str2：1179395<br>false</p><p>代码解读：很显然“精彩”和“笔记”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode() 相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。</p><h2 id="4-final-在-Java-中有什么作用？"><a href="#4-final-在-Java-中有什么作用？" class="headerlink" title="4.final 在 Java 中有什么作用？"></a>4.final 在 Java 中有什么作用？</h2><p>final 修饰的类叫最终类，该类不能被继承。<br><br>final 修饰的方法不能被重写。<br><br>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。<br><br>final修饰的对象只是引用地址不可变，内容还是能变的<br></p><h3 id="string类为什么是final类型"><a href="#string类为什么是final类型" class="headerlink" title="string类为什么是final类型"></a>string类为什么是final类型</h3><p>为了实现字符串池(只有当字符是不可变的，字符串池才有可能实现)<br>为了线程安全(字符串自己便是线程安全的)<br>为了实现String可以创建HashCode不可变性</p><h2 id="5-Java-中的-Math-round-1-5-等于多少？"><a href="#5-Java-中的-Math-round-1-5-等于多少？" class="headerlink" title="5.Java 中的 Math. round(-1. 5) 等于多少？"></a>5.Java 中的 Math. round(-1. 5) 等于多少？</h2><p>等于 -1。round()是四舍五入，注意负数5是舍的，例如：Math.round(1.5)值是2，Math.round(-1.5)值是-1。</p><h2 id="6-String-属于基础的数据类型吗？"><a href="#6-String-属于基础的数据类型吗？" class="headerlink" title="6.String 属于基础的数据类型吗？"></a>6.String 属于基础的数据类型吗？</h2><p>String 不属于基础类型，基础类型有 8 种：byte、boolean、char、short、int、float、long、double，除了基本类型（primitive type），剩下的都是引用类型（reference type），Java 5以后引入的枚举类型也算是一种比较特殊的引用类型。</p><h2 id="7-Java-中操作字符串都有哪些类？它们之间有什么区别？"><a href="#7-Java-中操作字符串都有哪些类？它们之间有什么区别？" class="headerlink" title="7.Java 中操作字符串都有哪些类？它们之间有什么区别？"></a>7.Java 中操作字符串都有哪些类？它们之间有什么区别？</h2><p>操作字符串的类有：String、StringBuffer、StringBuilder。<br>三者区别：</p><p>StringBuffer和StringBuilder都继承自抽象类AbstractStringBuilder。<br><br>String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 存储数据的字符数组没有被final修饰，说明值可以改变，抽象类AbstractStringBuilder内部都提供了一个自动扩容机制，当发现长度不够的时候(初始默认长度是16)，会自动进行扩容工作，扩展为原数组长度的2倍加2，创建一个新的数组，并将数组的数据复制到新数组，所以对于拼接字符串效率要比String要高。<br><br>线程安全性：StringBuffer由于很多方法都被 synchronized 修饰了所以线程安全，但是当多线程访问时，加锁和释放锁的过程很平凡，所以效率相比StringBuilder要低。StringBuilder相反执行效率高，但是线程不安全。所以单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。<br><br>执行速度:StringBuilder &gt; StringBuffer &gt; String。</p><h2 id="8-String-str-”i”与-String-str-new-String-“i”-一样吗？"><a href="#8-String-str-”i”与-String-str-new-String-“i”-一样吗？" class="headerlink" title="8.String str=”i”与 String str=new String(“i”)一样吗？"></a>8.String str=”i”与 String str=new String(“i”)一样吗？</h2><p>不一样，因为内存的分配方式不一样。String str=“i”的方式，Java 虚拟机会将其分配到常量池中，如果常量池中有”i”，就返回”i”的地址，如果没有就创建”i”，然后返回”i”的地址；而 String str=new String(“i”) 则会被分到堆内存中新开辟一块空间。</p><h2 id="9-如何将字符串反转？"><a href="#9-如何将字符串反转？" class="headerlink" title="9.如何将字符串反转？"></a>9.如何将字符串反转？</h2><p>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。<br>示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StringBuffer reverse</span></span><br><span class="line">StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">stringBuffer. append(<span class="string">"abcdefg"</span>);</span><br><span class="line">System. out. println(stringBuffer. reverse()); <span class="comment">// gfedcba</span></span><br><span class="line"><span class="comment">// StringBuilder reverse</span></span><br><span class="line">StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">stringBuilder. append(<span class="string">"abcdefg"</span>);</span><br><span class="line">System. out. println(stringBuilder. reverse()); <span class="comment">// gfedcba</span></span><br></pre></td></tr></table></figure></p><h2 id="10-String-类的常用方法都有那些？"><a href="#10-String-类的常用方法都有那些？" class="headerlink" title="10.String 类的常用方法都有那些？"></a>10.String 类的常用方法都有那些？</h2><p>indexOf()：返回指定字符的索引。<br><br>charAt()：返回指定索引处的字符。<br><br>replace()：字符串替换。<br><br>trim()：去除字符串两端空白。<br><br>split()：分割字符串，返回一个分割后的字符串数组。<br><br>getBytes()：返回字符串的 byte 类型数组。<br><br>length()：返回字符串长度。<br><br>toLowerCase()：将字符串转成小写字母。<br><br>toUpperCase()：将字符串转成大写字符。<br><br>substring()：截取字符串。<br><br>equals()：字符串比较。</p><h2 id="11-抽象类必须要有抽象方法吗？"><a href="#11-抽象类必须要有抽象方法吗？" class="headerlink" title="11.抽象类必须要有抽象方法吗？"></a>11.抽象类必须要有抽象方法吗？</h2><p>不需要，抽象类不一定非要有抽象方法；但是包含一个抽象方法的类一定是抽象类。<br>示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System. out. println(<span class="string">"hi~"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码，抽象类并没有抽象方法但完全可以正常运行。</p><h2 id="12-普通类和抽象类有哪些区别？"><a href="#12-普通类和抽象类有哪些区别？" class="headerlink" title="12.普通类和抽象类有哪些区别？"></a>12.普通类和抽象类有哪些区别？</h2><p>普通类不能包含抽象方法，抽象类可以包含抽象方法。<br><br>抽象类是不能被实例化的，就是不能用new调出构造方法创建对象，普通类可以直接实例化。<br><br>如果一个类继承于抽象类，则该子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为abstract类。</p><h2 id="13-抽象类能使用-final-修饰吗？"><a href="#13-抽象类能使用-final-修饰吗？" class="headerlink" title="13.抽象类能使用 final 修饰吗？"></a>13.抽象类能使用 final 修饰吗？</h2><p>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类，如下图所示，编辑器也会提示错误信息：</p><h2 id="14-接口和抽象类有什么区别？"><a href="#14-接口和抽象类有什么区别？" class="headerlink" title="14.接口和抽象类有什么区别？"></a>14.接口和抽象类有什么区别？</h2><p>实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。<br>构造函数：抽象类可以有构造函数；接口不能有。<br>实现数量：类可以实现很多个接口；但只能继承一个抽象类【java只支持单继承】。<br>访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的抽象方法可以使用Public和Protected修饰，如果抽象方法修饰符为Private，则报错：The abstract method 方法名 in type Test can only set a visibility modifier, one of public or protected。</p><h2 id="15-Java-中-IO-流分为几种？"><a href="#15-Java-中-IO-流分为几种？" class="headerlink" title="15.Java 中 IO 流分为几种？"></a>15.Java 中 IO 流分为几种？</h2><p>按功能来分：输入流（input）、输出流（output）。<br>按类型来分：字节流和字符流。<br>字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。</p><h2 id="16-BIO、NIO、AIO-有什么区别？"><a href="#16-BIO、NIO、AIO-有什么区别？" class="headerlink" title="16.BIO、NIO、AIO 有什么区别？"></a>16.BIO、NIO、AIO 有什么区别？</h2><p>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。<br>NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。<br>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</p><h2 id="17-Files的常用方法都有哪些？"><a href="#17-Files的常用方法都有哪些？" class="headerlink" title="17.Files的常用方法都有哪些？"></a>17.Files的常用方法都有哪些？</h2><p>Files. exists()：检测文件路径是否存在。<br>Files. createFile()：创建文件。<br>Files. createDirectory()：创建文件夹。<br>Files. delete()：删除一个文件或目录。<br>Files. copy()：复制文件。<br>Files. move()：移动文件。<br>Files. size()：查看文件个数。<br>Files. read()：读取文件。<br>Files. write()：写入文件。<br>···</p><p>====================================================================</p><h1 id="二-Java-容器模块"><a href="#二-Java-容器模块" class="headerlink" title="二. Java 容器模块"></a>二. Java 容器模块</h1><h2 id="18-Java-容器都有哪些？"><a href="#18-Java-容器都有哪些？" class="headerlink" title="18.Java 容器都有哪些？"></a>18.Java 容器都有哪些？</h2><p>Java 容器分为 Collection 和 Map 两大类，其下又有很多子类，如下所示：<br>Collection、<br>List、<br>ArrayList、<br>LinkedList、<br>Vector、<br>Stack、<br>Set、<br>HashSet、<br>LinkedHashSet、<br>TreeSet、<br>Map、<br>HashMap、<br>LinkedHashMap、<br>TreeMap、<br>ConcurrentHashMap、<br>Hashtable、</p><h2 id="19-Collection-和-Collections-有什么区别？"><a href="#19-Collection-和-Collections-有什么区别？" class="headerlink" title="19.Collection 和 Collections 有什么区别？"></a>19.Collection 和 Collections 有什么区别？</h2><p>Collection 是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法，所有集合都是它的子类，比如 List、Set 等。<br>Collections 是一个包装类，包含了很多静态方法，不能被实例化，就像一个工具类，比如提供的排序方法： Collections. sort(list)。</p><h2 id="20-List、Set、Map-之间的区别是什么？"><a href="#20-List、Set、Map-之间的区别是什么？" class="headerlink" title="20.List、Set、Map 之间的区别是什么？"></a>20.List、Set、Map 之间的区别是什么？</h2><p>List、Set、Map 的区别主要体现在两个方面：元素是否有序、是否允许元素重复。<br>三者之间的区别，如下表：</p><h2 id="21-HashMap-和-Hashtable-有什么区别？"><a href="#21-HashMap-和-Hashtable-有什么区别？" class="headerlink" title="21. HashMap 和 Hashtable 有什么区别？"></a>21. HashMap 和 Hashtable 有什么区别？</h2><p>HashMap是继承自AbstractMap类，而HashTable是继承自Dictionary类。不过它们都实现了同时实现了map、Cloneable（可复制）、Serializable（可序列化）这三个接口。<br>Hashtable比HashMap多提供了elments() 和contains() 两个方法。<br>HashMap的key-value支持key-value，null-null，key-null，null-value四种。而Hashtable只支持key-value一种（即key和value都不为null这种形式）。既然HashMap支持带有null的形式，那么在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断，因为使用get的时候，当返回null时，你无法判断到底是不存在这个key，还是这个key就是null，还是key存在但value是null。<br>线程安全性不同：HashMap的方法都没有使用synchronized关键字修饰，都是非线程安全的，而Hashtable的方法几乎都是被synchronized关键字修饰的。但是，当我们需要HashMap是线程安全的时，怎么办呢？我们可以通过Collections.synchronizedMap(hashMap)来进行处理，亦或者我们使用线程安全的ConcurrentHashMap。ConcurrentHashMap虽然也是线程安全的，但是它的效率比Hashtable要高好多倍。因为ConcurrentHashMap使用了分段锁，并不对整个数据进行锁定。<br>初始容量大小和每次扩充容量大小的不同：Hashtable默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。<br>计算hash值的方法不同：为了得到元素的位置，首先需要根据元素的 KEY计算出一个hash值，然后再用这个hash值来计算得到最终的位置。Hashtable直接使用对象的hashCode。hashCode是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值。然后再使用除留余数发来获得最终的位置。</p><h2 id="22-如何决定使用-HashMap-还是-TreeMap？"><a href="#22-如何决定使用-HashMap-还是-TreeMap？" class="headerlink" title="22.如何决定使用 HashMap 还是 TreeMap？"></a>22.如何决定使用 HashMap 还是 TreeMap？</h2><p>对于在 Map 中插入、删除、定位一个元素这类操作，HashMap 是最好的选择，因为相对而言 HashMap 的插入会更快，但如果你要对一个 key 集合进行有序的遍历，那 TreeMap 是更好的选择。</p><h2 id="23-说一下-HashMap-的实现原理？"><a href="#23-说一下-HashMap-的实现原理？" class="headerlink" title="23.说一下 HashMap 的实现原理？"></a>23.说一下 HashMap 的实现原理？</h2><p>HashMap 基于 Hash 算法实现的，我们通过 put(key,value)存储，get(key)来获取。当传入 key 时，HashMap 会根据 key. hashCode() 计算出 hash 值，根据 hash 值将 value 保存在 bucket 里。当计算出的 hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同 hash 值的 value。当 hash 冲突的个数比较少时，使用链表否则使用红黑树。</p><h2 id="24-说一下-HashSet-的实现原理？"><a href="#24-说一下-HashSet-的实现原理？" class="headerlink" title="24.说一下 HashSet 的实现原理？"></a>24.说一下 HashSet 的实现原理？</h2><p>HashSet 是基于 HashMap 实现的，HashSet 底层使用 HashMap 来保存所有元素，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</p><h2 id="25-ArrayList-和-LinkedList-的区别是什么？"><a href="#25-ArrayList-和-LinkedList-的区别是什么？" class="headerlink" title="25.ArrayList 和 LinkedList 的区别是什么？"></a>25.ArrayList 和 LinkedList 的区别是什么？</h2><p>数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。<br>随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。<br>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。<br>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</p><h2 id="26-如何实现数组和-List-之间的转换？"><a href="#26-如何实现数组和-List-之间的转换？" class="headerlink" title="26.如何实现数组和 List 之间的转换？"></a>26.如何实现数组和 List 之间的转换？</h2><p>数组转 List：使用 Arrays. asList(array) 进行转换。<br>List 转数组：使用 List 自带的 toArray() 方法。<br>代码示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// list to array</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list. add(<span class="string">"☞精◈彩◈猿◈笔◈记☜"</span>);</span><br><span class="line">list. add(<span class="string">"的博客"</span>);</span><br><span class="line">list. toArray();</span><br><span class="line"><span class="comment">// array to list</span></span><br><span class="line">String[] array = <span class="keyword">new</span> String[]&#123;<span class="string">"☞精◈彩◈猿◈笔◈记☜"</span>,<span class="string">"的博客"</span>&#125;;</span><br><span class="line">Arrays. asList(array);</span><br></pre></td></tr></table></figure></p><h2 id="27-ArrayList-和-Vector-的区别是什么？"><a href="#27-ArrayList-和-Vector-的区别是什么？" class="headerlink" title="27.ArrayList 和 Vector 的区别是什么？"></a>27.ArrayList 和 Vector 的区别是什么？</h2><p>线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。<br>性能：ArrayList 在性能方面要优于 Vector。<br>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</p><h2 id="28-Array-和-ArrayList-有何区别？"><a href="#28-Array-和-ArrayList-有何区别？" class="headerlink" title="28.Array 和 ArrayList 有何区别？"></a>28.Array 和 ArrayList 有何区别？</h2><p>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。<br>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。<br>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</p><h2 id="29-在-Queue-中-poll-和-remove-有什么区别？"><a href="#29-在-Queue-中-poll-和-remove-有什么区别？" class="headerlink" title="29.在 Queue 中 poll()和 remove()有什么区别？"></a>29.在 Queue 中 poll()和 remove()有什么区别？</h2><p>相同点：都是返回第一个元素，并在队列中删除返回的对象。<br>不同点：如果没有元素 remove()会直接抛出NoSuchElementException 异常，而 poll()会返回 null。<br>代码示例：</p><p>Queue<string> queue = new LinkedList<string>();<br>queue. offer(“string”); // add<br>System. out. println(queue. poll());<br>System. out. println(queue. remove());<br>System. out. println(queue. size());</string></string></p><h2 id="30-哪些集合类是线程安全的？"><a href="#30-哪些集合类是线程安全的？" class="headerlink" title="30.哪些集合类是线程安全的？"></a>30.哪些集合类是线程安全的？</h2><p>Vector、Hashtable、Stack 都是线程安全的，而像 HashMap 则是非线程安全的，不过在 JDK 1.5 之后随着 Java. util. concurrent 并发包的出现，它们也有了自己对应的线程安全类，比如 HashMap 对应的线程安全类就是 ConcurrentHashMap。</p><h2 id="31-迭代器-Iterator-是什么？"><a href="#31-迭代器-Iterator-是什么？" class="headerlink" title="31.迭代器 Iterator 是什么？"></a>31.迭代器 Iterator 是什么？</h2><p>Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</p><h2 id="32-Iterator-怎么使用？有什么特点？"><a href="#32-Iterator-怎么使用？有什么特点？" class="headerlink" title="32.Iterator 怎么使用？有什么特点？"></a>32.Iterator 怎么使用？有什么特点？</h2><p>Iterator 使用代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Iterator&lt;String&gt; it = list. iterator();</span><br><span class="line"><span class="keyword">while</span>(it. hasNext())&#123;</span><br><span class="line">String obj = it. next();</span><br><span class="line">System. out. println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Iterator 的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</p><h2 id="33-Iterator-和-ListIterator-有什么区别？"><a href="#33-Iterator-和-ListIterator-有什么区别？" class="headerlink" title="33.Iterator 和 ListIterator 有什么区别？"></a>33.Iterator 和 ListIterator 有什么区别？</h2><p>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。<br>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。<br>ListIterator 从 Iterator 接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</p><h2 id="34-怎么确保一个集合不能被修改？"><a href="#34-怎么确保一个集合不能被修改？" class="headerlink" title="34.怎么确保一个集合不能被修改？"></a>34.怎么确保一个集合不能被修改？</h2><p>可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。<br>示例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list. add(<span class="string">"x"</span>);</span><br><span class="line">Collection&lt;String&gt; clist = Collections. unmodifiableCollection(list);</span><br><span class="line">clist. add(<span class="string">"y"</span>); <span class="comment">// 运行时此行报错</span></span><br><span class="line">System. out. println(list. size());</span><br></pre></td></tr></table></figure></p><p>====================================================================</p><h1 id="三-Java-多线程模块"><a href="#三-Java-多线程模块" class="headerlink" title="三. Java 多线程模块"></a>三. Java 多线程模块</h1><h2 id="35-并行和并发有什么区别？"><a href="#35-并行和并发有什么区别？" class="headerlink" title="35.并行和并发有什么区别？"></a>35.并行和并发有什么区别？</h2><p>并行：多个处理器或多核处理器同时处理多个任务。<br>并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。<br>如下图：【并发 = 两个队列和一台咖啡机】 【并行 = 两个队列和两台咖啡机】</p><h2 id="36-线程和进程的区别？"><a href="#36-线程和进程的区别？" class="headerlink" title="36.线程和进程的区别？"></a>36.线程和进程的区别？</h2><p>一个程序下至少有一个进程，一个进程下至少有一个线程，一个进程下也可以有多个线程来增加程序的执行速度。</p><h2 id="37-守护线程是什么？"><a href="#37-守护线程是什么？" class="headerlink" title="37.守护线程是什么？"></a>37.守护线程是什么？</h2><p>守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在 Java 中垃圾回收线程就是特殊的守护线程。</p><h2 id="38-多线程有几种实现方式？"><a href="#38-多线程有几种实现方式？" class="headerlink" title="38.多线程有几种实现方式？"></a>38.多线程有几种实现方式？</h2><p>有4种，分别是：</p><p>继承Thread类<br>实现Runnable接口<br>实现Callable接口通过FutureTask包装器来创建Thread线程<br>通过线程池创建线程，使用线程池接口ExecutorService结合Callable、Future实现有返回结果的多线程。<br>前面两种【无返回值】原因：通过重写run方法，run方法的返回值是void，所以没有办法返回结果。<br>后面两种【有返回值】原因：通过Callable接口，就要实现call方法，这个方法的返回值是Object，所以返回的结果可以放在Object对象中。</p><h2 id="39-说一下-Runnable和-Callable有什么区别？"><a href="#39-说一下-Runnable和-Callable有什么区别？" class="headerlink" title="39.说一下 Runnable和 Callable有什么区别？"></a>39.说一下 Runnable和 Callable有什么区别？</h2><p>Runnable没有返回值，Callable可以拿到有返回值，Callable可以看作是 Runnable的补充。</p><h2 id="40-线程有哪些状态？"><a href="#40-线程有哪些状态？" class="headerlink" title="40.线程有哪些状态？"></a>40.线程有哪些状态？</h2><p>线程的6种状态：</p><p>初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。<br>运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。<br>阻塞(BLOCKED)：表示线程阻塞于锁。<br>等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。<br>超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。<br>终止(TERMINATED)：表示该线程已经执行完毕。</p><h2 id="41-sleep-和-wait-有什么区别？"><a href="#41-sleep-和-wait-有什么区别？" class="headerlink" title="41.sleep() 和 wait() 有什么区别？"></a>41.sleep() 和 wait() 有什么区别？</h2><p>类的不同：sleep() 来自 Thread，wait() 来自 Object。<br>释放锁：sleep() 不释放锁；wait() 释放锁。<br>用法不同：sleep() 时间到会自动恢复；wait() 可以使用 notify()/notifyAll()直接唤醒。</p><h2 id="42-notify-和-notifyAll-有什么区别？"><a href="#42-notify-和-notifyAll-有什么区别？" class="headerlink" title="42.notify()和 notifyAll()有什么区别？"></a>42.notify()和 notifyAll()有什么区别？</h2><p>notifyAll()会唤醒所有的线程，notify()之后唤醒一个线程。notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。</p><h2 id="43-线程的-run-和-start-有什么区别？"><a href="#43-线程的-run-和-start-有什么区别？" class="headerlink" title="43.线程的 run() 和 start() 有什么区别？"></a>43.线程的 run() 和 start() 有什么区别？</h2><p>start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。</p><h2 id="44-创建线程池有哪几种方式？"><a href="#44-创建线程池有哪几种方式？" class="headerlink" title="44.创建线程池有哪几种方式？"></a>44.创建线程池有哪几种方式？</h2><p>线程池创建有七种方式，最核心的是最后一种：</p><p>newSingleThreadExecutor()：它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目；<br>newCachedThreadPool()：它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列；<br>newFixedThreadPool(int nThreads)：重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads；<br>newSingleThreadScheduledExecutor()：创建单线程池，返回 ScheduledExecutorService，可以进行定时或周期性的工作调度；<br>newScheduledThreadPool(int corePoolSize)：和newSingleThreadScheduledExecutor()类似，创建的是个 ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程；<br>newWorkStealingPool(int parallelism)：这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序；<br>ThreadPoolExecutor()：是最原始的线程池创建，上面1-3创建方式都是对ThreadPoolExecutor的封装。</p><h2 id="45-线程池都有哪些状态？"><a href="#45-线程池都有哪些状态？" class="headerlink" title="45.线程池都有哪些状态？"></a>45.线程池都有哪些状态？</h2><p>RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。<br>SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。<br>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。<br>TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()。<br>TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。</p><h2 id="46-线程池中-submit-和-execute-方法有什么区别？"><a href="#46-线程池中-submit-和-execute-方法有什么区别？" class="headerlink" title="46.线程池中 submit() 和 execute() 方法有什么区别？"></a>46.线程池中 submit() 和 execute() 方法有什么区别？</h2><p>execute()：只能执行 Runnable 类型的任务。<br>submit()：可以执行 Runnable 和 Callable 类型的任务。<br>Callable 类型的任务可以获取执行的返回值，而 Runnable 执行无返回值。</p><h2 id="47-在-Java-程序中怎么保证多线程的运行安全？"><a href="#47-在-Java-程序中怎么保证多线程的运行安全？" class="headerlink" title="47.在 Java 程序中怎么保证多线程的运行安全？"></a>47.在 Java 程序中怎么保证多线程的运行安全？</h2><p>方法一：使用安全类，比如 Java. util. concurrent 下的类。<br>方法二：使用自动锁 synchronized。<br>方法三：使用手动锁 Lock。<br>手动锁 Java 示例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock. lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"获得锁"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"释放锁"</span>);</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="48-多线程中-synchronized-锁升级的原理是什么？"><a href="#48-多线程中-synchronized-锁升级的原理是什么？" class="headerlink" title="48.多线程中 synchronized 锁升级的原理是什么？"></a>48.多线程中 synchronized 锁升级的原理是什么？</h2><p>synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。<br>锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p><h2 id="49-什么是死锁？"><a href="#49-什么是死锁？" class="headerlink" title="49.什么是死锁？"></a>49.什么是死锁？</h2><p>当线程 A 持有独占锁a，并尝试去获取独占锁 b 的同时，线程 B 持有独占锁 b，并尝试获取独占锁 a 的情况下，就会发生 AB 两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。</p><h2 id="50-怎么防止死锁？"><a href="#50-怎么防止死锁？" class="headerlink" title="50.怎么防止死锁？"></a>50.怎么防止死锁？</h2><p>尽量使用 tryLock(long timeout, TimeUnit unit)的方法(ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。<br>尽量使用 Java. util. concurrent 并发类代替自己手写锁。<br>尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。<br>尽量减少同步的代码块。</p><h2 id="51-ThreadLocal-是什么？有哪些使用场景？"><a href="#51-ThreadLocal-是什么？有哪些使用场景？" class="headerlink" title="51.ThreadLocal 是什么？有哪些使用场景？"></a>51.ThreadLocal 是什么？有哪些使用场景？</h2><p>ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。<br>ThreadLocal 的经典使用场景是数据库连接和 session 管理等。</p><h2 id="52-说一下-synchronized-底层实现原理？"><a href="#52-说一下-synchronized-底层实现原理？" class="headerlink" title="52.说一下 synchronized 底层实现原理？"></a>52.说一下 synchronized 底层实现原理？</h2><p>synchronized 是由一对 monitorenter/monitorexit 指令实现的，monitor 对象是同步的基本实现单元。在 Java 6 之前，monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作，性能也很低。但在 Java 6 的时候，Java 虚拟机 对此进行了大刀阔斧地改进，提供了三种不同的 monitor 实现，也就是常说的三种不同的锁：偏向锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。</p><h2 id="53-synchronized-和-volatile-的区别是什么？"><a href="#53-synchronized-和-volatile-的区别是什么？" class="headerlink" title="53.synchronized 和 volatile 的区别是什么？"></a>53.synchronized 和 volatile 的区别是什么？</h2><p>volatile 是变量修饰符；synchronized 是修饰类、方法、代码段。<br>volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。<br>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</p><h2 id="54-synchronized-和-Lock-有什么区别？"><a href="#54-synchronized-和-Lock-有什么区别？" class="headerlink" title="54.synchronized 和 Lock 有什么区别？"></a>54.synchronized 和 Lock 有什么区别？</h2><p>synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。<br>synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。<br>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</p><h2 id="55-synchronized-和-ReentrantLock-区别是什么？"><a href="#55-synchronized-和-ReentrantLock-区别是什么？" class="headerlink" title="55.synchronized 和 ReentrantLock 区别是什么？"></a>55.synchronized 和 ReentrantLock 区别是什么？</h2><p>synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大，但是在 Java 6 中对 synchronized 进行了非常多的改进。<br>主要区别如下：</p><p>ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；<br>ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；<br>ReentrantLock 只适用于代码块锁，而 synchronized 可用于修饰方法、代码块等。<br>ReentrantLock 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化。</p><h2 id="56-说一下-atomic-的原理？"><a href="#56-说一下-atomic-的原理？" class="headerlink" title="56.说一下 atomic 的原理？"></a>56.说一下 atomic 的原理？</h2><p>atomic 主要利用 CAS (Compare And Swap) 和 volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p><p>====================================================================</p><h1 id="四-Java-反射模块"><a href="#四-Java-反射模块" class="headerlink" title="四. Java 反射模块"></a>四. Java 反射模块</h1><h2 id="57-什么是反射？"><a href="#57-什么是反射？" class="headerlink" title="57.什么是反射？"></a>57.什么是反射？</h2><p>反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。</p><h2 id="58-什么是-Java-序列化？什么情况下需要序列化？"><a href="#58-什么是-Java-序列化？什么情况下需要序列化？" class="headerlink" title="58.什么是 Java 序列化？什么情况下需要序列化？"></a>58.什么是 Java 序列化？什么情况下需要序列化？</h2><p>Java 序列化是为了保存各种对象在内存中的状态，并且可以把保存的对象状态再读出来。<br>以下情况需要使用 Java 序列化：</p><p>想把的内存中的对象状态保存到一个文件中或者数据库中时候；<br>想用套接字在网络上传送对象的时候；<br>想通过RMI（远程方法调用）传输对象的时候。</p><h2 id="59-动态代理是什么？有哪些应用？"><a href="#59-动态代理是什么？有哪些应用？" class="headerlink" title="59.动态代理是什么？有哪些应用？"></a>59.动态代理是什么？有哪些应用？</h2><p>动态代理是运行时动态生成代理类。<br>动态代理的应用有 spring aop、hibernate 数据查询、测试框架的后端 mock、rpc，Java注解对象获取等。</p><h2 id="60-怎么实现动态代理？"><a href="#60-怎么实现动态代理？" class="headerlink" title="60.怎么实现动态代理？"></a>60.怎么实现动态代理？</h2><p>JDK 原生动态代理和 cglib 动态代理。JDK 原生动态代理是基于接口实现的，而 cglib 是基于继承当前类的子类实现的。</p><p>====================================================================</p><h1 id="五-Java-对象拷贝模块"><a href="#五-Java-对象拷贝模块" class="headerlink" title="五. Java 对象拷贝模块"></a>五. Java 对象拷贝模块</h1><h2 id="61-为什么要使用克隆？"><a href="#61-为什么要使用克隆？" class="headerlink" title="61.为什么要使用克隆？"></a>61.为什么要使用克隆？</h2><p>克隆的对象可能包含一些已经修改过的属性，而 new 出来的对象的属性都还是初始化时候的值，所以当需要一个新的对象来保存当前对象的“状态”就靠克隆方法了。</p><h2 id="62-如何实现对象克隆？"><a href="#62-如何实现对象克隆？" class="headerlink" title="62.如何实现对象克隆？"></a>62.如何实现对象克隆？</h2><p>实现 Cloneable 接口并重写 Object 类中的 clone() 方法。<br>实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。</p><h2 id="63-深拷贝和浅拷贝区别是什么？"><a href="#63-深拷贝和浅拷贝区别是什么？" class="headerlink" title="63.深拷贝和浅拷贝区别是什么？"></a>63.深拷贝和浅拷贝区别是什么？</h2><p>浅拷贝：当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。<br>深拷贝：除了对象本身被复制外，对象所包含的所有成员变量也将复制。</p><p>====================================================================</p><h1 id="六-Java-Web模块"><a href="#六-Java-Web模块" class="headerlink" title="六. Java Web模块"></a>六. Java Web模块</h1><h2 id="64-JSP-和-servlet-有什么区别？"><a href="#64-JSP-和-servlet-有什么区别？" class="headerlink" title="64.JSP 和 servlet 有什么区别？"></a>64.JSP 和 servlet 有什么区别？</h2><p>JSP 是 servlet 技术的扩展，本质上就是 servlet 的简易方式。servlet 和 JSP 最主要的不同点在于，servlet 的应用逻辑是在 Java 文件中，并且完全从表示层中的 html 里分离开来，而 JSP 的情况是 Java 和 html 可以组合成一个扩展名为 JSP 的文件。JSP 侧重于视图，servlet 主要用于控制逻辑。</p><h2 id="65-JSP-有哪些内置对象？作用分别是什么？"><a href="#65-JSP-有哪些内置对象？作用分别是什么？" class="headerlink" title="65.JSP 有哪些内置对象？作用分别是什么？"></a>65.JSP 有哪些内置对象？作用分别是什么？</h2><p>JSP 有 9 大内置对象：</p><p>request：封装客户端的请求，其中包含来自 get 或 post 请求的参数；<br>response：封装服务器对客户端的响应；<br>pageContext：通过该对象可以获取其他对象；<br>session：封装用户会话的对象；<br>application：封装服务器运行环境的对象；<br>out：输出服务器响应的输出流对象；<br>config：Web 应用的配置对象；<br>page：JSP 页面本身（相当于 Java 程序中的 this）；<br>exception：封装页面抛出异常的对象。</p><h2 id="66-说一下-JSP-的-4-种作用域？"><a href="#66-说一下-JSP-的-4-种作用域？" class="headerlink" title="66.说一下 JSP 的 4 种作用域？"></a>66.说一下 JSP 的 4 种作用域？</h2><p>page：代表与一个页面相关的对象和属性。<br>request：代表与客户端发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个 Web 组件；需要在页面显示的临时数据可以置于此作用域。<br>session：代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的 session 中。<br>application：代表与整个 Web 应用程序相关的对象和属性，它实质上是跨越整个 Web 应用程序，包括多个页面、请求和会话的一个全局作用域。</p><h2 id="67-session-和-cookie-有什么区别？"><a href="#67-session-和-cookie-有什么区别？" class="headerlink" title="67.session 和 cookie 有什么区别？"></a>67.session 和 cookie 有什么区别？</h2><p>session：是一种将会话状态保存在服务器端的技术。<br>Cookie ：是在 HTTP 协议下， Web 服务器保存在用户浏览器（客户端）上的小文本文件，它可以包含有关用户的信息。无论何时用户链接到服务器，Web 站点都可以访问 Cookie 信息 。</p><p>存储位置不同：session 存储在服务器端；cookie 存储在浏览器端。<br>安全性不同：cookie 安全性一般，在浏览器存储，可以被伪造和修改。<br>容量和个数限制：cookie 有容量限制，每个站点下的 cookie 也有个数限制。<br>存储的多样性：session 可以存储在 Redis 中、数据库中、应用程序中；而 cookie 只能存储在浏览器中。</p><h2 id="68-说一下-session-的工作原理？"><a href="#68-说一下-session-的工作原理？" class="headerlink" title="68.说一下 session 的工作原理？"></a>68.说一下 session 的工作原理？</h2><p>session 的工作原理是客户端登录完成之后，服务器会创建对应的 session，session 创建完之后，会把 session 的 id 发送给客户端，客户端再存储到浏览器中。这样客户端每次访问服务器时，都会带着 sessionid，服务器拿到 sessionid 之后，在内存找到与之对应的 session 这样就可以正常工作了。</p><h2 id="69-如果客户端禁止-cookie-能实现-session-还能用吗？"><a href="#69-如果客户端禁止-cookie-能实现-session-还能用吗？" class="headerlink" title="69.如果客户端禁止 cookie 能实现 session 还能用吗？"></a>69.如果客户端禁止 cookie 能实现 session 还能用吗？</h2><p>可以用，session 只是依赖 cookie 存储 sessionid，如果 cookie 被禁用了，可以使用 url 中添加 sessionid 的方式保证 session 能正常使用。</p><h2 id="70-spring-mvc-和-struts-的区别是什么？"><a href="#70-spring-mvc-和-struts-的区别是什么？" class="headerlink" title="70.spring mvc 和 struts 的区别是什么？"></a>70.spring mvc 和 struts 的区别是什么？</h2><p>拦截级别：struts2 是类级别的拦截；spring mvc 是方法级别的拦截。<br>数据独立性：spring mvc 的方法之间基本上独立的，独享 request 和 response 数据，请求数据通过参数获取，处理结果通过 ModelMap 交回给框架，方法之间不共享变量；而 struts2 虽然方法之间也是独立的，但其所有 action 变量是共享的，这不会影响程序运行，却给我们编码和读程序时带来了一定的麻烦。<br>拦截机制：struts2 有以自己的 interceptor 机制，spring mvc 用的是独立的 aop 方式，这样导致struts2 的配置文件量比 spring mvc 大。<br>对 ajax 的支持：spring mvc 集成了ajax，所有 ajax 使用很方便，只需要一个注解 @ResponseBody 就可以实现了；而 struts2 一般需要安装插件或者自己写代码才行。</p><h2 id="71-如何避免-SQL-注入？"><a href="#71-如何避免-SQL-注入？" class="headerlink" title="71.如何避免 SQL 注入？"></a>71.如何避免 SQL 注入？</h2><p>使用预处理 PreparedStatement。<br>使用正则表达式过滤掉字符中的特殊字符。</p><h2 id="72-什么是-XSS-攻击，如何避免？"><a href="#72-什么是-XSS-攻击，如何避免？" class="headerlink" title="72.什么是 XSS 攻击，如何避免？"></a>72.什么是 XSS 攻击，如何避免？</h2><p>XSS 攻击：即跨站脚本攻击，它是 Web 程序中常见的漏洞。原理是攻击者往 Web 页面里插入恶意的脚本代码（css 代码、Javascript 代码等），当用户浏览该页面时，嵌入其中的脚本代码会被执行，从而达到恶意攻击用户的目的，如盗取用户 cookie、破坏页面结构、重定向到其他网站等。<br>预防 XSS 的核心是必须对输入的数据做过滤处理。</p><h2 id="73-什么是-CSRF-攻击，如何避免？"><a href="#73-什么是-CSRF-攻击，如何避免？" class="headerlink" title="73.什么是 CSRF 攻击，如何避免？"></a>73.什么是 CSRF 攻击，如何避免？</h2><p>CSRF：Cross-Site Request Forgery（中文：跨站请求伪造），可以理解为攻击者盗用了你的身份，以你的名义发送恶意请求，比如：以你名义发送邮件、发消息、购买商品，虚拟货币转账等。<br>防御手段：</p><p>验证请求来源地址；<br>关键操作添加验证码；<br>在请求地址添加 token 并验证。</p><p>====================================================================</p><h1 id="七-Java-异常模块"><a href="#七-Java-异常模块" class="headerlink" title="七. Java 异常模块"></a>七. Java 异常模块</h1><h2 id="74-throw-和-throws-的区别？"><a href="#74-throw-和-throws-的区别？" class="headerlink" title="74.throw 和 throws 的区别？"></a>74.throw 和 throws 的区别？</h2><p>throw：是真实抛出一个异常。<br>throws：是声明可能会抛出一个异常。</p><h2 id="75-final、finally、finalize-有什么区别？"><a href="#75-final、finally、finalize-有什么区别？" class="headerlink" title="75.final、finally、finalize 有什么区别？"></a>75.final、finally、finalize 有什么区别？</h2><p>final：是修饰符，如果修饰类，此类不能被继承；如果修饰方法和变量，则表示此方法和此变量不能在被改变，只能使用。<br>finally：是 try{} catch{} finally{} 最后一部分，表示不论发生任何情况都会执行，finally 部分可以省略，但如果 finally 部分存在，则一定会执行 finally 里面的代码。<br>finalize： 是Object的protected方法，子类可以覆盖该方法以实现资源清理工作，GC在回收对象之前调用该方法。<br>76.try-catch-finally 中哪个部分可以省略？<br>try-catch-finally 其中 catch 和 finally 都可以被省略，但是不能同时省略，也就是说有 try 的时候，必须后面跟一个 catch 或者 finally。</p><h2 id="77-try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？"><a href="#77-try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？" class="headerlink" title="77.try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？"></a>77.try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</h2><p>finally 一定会执行，即使是 catch 中 return 了，catch 中的 return 会等 finally 中的代码执行完之后，才会执行。</p><h2 id="78-常见的异常类有哪些？"><a href="#78-常见的异常类有哪些？" class="headerlink" title="78.常见的异常类有哪些？"></a>78.常见的异常类有哪些？</h2><p>NullPointerException 空指针异常<br>ClassNotFoundException 指定类不存在<br>NumberFormatException 字符串转换为数字异常<br>IndexOutOfBoundsException 数组下标越界异常<br>ClassCastException 数据类型转换异常<br>FileNotFoundException 文件未找到异常<br>NoSuchMethodException 方法不存在异常<br>IOException IO 异常<br>SocketException Socket 异常</p><p>====================================================================</p><h1 id="八-网络模块"><a href="#八-网络模块" class="headerlink" title="八. 网络模块"></a>八. 网络模块</h1><h2 id="79-http-响应码-301-和-302-代表的是什么？有什么区别？"><a href="#79-http-响应码-301-和-302-代表的是什么？有什么区别？" class="headerlink" title="79.http 响应码 301 和 302 代表的是什么？有什么区别？"></a>79.http 响应码 301 和 302 代表的是什么？有什么区别？</h2><p>301：永久重定向；302：暂时重定向。<br>它们的区别是，301 对搜索引擎优化（SEO）更加有利；302 有被提示为网络拦截的风险。</p><h2 id="80-forward-和-redirect-的区别？"><a href="#80-forward-和-redirect-的区别？" class="headerlink" title="80.forward 和 redirect 的区别？"></a>80.forward 和 redirect 的区别？</h2><p>forward 是转发 和 redirect 是重定向：<br>地址栏 url 显示：foward url 不会发生改变，redirect url 会发生改变；<br>数据共享：forward 可以共享 request 里的数据，redirect 不能共享；<br>效率：forward 比 redirect 效率高。</p><h2 id="81-简述-tcp-和-udp的区别？"><a href="#81-简述-tcp-和-udp的区别？" class="headerlink" title="81.简述 tcp 和 udp的区别？"></a>81.简述 tcp 和 udp的区别？</h2><p>tcp 和 udp 是 OSI 模型中的运输层中的协议。tcp 提供可靠的通信传输，而 udp 则常被用于让广播和细节控制交给应用的通信传输。<br>两者的区别大致如下：</p><p>tcp 面向连接，udp 面向非连接即发送数据前不需要建立链接；<br>tcp 提供可靠的服务（数据传输），udp 无法保证；<br>tcp 面向字节流，udp 面向报文；<br>tcp 数据传输慢，udp 数据传输快；</p><h2 id="82-tcp-为什么要三次握手，两次不行吗？为什么？"><a href="#82-tcp-为什么要三次握手，两次不行吗？为什么？" class="headerlink" title="82.tcp 为什么要三次握手，两次不行吗？为什么？"></a>82.tcp 为什么要三次握手，两次不行吗？为什么？</h2><p>　我们假设A和B是通信的双方。我理解的握手实际上就是通信，发一次信息就是进行一次握手。</p><p>第一次握手： A给B打电话说，你可以听到我说话吗？<br>第二次握手： B收到了A的信息，然后对A说： 我可以听得到你说话啊，你能听得到我说话吗？<br>第三次握手： A收到了B的信息，然后说可以的，我要给你发信息啦！<br>在三次握手之后，A和B都能确定这么一件事： 我说的话，你能听到； 你说的话，我也能听到。 这样，就可以开始正常通信了。<br>注意： HTTP是基于TCP协议的，所以每次都是客户端发送请求，服务器应答，但是TCP还可以给其他应用层提供服务，即可能A、B在建立链接之后，谁都可能先开始通信。</p><p>如果采用两次握手，那么只要服务器发出确认数据包就会建立连接，但由于客户端此时并未响应服务器端的请求，那此时服务器端就会一直在等待客户端，这样服务器端就白白浪费了一定的资源。若采用三次握手，服务器端没有收到来自客户端的再此确认，则就会知道客户端并没有要求建立请求，就不会浪费服务器的资源。</p><h2 id="83-说一下-tcp-粘包是怎么产生的？"><a href="#83-说一下-tcp-粘包是怎么产生的？" class="headerlink" title="83.说一下 tcp 粘包是怎么产生的？"></a>83.说一下 tcp 粘包是怎么产生的？</h2><p>tcp 粘包可能发生在发送端或者接收端，分别来看两端各种产生粘包的原因：</p><p>发送端粘包：发送端需要等缓冲区满才发送出去，造成粘包；<br>接收方粘包：接收方不及时接收缓冲区的包，造成多个包接收。</p><h2 id="84-OSI-的七层模型都有哪些？"><a href="#84-OSI-的七层模型都有哪些？" class="headerlink" title="84.OSI 的七层模型都有哪些？"></a>84.OSI 的七层模型都有哪些？</h2><p>物理层：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。<br>数据链路层：负责建立和管理节点间的链路。<br>网络层：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。<br>传输层：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。<br>会话层：向两个实体的表示层提供建立和使用连接的方法。<br>表示层：处理用户信息的表示问题，如编码、数据格式转换和加密解密等。<br>应用层：直接向用户提供服务，完成用户希望在网络上完成的各种工作。</p><h2 id="85-get-和-post-请求有哪些区别？"><a href="#85-get-和-post-请求有哪些区别？" class="headerlink" title="85.get 和 post 请求有哪些区别？"></a>85.get 和 post 请求有哪些区别？</h2><p>get 请求会被浏览器主动缓存，而 post 不会。<br>get 传递参数有大小限制，而 post 没有。<br>post 参数传输更安全，get 的参数会明文限制在 url 上，post 不会。</p><h2 id="86-如何实现跨域？"><a href="#86-如何实现跨域？" class="headerlink" title="86.如何实现跨域？"></a>86.如何实现跨域？</h2><p>实现跨域有以下几种方案：</p><p>服务器端运行跨域 设置 CORS 等于 *；<br>在单个接口使用注解 @CrossOrigin 运行跨域；<br>使用 jsonp 跨域；</p><h2 id="87-说一下-JSONP-实现原理？"><a href="#87-说一下-JSONP-实现原理？" class="headerlink" title="87.说一下 JSONP 实现原理？"></a>87.说一下 JSONP 实现原理？</h2><p>jsonp：JSON with Padding，它是利用script标签的 src 连接可以访问不同源的特性，加载远程返回的“JS 函数”来执行的。</p><p>====================================================================</p><h1 id="九-设计模式模块"><a href="#九-设计模式模块" class="headerlink" title="九. 设计模式模块"></a>九. 设计模式模块</h1><h2 id="88-说一下你熟悉的设计模式？"><a href="#88-说一下你熟悉的设计模式？" class="headerlink" title="88.说一下你熟悉的设计模式？"></a>88.说一下你熟悉的设计模式？</h2><p>单例模式：保证被创建一次，节省系统开销。<br>工厂模式（简单工厂、抽象工厂）：解耦代码。<br>观察者模式：定义了对象之间的一对多的依赖，这样一来，当一个对象改变时，它的所有的依赖者都会收到通知并自动更新。<br>外观模式：提供一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层的接口，让子系统更容易使用。<br>模版方法模式：定义了一个算法的骨架，而将一些步骤延迟到子类中，模版方法使得子类可以在不改变算法结构的情况下，重新定义算法的步骤。<br>状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。</p><h2 id="89-简单工厂和抽象工厂有什么区别？"><a href="#89-简单工厂和抽象工厂有什么区别？" class="headerlink" title="89.简单工厂和抽象工厂有什么区别？"></a>89.简单工厂和抽象工厂有什么区别？</h2><p>简单工厂：用来生产同一等级结构中的任意产品，对于增加新的产品，无能为力。<br>工厂方法：用来生产同一等级结构中的固定产品，支持增加任意产品。<br>抽象工厂：用来生产不同产品族的全部产品，对于增加新的产品，无能为力；支持增加产品族。</p><p>====================================================================</p><h1 id="十-Spring-Spring-MVC模块"><a href="#十-Spring-Spring-MVC模块" class="headerlink" title="十. Spring/Spring MVC模块"></a>十. Spring/Spring MVC模块</h1><h2 id="90-为什么要使用-spring？"><a href="#90-为什么要使用-spring？" class="headerlink" title="90.为什么要使用 spring？"></a>90.为什么要使用 spring？</h2><p>spring 提供 ioc 技术，容器会帮你管理依赖的对象，从而不需要自己创建和管理依赖对象了，更轻松的实现了程序的解耦。<br>spring 提供了事务支持，使得事务操作变的更加方便。<br>spring 提供了面向切片编程，这样可以更方便的处理某一类的问题。<br>更方便的框架集成，spring 可以很方便的集成其他框架，比如 MyBatis、hibernate 等。</p><h2 id="91-解释一下什么是-aop？"><a href="#91-解释一下什么是-aop？" class="headerlink" title="91.解释一下什么是 aop？"></a>91.解释一下什么是 aop？</h2><p>与OOP(面向对象)对比，AOP是处理一些横切行问题，这些横切性问题不会影响到主逻辑的实现，但是会散落到代码的各个部分，难以维护。AOP就是把这些问题和主业务逻辑分开，达到与主业务逻辑解耦的目的。</p><p>传统OOP是自上而下的逻辑开发；</p><p>aop 是面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。<br>简单来说就是统一处理某一“切面”（类）的问题的编程思想，比如统一处理日志、异常等。</p><h2 id="92-解释一下什么是-ioc？"><a href="#92-解释一下什么是-ioc？" class="headerlink" title="92.解释一下什么是 ioc？"></a>92.解释一下什么是 ioc？</h2><p>ioc：Inversionof Control（中文：控制反转）是 spring 的核心，对于 spring 框架来说，就是由 Spring IoC Container来负责控制对象的生命周期和对象间的关系。<br>简单来说，控制指的是当前对象对内部成员的控制权；控制反转指的是，这种控制权不由当前对象管理了，由其他（类,第三方容器）来管理。</p><p><strong>何为控制，控制的是什么？</strong></p><p>答：是 bean 的创建、管理的权利，控制 bean 的整个生命周期。</p><p><strong>何为反转，反转了什么？</strong></p><p>答：把这个权利交给了 Spring 容器，而不是自己去控制，就是反转。 由之前的自己主动创建对象，变成现在被动接收别人给我们的对象的过程，这就是反转。</p><h2 id="93-spring-有哪些主要模块？"><a href="#93-spring-有哪些主要模块？" class="headerlink" title="93.spring 有哪些主要模块？"></a>93.spring 有哪些主要模块？</h2><p>spring core：框架的最基础部分，提供 ioc 和依赖注入特性。<br>spring context：构建于 core 封装包基础上的 context 封装包，提供了一种框架式的对象访问方法。<br>spring dao：Data Access Object 提供了JDBC的抽象层。<br>spring aop：提供了面向切面的编程实现，让你可以自定义拦截器、切点等。<br>spring Web：提供了针对 Web 开发的集成特性，例如文件上传，利用 servlet listeners 进行 ioc 容器初始化和针对 Web 的 ApplicationContext。<br>spring Web mvc：spring 中的 mvc 封装包提供了 Web 应用的 Model-View-Controller（MVC）的实现。</p><h2 id="94-spring-常用的依赖注入方式有哪些？"><a href="#94-spring-常用的依赖注入方式有哪些？" class="headerlink" title="94.spring 常用的依赖注入方式有哪些？"></a>94.spring 常用的依赖注入方式有哪些？</h2><p>setter 属性注入<br>构造方法注入<br>注解方式注入</p><h2 id="95-spring-中的-bean-是线程安全的吗？"><a href="#95-spring-中的-bean-是线程安全的吗？" class="headerlink" title="95.spring 中的 bean 是线程安全的吗？"></a>95.spring 中的 bean 是线程安全的吗？</h2><p>spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。<br>实际上大部分时候 spring bean 无状态的（比如 dao 类），所有某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了，所以就可以保证线程安全了。</p><p>有状态就是有数据存储功能。<br>无状态就是不会保存数据。</p><h2 id="阐述Spring框架中Bean的生命周期？"><a href="#阐述Spring框架中Bean的生命周期？" class="headerlink" title="阐述Spring框架中Bean的生命周期？"></a>阐述Spring框架中Bean的生命周期？</h2><p>① Spring IoC容器找到关于Bean的定义并实例化该Bean。<br><br>② Spring IoC容器对Bean进行依赖注入。<br><br>③ 如果Bean实现了BeanNameAware接口，则将该Bean的id传给setBeanName方法。<br><br>④ 如果Bean实现了BeanFactoryAware接口，则将BeanFactory对象传给setBeanFactory方法。<br><br>⑤ 如果Bean实现了BeanPostProcessor接口，则调用其postProcessBeforeInitialization方法。<br><br>⑥ 如果Bean实现了InitializingBean接口，则调用其afterPropertySet方法。<br><br>⑦ 如果有和Bean关联的BeanPostProcessors对象，则这些对象的postProcessAfterInitialization方法被调用。<br><br>⑧ 当销毁Bean实例时，如果Bean实现了DisposableBean接口，则调用其destroy方法。</p><h2 id="96-spring-支持几种-bean-的作用域？"><a href="#96-spring-支持几种-bean-的作用域？" class="headerlink" title="96.spring 支持几种 bean 的作用域？"></a>96.spring 支持几种 bean 的作用域？</h2><p>spring 支持 5 种作用域，如下：<br><br>singleton：spring ioc 容器中只存在一个 bean 实例，bean 以单例模式存在，是系统默认值；<br><br>prototype：每次从容器调用 bean 时都会创建一个新的示例，既每次 getBean()相当于执行 new Bean()操作；<br><br>request：每次 http 请求都会创建一个 bean；<br><br>session：同一个 http session 共享一个 bean 实例；<br><br>global-session：用于 portlet 容器，因为每个 portlet 有单独的 session，globalsession 提供一个全局性的 http session。<br><br>注意： 使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。</p><h2 id="97-spring-自动装配-bean-有哪些方式？"><a href="#97-spring-自动装配-bean-有哪些方式？" class="headerlink" title="97.spring 自动装配 bean 有哪些方式？"></a>97.spring 自动装配 bean 有哪些方式？</h2><p>no：默认值，表示没有自动装配，应使用显式 bean 引用进行装配。<br>byName：它根据 bean 的名称注入对象依赖项。<br>byType：它根据类型注入对象依赖项。<br>构造函数：通过构造函数来注入依赖项，需要设置大量的参数。<br>autodetect：容器首先通过构造函数使用 autowire 装配，如果不能，则通过 byType 自动装配。</p><h2 id="98-spring-事务实现方式有哪些？"><a href="#98-spring-事务实现方式有哪些？" class="headerlink" title="98.spring 事务实现方式有哪些？"></a>98.spring 事务实现方式有哪些？</h2><p>声明式事务：声明式事务也有两种实现方式，基于 xml 配置文件的方式和注解方式（在类上添加 @Transaction 注解）。<br>编码方式：提供编码的形式管理和维护事务。</p><h2 id="7种事务的传播机制（可通过spring配置或注解来设置）"><a href="#7种事务的传播机制（可通过spring配置或注解来设置）" class="headerlink" title="7种事务的传播机制（可通过spring配置或注解来设置）"></a><strong>7种事务的传播机制（可通过spring配置或注解来设置）</strong></h2><ol><li>REQUIRED（默认）：支持使用当前事务，如果当前事务不存在，创建一个新事务。</li><li>SUPPORTS：支持使用当前事务，如果当前事务不存在，则不使用事务。</li><li>MANDATORY：中文翻译为强制，支持使用当前事务，如果当前事务不存在，则抛出Exception。</li><li>REQUIRES_NEW：创建一个新事务，如果当前事务存在，把当前事务挂起。</li><li>NOT_SUPPORTED：无事务执行，如果当前事务存在，把当前事务挂起。</li><li>NEVER：无事务执行，如果当前有事务则抛出Exception。</li><li>NESTED：嵌套事务，如果当前事务存在，那么在嵌套的事务中执行。如果当前事务不存在，则表现跟REQUIRED一样。</li></ol><h2 id="99-说一下-spring-的事务隔离？"><a href="#99-说一下-spring-的事务隔离？" class="headerlink" title="99.说一下 spring 的事务隔离？"></a>99.说一下 spring 的事务隔离？</h2><p>spring 有五大隔离级别，默认值为 ISOLATION_DEFAULT（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致：</p><p>ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；<br>ISOLATION_READ_UNCOMMITTED：<strong>未提交读</strong>，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）；<br>ISOLATION_READ_COMMITTED：<strong>提交读</strong>，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），SQL server 的默认级别；<br>ISOLATION_REPEATABLE_READ：<strong>可重复读</strong>，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；<br>ISOLATION_SERIALIZABLE：<strong>序列化</strong>，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。<br><strong>脏读</strong> ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。<br><strong>不可重复读</strong> ：是指在一个事务内，多次读同一数据。<br><strong>幻读 </strong>：指同一个事务内多次查询返回的结果不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p><h2 id="100-说一下-spring-mvc-运行流程？"><a href="#100-说一下-spring-mvc-运行流程？" class="headerlink" title="100.说一下 spring mvc 运行流程？"></a>100.说一下 spring mvc 运行流程？</h2><p>spring mvc 先将请求发送给 DispatcherServlet。<br>DispatcherServlet 查询一个或多个 HandlerMapping，找到处理请求的 Controller。<br>DispatcherServlet 再把请求提交到对应的 Controller。<br>Controller 进行业务逻辑处理后，会返回一个ModelAndView。<br>Dispathcher 查询一个或多个 ViewResolver 视图解析器，找到 ModelAndView 对象指定的视图对象。<br>视图对象负责渲染返回给客户端。</p><h2 id="101-spring-mvc-有哪些组件？"><a href="#101-spring-mvc-有哪些组件？" class="headerlink" title="101.spring mvc 有哪些组件？"></a>101.spring mvc 有哪些组件？</h2><p>前置控制器 DispatcherServlet。<br>映射控制器 HandlerMapping。<br>处理器 Controller。<br>模型和视图 ModelAndView。<br>视图解析器 ViewResolver。</p><h2 id="102-RequestMapping-的作用是什么？"><a href="#102-RequestMapping-的作用是什么？" class="headerlink" title="102.@RequestMapping 的作用是什么？"></a>102.@RequestMapping 的作用是什么？</h2><p>将 http 请求映射到相应的类/方法上。</p><h2 id="103-Autowired-的作用是什么？"><a href="#103-Autowired-的作用是什么？" class="headerlink" title="103.@Autowired 的作用是什么？"></a>103.@Autowired 的作用是什么？</h2><p>@Autowired 它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作，通过@Autowired 的使用来消除 set/get 方法。</p><p>====================================================================</p><h1 id="十一-Spring-Boot-Spring-Cloud模块"><a href="#十一-Spring-Boot-Spring-Cloud模块" class="headerlink" title="十一. Spring Boot/Spring Cloud模块"></a>十一. Spring Boot/Spring Cloud模块</h1><h2 id="104-什么是-spring-boot？"><a href="#104-什么是-spring-boot？" class="headerlink" title="104.什么是 spring boot？"></a>104.什么是 spring boot？</h2><p>spring boot 是为 spring 服务的，是用来简化新 spring 应用的初始搭建以及开发过程的。</p><h2 id="105-为什么要用-spring-boot？"><a href="#105-为什么要用-spring-boot？" class="headerlink" title="105.为什么要用 spring boot？"></a>105.为什么要用 spring boot？</h2><p>配置简单<br>独立运行<br>自动装配<br>无代码生成和 xml 配置<br>提供应用监控<br>易上手<br>提升开发效率</p><h2 id="106-spring-boot-核心配置文件是什么？"><a href="#106-spring-boot-核心配置文件是什么？" class="headerlink" title="106.spring boot 核心配置文件是什么？"></a>106.spring boot 核心配置文件是什么？</h2><p>spring boot 核心的两个配置文件：</p><p>bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，且 boostrap 里面的属性不能被覆盖；<br>application (. yml 或者 . properties)：用于 spring boot 项目的自动化配置。</p><h2 id="107-spring-boot-配置文件有哪几种类型？它们有什么区别？"><a href="#107-spring-boot-配置文件有哪几种类型？它们有什么区别？" class="headerlink" title="107.spring boot 配置文件有哪几种类型？它们有什么区别？"></a>107.spring boot 配置文件有哪几种类型？它们有什么区别？</h2><p>配置文件有 . properties 格式和 . yml 格式，它们主要的区别是书法风格不同。<br>properties 配置如下：</p><p>spring. RabbitMQ. port=5672<br>yml 配置如下：</p><p>spring:<br>RabbitMQ:<br>port: 5672</p><p>yml 格式不支持 @PropertySource 注解导入。</p><h2 id="108-spring-boot-有哪些方式可以实现热部署？"><a href="#108-spring-boot-有哪些方式可以实现热部署？" class="headerlink" title="108.spring boot 有哪些方式可以实现热部署？"></a>108.spring boot 有哪些方式可以实现热部署？</h2><p>使用 devtools 启动热部署，添加 devtools 库，在配置文件中把 spring. devtools. restart. enabled 设置为 true；<br>使用 Intellij Idea 编辑器，勾上自动编译或手动重新编译。</p><h2 id="109-jpa-和-hibernate-有什么区别？"><a href="#109-jpa-和-hibernate-有什么区别？" class="headerlink" title="109.jpa 和 hibernate 有什么区别？"></a>109.jpa 和 hibernate 有什么区别？</h2><p>jpa 全称 Java Persistence API，是 Java 持久化接口规范，hibernate 属于 jpa 的具体实现。</p><h2 id="110-什么是-spring-cloud？"><a href="#110-什么是-spring-cloud？" class="headerlink" title="110.什么是 spring cloud？"></a>110.什么是 spring cloud？</h2><p>spring cloud 是一系列框架的有序集合。它利用 spring boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 spring boot 的开发风格做到一键启动和部署。</p><h2 id="111-spring-cloud-断路器的作用是什么？"><a href="#111-spring-cloud-断路器的作用是什么？" class="headerlink" title="111.spring cloud 断路器的作用是什么？"></a>111.spring cloud 断路器的作用是什么？</h2><p>在分布式架构中，断路器模式的作用也是类似的，当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个错误响应，而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延。</p><h2 id="112-spring-cloud-的核心组件有哪些？"><a href="#112-spring-cloud-的核心组件有哪些？" class="headerlink" title="112.spring cloud 的核心组件有哪些？"></a>112.spring cloud 的核心组件有哪些？</h2><p>Eureka：服务注册于发现。<br>Feign：基于动态代理机制，根据注解和选择的机器，拼接请求 url 地址，发起请求。<br>Ribbon：实现负载均衡，从一个服务的多台机器中选择一台。<br>Hystrix：提供线程池，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题。<br>Zuul：网关管理，由 Zuul 网关转发请求给对应的服务。</p><p>====================================================================</p><h1 id="十二-Hibernate模块"><a href="#十二-Hibernate模块" class="headerlink" title="十二. Hibernate模块"></a>十二. Hibernate模块</h1><h2 id="113-为什么要使用-hibernate？"><a href="#113-为什么要使用-hibernate？" class="headerlink" title="113.为什么要使用 hibernate？"></a>113.为什么要使用 hibernate？</h2><p>hibernate 是对 jdbc 的封装，大大简化了数据访问层的繁琐的重复性代码。<br>hibernate 是一个优秀的 ORM 实现，很多程度上简化了 DAO 层的编码功能。<br>可以很方便的进行数据库的移植工作。<br>提供了缓存机制，是程序执行更改的高效。</p><h2 id="114-什么是-ORM-框架？"><a href="#114-什么是-ORM-框架？" class="headerlink" title="114.什么是 ORM 框架？"></a>114.什么是 ORM 框架？</h2><p>ORM（Object Relation Mapping）对象关系映射，是把数据库中的关系数据映射成为程序中的对象。<br>使用 ORM 的优点：提高了开发效率降低了开发成本、开发更简单更对象化、可移植更强。</p><h2 id="115-hibernate-中如何在控制台查看打印的-SQL-语句？"><a href="#115-hibernate-中如何在控制台查看打印的-SQL-语句？" class="headerlink" title="115.hibernate 中如何在控制台查看打印的 SQL 语句？"></a>115.hibernate 中如何在控制台查看打印的 SQL 语句？</h2><p>在 Config 里面把 hibernate. show_SQL 设置为 true 就可以。但不建议开启，开启之后会降低程序的运行效率。</p><h2 id="116-hibernate-有几种查询方式？"><a href="#116-hibernate-有几种查询方式？" class="headerlink" title="116.hibernate 有几种查询方式？"></a>116.hibernate 有几种查询方式？</h2><p>三种：hql、原生 SQL、条件查询 Criteria。</p><h2 id="117-hibernate-实体类可以被定义为-final-吗？"><a href="#117-hibernate-实体类可以被定义为-final-吗？" class="headerlink" title="117.hibernate 实体类可以被定义为 final 吗？"></a>117.hibernate 实体类可以被定义为 final 吗？</h2><p>实体类可以定义为 final 类，但这样的话就不能使用 hibernate 代理模式下的延迟关联提供性能了，所以不建议定义实体类为 final。</p><h2 id="118-在-hibernate-中使用-Integer-和-int-做映射有什么区别？"><a href="#118-在-hibernate-中使用-Integer-和-int-做映射有什么区别？" class="headerlink" title="118.在 hibernate 中使用 Integer 和 int 做映射有什么区别？"></a>118.在 hibernate 中使用 Integer 和 int 做映射有什么区别？</h2><p>Integer 类型为对象，它的值允许为 null，而 int 属于基础数据类型，值不能为 null。</p><h2 id="119-hibernate-是如何工作的？"><a href="#119-hibernate-是如何工作的？" class="headerlink" title="119.hibernate 是如何工作的？"></a>119.hibernate 是如何工作的？</h2><p>读取并解析配置文件。<br>读取并解析映射文件，创建 SessionFactory。<br>打开 Session。<br>创建事务。<br>进行持久化操作。<br>提交事务。<br>关闭 Session。<br>关闭 SessionFactory。</p><h2 id="120-get-和-load-的区别？"><a href="#120-get-和-load-的区别？" class="headerlink" title="120.get()和 load()的区别？"></a>120.get()和 load()的区别？</h2><p>数据查询时，没有 OID 指定的对象，get() 返回 null；load() 返回一个代理对象。<br>load()支持延迟加载；get() 不支持延迟加载。</p><h2 id="121-说一下-hibernate-的缓存机制？"><a href="#121-说一下-hibernate-的缓存机制？" class="headerlink" title="121.说一下 hibernate 的缓存机制？"></a>121.说一下 hibernate 的缓存机制？</h2><p>hibernate 常用的缓存有一级缓存和二级缓存：<br>一级缓存：也叫 Session 缓存，只在 Session 作用范围内有效，不需要用户干涉，由 hibernate 自身维护，可以通过：evict(object)清除 object 的缓存；clear()清除一级缓存中的所有缓存；flush()刷出缓存；<br>二级缓存：应用级别的缓存，在所有 Session 中都有效，支持配置第三方的缓存，如：EhCache。</p><h2 id="122-hibernate-对象有哪些状态？"><a href="#122-hibernate-对象有哪些状态？" class="headerlink" title="122.hibernate 对象有哪些状态？"></a>122.hibernate 对象有哪些状态？</h2><p>临时/瞬时状态：直接 new 出来的对象，该对象还没被持久化（没保存在数据库中），不受 Session 管理。<br>持久化状态：当调用 Session 的 save/saveOrupdate/get/load/list 等方法的时候，对象就是持久化状态。<br>游离状态：Session 关闭之后对象就是游离状态。</p><h2 id="123-在-hibernate-中-getCurrentSession-和-openSession-的区别是什么？"><a href="#123-在-hibernate-中-getCurrentSession-和-openSession-的区别是什么？" class="headerlink" title="123.在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？"></a>123.在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？</h2><p>getCurrentSession 会绑定当前线程，而 openSession 则不会。<br>getCurrentSession 事务是 Spring 控制的，并且不需要手动关闭，而 openSession 需要我们自己手动开启和提交事务。</p><h2 id="124-hibernate-实体类必须要有无参构造函数吗？为什么？"><a href="#124-hibernate-实体类必须要有无参构造函数吗？为什么？" class="headerlink" title="124.hibernate 实体类必须要有无参构造函数吗？为什么？"></a>124.hibernate 实体类必须要有无参构造函数吗？为什么？</h2><p>hibernate 中每个实体类必须提供一个无参构造函数，因为 hibernate 框架要使用 reflection api，通过调用 ClassnewInstance() 来创建实体类的实例，如果没有无参的构造函数就会抛出异常。</p><p>====================================================================</p><h1 id="十三-MyBatis模块"><a href="#十三-MyBatis模块" class="headerlink" title="十三. MyBatis模块"></a>十三. MyBatis模块</h1><h2 id="125-MyBatis-中-和-的区别是什么？"><a href="#125-MyBatis-中-和-的区别是什么？" class="headerlink" title="125.MyBatis 中 #{}和 ${}的区别是什么？"></a>125.MyBatis 中 #{}和 ${}的区别是什么？</h2><p>#{}是预编译处理，${}是字符替换。 在使用 #{}时，MyBatis 会将 SQL 中的 #{}替换成“?”，配合 PreparedStatement 的 set 方法赋值，这样可以有效的防止 SQL 注入，保证程序的运行安全。</p><h2 id="126-MyBatis-有几种分页方式？"><a href="#126-MyBatis-有几种分页方式？" class="headerlink" title="126.MyBatis 有几种分页方式？"></a>126.MyBatis 有几种分页方式？</h2><p>分页方式：逻辑分页和物理分页。<br>逻辑分页： 使用 MyBatis 自带的 RowBounds 进行分页，它是一次性查询很多数据，然后在数据中再进行检索。<br>物理分页： 自己手写 SQL 分页或使用分页插件 PageHelper，去数据库查询指定条数的分页数据的形式。</p><h2 id="127-RowBounds-是一次性查询全部结果吗？为什么？"><a href="#127-RowBounds-是一次性查询全部结果吗？为什么？" class="headerlink" title="127.RowBounds 是一次性查询全部结果吗？为什么？"></a>127.RowBounds 是一次性查询全部结果吗？为什么？</h2><p>RowBounds 表面是在“所有”数据中检索数据，其实并非是一次性查询出所有数据，因为 MyBatis 是对 jdbc 的封装，在 jdbc 驱动中有一个 Fetch Size 的配置，它规定了每次最多从数据库查询多少条数据，假如你要查询更多数据，它会在你执行 next()的时候，去查询更多的数据。就好比你去自动取款机取 10000 元，但取款机每次最多能取 2500 元，所以你要取 4 次才能把钱取完。只是对于 jdbc 来说，当你调用 next()的时候会自动帮你完成查询工作。这样做的好处可以有效的防止内存溢出。<br>Fetch Size 官方相关文档：<a href="http://t" target="_blank" rel="noopener">http://t</a>. cn/EfSE2g3</p><h2 id="128-MyBatis-逻辑分页和物理分页的区别是什么？"><a href="#128-MyBatis-逻辑分页和物理分页的区别是什么？" class="headerlink" title="128.MyBatis 逻辑分页和物理分页的区别是什么？"></a>128.MyBatis 逻辑分页和物理分页的区别是什么？</h2><p>逻辑分页是一次性查询很多数据，然后再在结果中检索分页的数据。这样做弊端是需要消耗大量的内存、有内存溢出的风险、对数据库压力较大。<br>物理分页是从数据库查询指定条数的数据，弥补了一次性全部查出的所有数据的种种缺点，比如需要大量的内存，对数据库查询压力较大等问题。</p><h2 id="129-MyBatis-是否支持延迟加载？延迟加载的原理是什么？"><a href="#129-MyBatis-是否支持延迟加载？延迟加载的原理是什么？" class="headerlink" title="129.MyBatis 是否支持延迟加载？延迟加载的原理是什么？"></a>129.MyBatis 是否支持延迟加载？延迟加载的原理是什么？</h2><p>MyBatis 支持延迟加载，设置 lazyLoadingEnabled=true 即可。<br>延迟加载的原理的是调用的时候触发加载，而不是在初始化的时候就加载信息。比如调用 a. getB(). getName()，这个时候发现 a. getB() 的值为 null，此时会单独触发事先保存好的关联 B 对象的 SQL，先查询出来 B，然后再调用 a. setB(b)，而这时候再调用 a. getB(). getName() 就有值了，这就是延迟加载的基本原理。</p><h2 id="130-说一下-MyBatis-的一级缓存和二级缓存？"><a href="#130-说一下-MyBatis-的一级缓存和二级缓存？" class="headerlink" title="130.说一下 MyBatis 的一级缓存和二级缓存？"></a>130.说一下 MyBatis 的一级缓存和二级缓存？</h2><p>一级缓存：基于 PerpetualCache 的 HashMap 本地缓存，它的声明周期是和 SQLSession 一致的，有多个 SQLSession 或者分布式的环境中数据库操作，可能会出现脏数据。当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认一级缓存是开启的。<br>二级缓存：也是基于 PerpetualCache 的 HashMap 本地缓存，不同在于其存储作用域为 Mapper 级别的，如果多个SQLSession之间需要共享缓存，则需要使用到二级缓存，并且二级缓存可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态)。<br>开启二级缓存数据查询流程：二级缓存 -&gt; 一级缓存 -&gt; 数据库。<br>缓存更新机制：当某一个作用域(一级缓存 Session/二级缓存 Mapper)进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p><h2 id="131-MyBatis-和-hibernate-的区别有哪些？"><a href="#131-MyBatis-和-hibernate-的区别有哪些？" class="headerlink" title="131.MyBatis 和 hibernate 的区别有哪些？"></a>131.MyBatis 和 hibernate 的区别有哪些？</h2><p>灵活性：MyBatis 更加灵活，自己可以写 SQL 语句，使用起来比较方便。<br>可移植性：MyBatis 有很多自己写的 SQL，因为每个数据库的 SQL 可以不相同，所以可移植性比较差。<br>学习和使用门槛：MyBatis 入门比较简单，使用门槛也更低。<br>二级缓存：hibernate 拥有更好的二级缓存，它的二级缓存可以自行更换为第三方的二级缓存。</p><h2 id="132-MyBatis-有哪些执行器（Executor）？"><a href="#132-MyBatis-有哪些执行器（Executor）？" class="headerlink" title="132.MyBatis 有哪些执行器（Executor）？"></a>132.MyBatis 有哪些执行器（Executor）？</h2><p>MyBatis 有三种基本的Executor执行器：</p><p>SimpleExecutor：每执行一次 update 或 select 就开启一个 Statement 对象，用完立刻关闭 Statement 对象；<br>ReuseExecutor：执行 update 或 select，以 SQL 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后不关闭 Statement 对象，而是放置于 Map 内供下一次使用。简言之，就是重复使用 Statement 对象；<br>BatchExecutor：执行 update（没有 select，jdbc 批处理不支持 select），将所有 SQL 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理，与 jdbc 批处理相同。</p><h2 id="133-MyBatis-分页插件的实现原理是什么？"><a href="#133-MyBatis-分页插件的实现原理是什么？" class="headerlink" title="133.MyBatis 分页插件的实现原理是什么？"></a>133.MyBatis 分页插件的实现原理是什么？</h2><p>分页插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 SQL，然后重写 SQL，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。</p><h2 id="134-MyBatis-如何编写一个自定义插件？"><a href="#134-MyBatis-如何编写一个自定义插件？" class="headerlink" title="134.MyBatis 如何编写一个自定义插件？"></a>134.MyBatis 如何编写一个自定义插件？</h2><p>自定义插件实现原理：</p><p>MyBatis 自定义插件针对 MyBatis 四大对象（Executor、StatementHandler、ParameterHandler、ResultSetHandler）进行拦截：<br>Executor：拦截内部执行器，它负责调用 StatementHandler 操作数据库，并把结果集通过 ResultSetHandler 进行自动映射，另外它还处理了二级缓存的操作；<br>StatementHandler：拦截 SQL 语法构建的处理，它是 MyBatis 直接和数据库执行 SQL 脚本的对象，另外它也实现了 MyBatis 的一级缓存；<br>ParameterHandler：拦截参数的处理；<br>ResultSetHandler：拦截结果集的处理。<br>自定义插件实现关键：<br>MyBatis 插件要实现 Interceptor 接口，接口包含的方法，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">    <span class="function">Object <span class="title">plugin</span><span class="params">(Object target)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>setProperties 方法是在 MyBatis 进行配置插件的时候可以配置自定义相关属性，即：接口实现对象的参数配置；<br>plugin 方法是插件用于封装目标对象的，通过该方法我们可以返回目标对象本身，也可以返回一个它的代理，可以决定是否要进行拦截进而决定要返回一个什么样的目标对象，官方提供了示例：return Plugin. wrap(target, this)；<br>intercept 方法就是要进行拦截的时候要执行的方法。<br>自定义插件实现示例：<br>官方插件实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts</span>(&#123;<span class="meta">@Signature</span>(type = Executor. <span class="class"><span class="keyword">class</span>, <span class="title">method</span> </span>= <span class="string">"query"</span>,</span><br><span class="line">args = &#123;MappedStatement. <span class="class"><span class="keyword">class</span>, <span class="title">Object</span>. <span class="title">class</span>, <span class="title">RowBounds</span>. <span class="title">class</span>, <span class="title">ResultHandler</span>. <span class="title">class</span>&#125;)&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">TestInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object target = invocation. getTarget(); <span class="comment">//被代理对象</span></span><br><span class="line">        Method method = invocation. getMethod(); <span class="comment">//代理方法</span></span><br><span class="line">        Object[] args = invocation. getArgs(); <span class="comment">//方法参数</span></span><br><span class="line">        <span class="comment">// do something . . . . . . 方法拦截前执行代码块</span></span><br><span class="line">        Object result = invocation. proceed();</span><br><span class="line">        <span class="comment">// do something . . . . . . . 方法拦截后执行代码块</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Plugin. wrap(target, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>====================================================================</p><h1 id="十四-RabbitMQ模块"><a href="#十四-RabbitMQ模块" class="headerlink" title="十四. RabbitMQ模块"></a>十四. RabbitMQ模块</h1><h2 id="135-RabbitMQ-的使用场景有哪些？"><a href="#135-RabbitMQ-的使用场景有哪些？" class="headerlink" title="135.RabbitMQ 的使用场景有哪些？"></a>135.RabbitMQ 的使用场景有哪些？</h2><p>抢购活动，削峰填谷，防止系统崩塌。<br>延迟信息处理，比如 10 分钟之后给下单未付款的用户发送邮件提醒。<br>解耦系统，对于新增的功能可以单独写模块扩展，比如用户确认评价之后，新增了给用户返积分的功能，这个时候不用在业务代码里添加新增积分的功能，只需要把新增积分的接口订阅确认评价的消息队列即可，后面再添加任何功能只需要订阅对应的消息队列即可。</p><h2 id="136-RabbitMQ-有哪些重要的角色？"><a href="#136-RabbitMQ-有哪些重要的角色？" class="headerlink" title="136.RabbitMQ 有哪些重要的角色？"></a>136.RabbitMQ 有哪些重要的角色？</h2><p>RabbitMQ 中重要的角色有：生产者、消费者和代理：</p><p>生产者：消息的创建者，负责创建和推送数据到消息服务器；<br>消费者：消息的接收方，用于处理数据和确认消息；<br>代理：就是 RabbitMQ 本身，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色。</p><h2 id="137-RabbitMQ-有哪些重要的组件？"><a href="#137-RabbitMQ-有哪些重要的组件？" class="headerlink" title="137.RabbitMQ 有哪些重要的组件？"></a>137.RabbitMQ 有哪些重要的组件？</h2><p>ConnectionFactory（连接管理器）：应用程序与Rabbit之间建立连接的管理器，程序代码中使用。</p><p>Channel（信道）：消息推送使用的通道。<br>Exchange（交换器）：用于接受、分配消息。<br>Queue（队列）：用于存储生产者的消息。<br>RoutingKey（路由键）：用于把生成者的数据分配到交换器上。<br>BindingKey（绑定键）：用于把交换器的消息绑定到队列上。<br>138.RabbitMQ 中 vhost 的作用是什么？<br>vhost：每个 RabbitMQ 都能创建很多 vhost，我们称之为虚拟主机，每个虚拟主机其实都是 mini 版的RabbitMQ，它拥有自己的队列，交换器和绑定，拥有自己的权限机制。</p><h2 id="139-RabbitMQ-的消息是怎么发送的？"><a href="#139-RabbitMQ-的消息是怎么发送的？" class="headerlink" title="139.RabbitMQ 的消息是怎么发送的？"></a>139.RabbitMQ 的消息是怎么发送的？</h2><p>首先客户端必须连接到 RabbitMQ 服务器才能发布和消费消息，<br>客户端和 rabbit server 之间会创建一个 tcp 连接，一旦 tcp 打开并通过了认证<br>（认证就是你发送给 rabbit 服务器的用户名和密码），<br>你的客户端和 RabbitMQ 就创建了一条 amqp 信道（channel），<br>信道是创建在“真实” tcp 上的虚拟连接，amqp 命令都是通过信道发送出去的，<br>每个信道都会有一个唯一的 id，不论是发布消息，订阅队列都是通过这个信道完成的。</p><h2 id="140-RabbitMQ-怎么保证消息的稳定性？"><a href="#140-RabbitMQ-怎么保证消息的稳定性？" class="headerlink" title="140.RabbitMQ 怎么保证消息的稳定性？"></a>140.RabbitMQ 怎么保证消息的稳定性？</h2><p>提供了事务的功能。<br>通过将 channel 设置为 confirm（确认）模式。</p><h2 id="141-RabbitMQ-怎么避免消息丢失？"><a href="#141-RabbitMQ-怎么避免消息丢失？" class="headerlink" title="141.RabbitMQ 怎么避免消息丢失？"></a>141.RabbitMQ 怎么避免消息丢失？</h2><p>把消息持久化磁盘，保证服务器重启消息不丢失。<br>每个集群中至少有一个物理磁盘，保证消息落入磁盘。</p><h2 id="142-要保证消息持久化成功的条件有哪些？"><a href="#142-要保证消息持久化成功的条件有哪些？" class="headerlink" title="142.要保证消息持久化成功的条件有哪些？"></a>142.要保证消息持久化成功的条件有哪些？</h2><p>声明队列必须设置持久化 durable 设置为 true.<br>消息推送投递模式必须设置持久化，deliveryMode 设置为 2（持久）。<br>消息已经到达持久化交换器。<br>消息已经到达持久化队列。<br>以上四个条件都满足才能保证消息持久化成功。</p><h2 id="143-RabbitMQ-持久化有什么缺点？"><a href="#143-RabbitMQ-持久化有什么缺点？" class="headerlink" title="143.RabbitMQ 持久化有什么缺点？"></a>143.RabbitMQ 持久化有什么缺点？</h2><p>持久化的缺地就是降低了服务器的吞吐量，因为使用的是磁盘而非内存存储，<br>从而降低了吞吐量。可尽量使用 ssd 硬盘来缓解吞吐量的问题。</p><h2 id="144-RabbitMQ-有几种广播类型？"><a href="#144-RabbitMQ-有几种广播类型？" class="headerlink" title="144.RabbitMQ 有几种广播类型？"></a>144.RabbitMQ 有几种广播类型？</h2><p>direct（默认方式）：最基础最简单的模式，发送方把消息发送给订阅方，<br>如果有多个订阅者，默认采取轮询的方式进行消息发送。<br>headers：与 direct 类似，只是性能很差，此类型几乎用不到。<br>fanout：分发模式，把消费分发给所有订阅者。<br>topic：匹配订阅模式，使用正则匹配到消息队列，能匹配到的都能接收到。</p><h2 id="145-RabbitMQ-怎么实现延迟消息队列？"><a href="#145-RabbitMQ-怎么实现延迟消息队列？" class="headerlink" title="145.RabbitMQ 怎么实现延迟消息队列？"></a>145.RabbitMQ 怎么实现延迟消息队列？</h2><p>延迟队列的实现有两种方式：</p><p>通过消息过期后进入死信交换器，再由交换器转发到延迟消费队列，实现延迟功能；<br>使用 RabbitMQ-delayed-message-exchange 插件实现延迟功能。</p><h2 id="146-RabbitMQ-集群有什么用？"><a href="#146-RabbitMQ-集群有什么用？" class="headerlink" title="146.RabbitMQ 集群有什么用？"></a>146.RabbitMQ 集群有什么用？</h2><p>集群主要有以下两个用途：</p><p>高可用：某个服务器出现问题，整个 RabbitMQ 还可以继续使用；<br>高容量：集群可以承载更多的消息量。</p><h2 id="147-RabbitMQ-节点的类型有哪些？"><a href="#147-RabbitMQ-节点的类型有哪些？" class="headerlink" title="147.RabbitMQ 节点的类型有哪些？"></a>147.RabbitMQ 节点的类型有哪些？</h2><p>磁盘节点：消息会存储到磁盘。<br>内存节点：消息都存储在内存中，重启服务器消息丢失，性能高于磁盘类型。</p><h2 id="148-RabbitMQ-集群搭建需要注意哪些问题？"><a href="#148-RabbitMQ-集群搭建需要注意哪些问题？" class="headerlink" title="148.RabbitMQ 集群搭建需要注意哪些问题？"></a>148.RabbitMQ 集群搭建需要注意哪些问题？</h2><p>各节点之间使用“–link”连接，此属性不能忽略。<br>各节点使用的 erlang cookie 值必须相同，此值相当于“秘钥”的功能，用于各节点的认证。<br>整个集群中必须包含一个磁盘节点。</p><h2 id="149-RabbitMQ-每个节点是其他节点的完整拷贝吗？为什么？"><a href="#149-RabbitMQ-每个节点是其他节点的完整拷贝吗？为什么？" class="headerlink" title="149.RabbitMQ 每个节点是其他节点的完整拷贝吗？为什么？"></a>149.RabbitMQ 每个节点是其他节点的完整拷贝吗？为什么？</h2><p>不是，原因有以下两个：</p><p>存储空间的考虑：如果每个节点都拥有所有队列的完全拷贝，<br>这样新增节点不但没有新增存储空间，反而增加了更多的冗余数据；<br>性能的考虑：如果每条消息都需要完整拷贝到每一个集群节点，<br>那新增节点并没有提升处理消息的能力，最多是保持和单节点相同的性能甚至是更糟。</p><h2 id="150-RabbitMQ-集群中唯一一个磁盘节点崩溃了会发生什么情况？"><a href="#150-RabbitMQ-集群中唯一一个磁盘节点崩溃了会发生什么情况？" class="headerlink" title="150.RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么情况？"></a>150.RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么情况？</h2><p>如果唯一磁盘的磁盘节点崩溃了，不能进行以下操作：<br>不能创建队列、<br>不能创建交换器、<br>不能创建绑定、<br>不能添加用户、<br>不能更改权限、<br>不能添加和删除集群节点、<br>唯一磁盘节点崩溃了，集群是可以保持运行的，但你不能更改任何东西。</p><h2 id="151-RabbitMQ-对集群节点停止顺序有要求吗？"><a href="#151-RabbitMQ-对集群节点停止顺序有要求吗？" class="headerlink" title="151.RabbitMQ 对集群节点停止顺序有要求吗？"></a>151.RabbitMQ 对集群节点停止顺序有要求吗？</h2><p>RabbitMQ 对集群的停止的顺序是有要求的，应该先关闭内存节点，<br>最后再关闭磁盘节点。如果顺序恰好相反的话，可能会造成消息的丢失。</p><p>====================================================================</p><h1 id="十五-Kafka"><a href="#十五-Kafka" class="headerlink" title="十五. Kafka"></a>十五. Kafka</h1><h2 id="152-kafka-可以脱离-zookeeper-单独使用吗？为什么？"><a href="#152-kafka-可以脱离-zookeeper-单独使用吗？为什么？" class="headerlink" title="152.kafka 可以脱离 zookeeper 单独使用吗？为什么？"></a>152.kafka 可以脱离 zookeeper 单独使用吗？为什么？</h2><p>kafka 不能脱离 zookeeper 单独使用，因为 kafka 使用 zookeeper<br>管理和协调 kafka 的节点服务器。</p><h2 id="153-kafka-有几种数据保留的策略？"><a href="#153-kafka-有几种数据保留的策略？" class="headerlink" title="153.kafka 有几种数据保留的策略？"></a>153.kafka 有几种数据保留的策略？</h2><p>kafka 有两种数据保存策略：按照过期时间保留和按照存储的消息大小保留。</p><h2 id="154-kafka-同时设置了-7-天和-10G-清除数据，到第五天的时候消息达到了-10G，这个时候-kafka-将如何处理？"><a href="#154-kafka-同时设置了-7-天和-10G-清除数据，到第五天的时候消息达到了-10G，这个时候-kafka-将如何处理？" class="headerlink" title="154.kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka 将如何处理？"></a>154.kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka 将如何处理？</h2><p>这个时候 kafka 会执行数据清除工作，时间和大小不论那个满足条件，都会清空数据。</p><h2 id="155-什么情况会导致-kafka-运行变慢？"><a href="#155-什么情况会导致-kafka-运行变慢？" class="headerlink" title="155.什么情况会导致 kafka 运行变慢？"></a>155.什么情况会导致 kafka 运行变慢？</h2><p>cpu性能瓶颈、<br>磁盘读写瓶颈、<br>网络瓶颈。</p><h2 id="156-使用-kafka-集群需要注意什么？"><a href="#156-使用-kafka-集群需要注意什么？" class="headerlink" title="156.使用 kafka 集群需要注意什么？"></a>156.使用 kafka 集群需要注意什么？</h2><p>集群的数量不是越多越好，最好不要超过 7 个，因为节点越多，消息复制需要的时间就越长，<br>整个群组的吞吐量就越低。<br>集群数量最好是单数，因为超过一半故障集群就不能用了，设置为单数容错率更高。</p><p>====================================================================</p><h1 id="十六-Zookeeper模块"><a href="#十六-Zookeeper模块" class="headerlink" title="十六. Zookeeper模块"></a>十六. Zookeeper模块</h1><h2 id="157-zookeeper-是什么？"><a href="#157-zookeeper-是什么？" class="headerlink" title="157.zookeeper 是什么？"></a>157.zookeeper 是什么？</h2><p>zookeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是 google chubby 的开源实现，是 hadoop 和 hbase 的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。</p><h2 id="158-zookeeper-都有哪些功能？"><a href="#158-zookeeper-都有哪些功能？" class="headerlink" title="158.zookeeper 都有哪些功能？"></a>158.zookeeper 都有哪些功能？</h2><p>集群管理：监控节点存活状态、运行请求等。<br>主节点选举：主节点挂掉了之后可以从备用的节点开始新一轮选主，主节点选举说的就是这个选举的过程，使用 zookeeper 可以协助完成这个过程。<br><br>分布式锁：zookeeper 提供两种锁：独占锁、共享锁。独占锁即一次只能有一个线程使用资源，共享锁是读锁共享，读写互斥，即可以有多线线程同时读同一个资源，如果要使用写锁也只能有一个线程使用。zookeeper可以对分布式锁进行控制。<br>命名服务：在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。</p><h2 id="159-zookeeper-有几种部署模式？"><a href="#159-zookeeper-有几种部署模式？" class="headerlink" title="159.zookeeper 有几种部署模式？"></a>159.zookeeper 有几种部署模式？</h2><p>zookeeper 有三种部署模式：<br><br>单机部署：一台集群上运行；<br><br>集群部署：多台集群运行；<br><br>伪集群部署：一台集群启动多个 zookeeper 实例运行。</p><h2 id="160-zookeeper-怎么保证主从节点的状态同步？"><a href="#160-zookeeper-怎么保证主从节点的状态同步？" class="headerlink" title="160.zookeeper 怎么保证主从节点的状态同步？"></a>160.zookeeper 怎么保证主从节点的状态同步？</h2><p>zookeeper 的核心是原子广播，这个机制保证了各个 server 之间的同步。<br>实现这个机制的协议叫做 zab 协议。 zab 协议有两种模式，<br>分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，<br>zab 就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的<br>状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。</p><h2 id="161-集群中为什么要有主节点？"><a href="#161-集群中为什么要有主节点？" class="headerlink" title="161.集群中为什么要有主节点？"></a>161.集群中为什么要有主节点？</h2><p>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，<br>其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，所以就需要主节点。</p><h2 id="162-集群中有-3-台服务器，其中一个节点宕机，这个时候-zookeeper-还可以使用吗？"><a href="#162-集群中有-3-台服务器，其中一个节点宕机，这个时候-zookeeper-还可以使用吗？" class="headerlink" title="162.集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？"></a>162.集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？</h2><p>可以继续使用，单数服务器只要没超过一半的服务器宕机就可以继续使用。</p><h2 id="163-说一下-zookeeper-的通知机制？"><a href="#163-说一下-zookeeper-的通知机制？" class="headerlink" title="163.说一下 zookeeper 的通知机制？"></a>163.说一下 zookeeper 的通知机制？</h2><p>客户端端会对某个 znode 建立一个 watcher 事件，当该 znode 发生变化时，<br>这些客户端会收到 zookeeper 的通知，然后客户端可以根据 znode 变化来做出业务上的改变。</p><p>====================================================================</p><h1 id="十七-MySQL模块"><a href="#十七-MySQL模块" class="headerlink" title="十七. MySQL模块"></a>十七. MySQL模块</h1><h2 id="164-数据库的三范式是什么？"><a href="#164-数据库的三范式是什么？" class="headerlink" title="164.数据库的三范式是什么？"></a>164.数据库的三范式是什么？</h2><p>第一范式（1NF）：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。<br>第二范式（2NF）：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。（在1NF基础上消除非主属性对主键的部分函数依赖）<br>第三范式（3NF）：任何非主属性不依赖于其它非主属性。（在2NF基础上消除传递依赖）</p><h2 id="165-一张自增表里面总共有-7-条数据，删除了最后-2-条数据，重启-MySQL-数据库，又插入了一条数据，此时-id-是几？"><a href="#165-一张自增表里面总共有-7-条数据，删除了最后-2-条数据，重启-MySQL-数据库，又插入了一条数据，此时-id-是几？" class="headerlink" title="165.一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 MySQL 数据库，又插入了一条数据，此时 id 是几？"></a>165.一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 MySQL 数据库，又插入了一条数据，此时 id 是几？</h2><p>表类型如果是 MyISAM ，那 id 就是 8。<br>表类型如果是 InnoDB，那 id 就是 6。<br>InnoDB 表只会把自增主键的最大 id 记录在内存中，所以重启之后会导致最大 id 丢失。</p><h2 id="166-如何获取当前数据库版本？"><a href="#166-如何获取当前数据库版本？" class="headerlink" title="166.如何获取当前数据库版本？"></a>166.如何获取当前数据库版本？</h2><p>使用 select version() 获取当前 MySQL 数据库版本。</p><h2 id="167-说一下-ACID-是什么？"><a href="#167-说一下-ACID-是什么？" class="headerlink" title="167.说一下 ACID 是什么？"></a>167.说一下 ACID 是什么？</h2><p>Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。<br><br>Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。<br><br>Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。<br><br>Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p><h2 id="168-char-和-varchar-的区别是什么？"><a href="#168-char-和-varchar-的区别是什么？" class="headerlink" title="168.char 和 varchar 的区别是什么？"></a>168.char 和 varchar 的区别是什么？</h2><p>char(n) ：固定长度类型，比如订阅 char(10)，当你输入”abc”三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。<br>优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。</p><p>varchar(n) ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。<br>所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。</p><h2 id="169-float-和-double-的区别是什么？"><a href="#169-float-和-double-的区别是什么？" class="headerlink" title="169.float 和 double 的区别是什么？"></a>169.float 和 double 的区别是什么？</h2><p>float 最多可以存储 8 位的十进制数，并在内存中占 4 字节。<br>double 最可可以存储 16 位的十进制数，并在内存中占 8 字节。</p><h2 id="170-MySQL-的内连接、左连接、右连接有什么区别？"><a href="#170-MySQL-的内连接、左连接、右连接有什么区别？" class="headerlink" title="170.MySQL 的内连接、左连接、右连接有什么区别？"></a>170.MySQL 的内连接、左连接、右连接有什么区别？</h2><p>内连接关键字：inner join；左连接：left join；右连接：right join。<br>内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。</p><h2 id="171-MySQL-索引是怎么实现的？"><a href="#171-MySQL-索引是怎么实现的？" class="headerlink" title="171.MySQL 索引是怎么实现的？"></a>171.MySQL 索引是怎么实现的？</h2><p>索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。<br>具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。</p><h2 id="172-怎么验证-MySQL-的索引是否满足需求？"><a href="#172-怎么验证-MySQL-的索引是否满足需求？" class="headerlink" title="172.怎么验证 MySQL 的索引是否满足需求？"></a>172.怎么验证 MySQL 的索引是否满足需求？</h2><p>使用 explain 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。<br>explain 语法：explain select * from table where type=1。</p><h2 id="173-说一下数据库的事务隔离？"><a href="#173-说一下数据库的事务隔离？" class="headerlink" title="173.说一下数据库的事务隔离？"></a>173.说一下数据库的事务隔离？</h2><p>MySQL 的事务隔离是在 MySQL. ini 配置文件里添加的，在文件的最后添加：</p><p>transaction-isolation = REPEATABLE-READ<br>1<br>可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。</p><p>READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。<br>READ-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。<br>REPEATABLE-READ：可重复读，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。<br>SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。<br>脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。<br>不可重复读 ：是指在一个事务内，多次读同一数据。<br>幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p><h2 id="174-说一下-MySQL-常用的引擎？"><a href="#174-说一下-MySQL-常用的引擎？" class="headerlink" title="174.说一下 MySQL 常用的引擎？"></a>174.说一下 MySQL 常用的引擎？</h2><p>InnoDB引擎：InnoDB 引擎提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行 select count(*) from table 指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。<br></p><p>MyIASM引擎：MySQL 的默认引擎，但不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。</p><h2 id="175-说一下-MySQL-的行锁和表锁？"><a href="#175-说一下-MySQL-的行锁和表锁？" class="headerlink" title="175.说一下 MySQL 的行锁和表锁？"></a>175.说一下 MySQL 的行锁和表锁？</h2><p>MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。</p><p>表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。<br><br>行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。</p><h2 id="176-说一下乐观锁和悲观锁？"><a href="#176-说一下乐观锁和悲观锁？" class="headerlink" title="176.说一下乐观锁和悲观锁？"></a>176.说一下乐观锁和悲观锁？</h2><p><strong>乐观锁</strong>：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。<br><br><strong>悲观锁</strong>：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。<br><br>数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。</p><h2 id="177-MySQL-问题排查都有哪些手段？"><a href="#177-MySQL-问题排查都有哪些手段？" class="headerlink" title="177.MySQL 问题排查都有哪些手段？"></a>177.MySQL 问题排查都有哪些手段？</h2><p>使用 show processlist 命令查看当前所有连接信息。<br>使用 explain 命令查询 SQL 语句执行计划。<br>开启慢查询日志，查看慢查询的 SQL。</p><h2 id="178-如何做-MySQL-的性能优化？"><a href="#178-如何做-MySQL-的性能优化？" class="headerlink" title="178.如何做 MySQL 的性能优化？"></a>178.如何做 MySQL 的性能优化？</h2><p>为搜索字段创建索引。<br>避免使用 select *，列出需要查询的字段。<br>垂直分割分表。</p><h1 id="选择正确的存储引擎。"><a href="#选择正确的存储引擎。" class="headerlink" title="选择正确的存储引擎。"></a>选择正确的存储引擎。</h1><h1 id="十八-Redis模块"><a href="#十八-Redis模块" class="headerlink" title="十八. Redis模块"></a>十八. Redis模块</h1><h2 id="179-Redis-是什么？都有哪些使用场景？"><a href="#179-Redis-是什么？都有哪些使用场景？" class="headerlink" title="179.Redis 是什么？都有哪些使用场景？"></a>179.Redis 是什么？都有哪些使用场景？</h2><p>Redis 是一个使用 C 语言开发的高速缓存数据库。<br>redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave主从同步【主从同步：数据可以从主服务器向任意数量的从服务器上同步】。<br>Redis 是一个高性能的key-value数据库。 redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部 分场合可以对关系数据库起到很好的补充作用。它提供了Java，C/C++，C#，PHP，JavaScript，Perl，Object-C，Python，Ruby，Erlang等客户端，使用很方便。<br>Redis 使用场景：</p><p>记录帖子点赞数、点击数、评论数；<br>缓存近期热帖；<br>缓存文章详情信息；<br>记录用户会话信息。</p><h2 id="180-Redis-有哪些功能？"><a href="#180-Redis-有哪些功能？" class="headerlink" title="180.Redis 有哪些功能？"></a>180.Redis 有哪些功能？</h2><p>数据缓存功能、<br>分布式锁的功能、<br>支持数据持久化、<br>支持事务、<br>支持消息队列、</p><h2 id="181-Redis-和-memcache-有什么区别？"><a href="#181-Redis-和-memcache-有什么区别？" class="headerlink" title="181.Redis 和 memcache 有什么区别？"></a>181.Redis 和 memcache 有什么区别？</h2><p>存储方式不同：memcache 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小；Redis 有部份存在硬盘上，这样能保证数据的持久性。<br>数据支持类型：memcache 对数据类型支持相对简单；Redis 有复杂的数据类型。<br>使用底层模型不同：它们之间底层实现方式，以及与客户端之间通信的应用协议不一样，Redis 自己构建了 vm 机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。<br>value 值大小不同：Redis 最大可以达到 1gb；memcache 只有 1mb。</p><h2 id="182-Redis-为什么是单线程的？"><a href="#182-Redis-为什么是单线程的？" class="headerlink" title="182.Redis 为什么是单线程的？"></a>182.Redis 为什么是单线程的？</h2><p>因为 cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了。<br>关于 Redis 的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。而且单线程并不代表就慢， nginx 和 node.js 也都是高性能单线程的代表。</p><h2 id="183-什么是缓存穿透？怎么解决？"><a href="#183-什么是缓存穿透？怎么解决？" class="headerlink" title="183.什么是缓存穿透？怎么解决？"></a>183.什么是缓存穿透？怎么解决？</h2><p><strong>缓存穿透</strong>：指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。<br><br><strong>解决方案</strong>：最简单粗暴的方法如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们就把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</p><h2 id="184-Redis-支持的数据类型有哪些？"><a href="#184-Redis-支持的数据类型有哪些？" class="headerlink" title="184.Redis 支持的数据类型有哪些？"></a>184.Redis 支持的数据类型有哪些？</h2><p>Redis 支持的数据类型：string（字符串）、list（列表）、hash（字典）、set（集合）、zset（有序集合）；</p><p>另外3种特殊数据类型Geospatial(地理空间)、Bitmap、hyperLogLog</p><h2 id="185-Redis-支持的-Java-客户端都有哪些？"><a href="#185-Redis-支持的-Java-客户端都有哪些？" class="headerlink" title="185.Redis 支持的 Java 客户端都有哪些？"></a>185.Redis 支持的 Java 客户端都有哪些？</h2><p>支持的 Java 客户端有 Redisson、jedis、lettuce 等。</p><h2 id="186-jedis-和-Redisson-有哪些区别？"><a href="#186-jedis-和-Redisson-有哪些区别？" class="headerlink" title="186.jedis 和 Redisson 有哪些区别？"></a>186.jedis 和 Redisson 有哪些区别？</h2><p>jedis：提供了比较全面的 Redis 命令的支持。<br><br>Redisson：实现了分布式和可扩展的 Java 数据结构，与 jedis 相比 Redisson 的功能相对简单，不支持排序、事务、管道、分区等 Redis 特性。</p><h2 id="187-怎么保证缓存和数据库数据的一致性？"><a href="#187-怎么保证缓存和数据库数据的一致性？" class="headerlink" title="187.怎么保证缓存和数据库数据的一致性？"></a>187.怎么保证缓存和数据库数据的一致性？</h2><p>合理设置缓存的过期时间。<br>新增、更改、删除数据库操作时同步更新 Redis，可以使用事物机制来保证数据的一致性。</p><h2 id="188-Redis-持久化有几种方式？"><a href="#188-Redis-持久化有几种方式？" class="headerlink" title="188.Redis 持久化有几种方式？"></a>188.Redis 持久化有几种方式？</h2><p>Redis 的持久化有两种方式，或者说有两种策略：<br><br>RDB（Redis Database）：指定的时间间隔能对你的数据进行快照存储。<br><br>AOF（Append Only File）：每一个收到的写命令都通过write函数追加到文件中。</p><h2 id="189-Redis-怎么实现分布式锁？"><a href="#189-Redis-怎么实现分布式锁？" class="headerlink" title="189.Redis 怎么实现分布式锁？"></a>189.Redis 怎么实现分布式锁？</h2><p>Redis 分布式锁其实就是在系统里面占一个“坑”，其他程序也要占“坑”的时候，占用成功了就可以继续执行，失败了就只能放弃或稍后重试。<br>占坑一般使用 setnx(set if not exists)指令，只允许被一个程序占有，使用完调用 del 释放锁。</p><h2 id="190-Redis-分布式锁有什么缺陷？"><a href="#190-Redis-分布式锁有什么缺陷？" class="headerlink" title="190.Redis 分布式锁有什么缺陷？"></a>190.Redis 分布式锁有什么缺陷？</h2><p>Redis 分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。</p><h2 id="191-Redis-如何做内存优化？"><a href="#191-Redis-如何做内存优化？" class="headerlink" title="191.Redis 如何做内存优化？"></a>191.Redis 如何做内存优化？</h2><p>尽量使用 Redis 的散列表，把相关的信息放到散列表里面存储，而不是把每个字段单独存储，这样可以有效的减少内存使用。比如将 Web 系统的用户对象，应该放到散列表里面再整体存储到 Redis，而不是把用户的姓名、年龄、密码、邮箱等字段分别设置 key 进行存储。</p><h2 id="192-Redis-淘汰策略有哪些？"><a href="#192-Redis-淘汰策略有哪些？" class="headerlink" title="192.Redis 淘汰策略有哪些？"></a>192.Redis 淘汰策略有哪些？</h2><p>volatile-lru：从已设置过期时间的数据集（server. db[i]. expires）中挑选最近最少使用的数据淘汰。<br>volatile-ttl：从已设置过期时间的数据集（server. db[i]. expires）中挑选将要过期的数据淘汰。<br>volatile-random：从已设置过期时间的数据集（server. db[i]. expires）中任意选择数据淘汰。<br>allkeys-lru：从数据集（server. db[i]. dict）中挑选最近最少使用的数据淘汰。<br>allkeys-random：从数据集（server. db[i]. dict）中任意选择数据淘汰。<br>no-enviction（驱逐）：禁止驱逐数据。</p><h2 id="193-Redis-常见的性能问题有哪些？该如何解决？"><a href="#193-Redis-常见的性能问题有哪些？该如何解决？" class="headerlink" title="193.Redis 常见的性能问题有哪些？该如何解决？"></a>193.Redis 常见的性能问题有哪些？该如何解决？</h2><p>主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。<br>Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。</p><p>====================================================================</p><h1 id="十九-JVM模块"><a href="#十九-JVM模块" class="headerlink" title="十九. JVM模块"></a>十九. JVM模块</h1><h2 id="194-说一下-JVM-的主要组成部分？及其作用？"><a href="#194-说一下-JVM-的主要组成部分？及其作用？" class="headerlink" title="194.说一下 JVM 的主要组成部分？及其作用？"></a>194.说一下 JVM 的主要组成部分？及其作用？</h2><p>类加载器（ClassLoader）<br>运行时数据区（Runtime Data Area）<br>执行引擎（Execution Engine）<br>本地库接口（Native Interface）<br>组件的作用： 首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。</p><h2 id="195-说一下-JVM-运行时数据区？"><a href="#195-说一下-JVM-运行时数据区？" class="headerlink" title="195.说一下 JVM 运行时数据区？"></a>195.说一下 JVM 运行时数据区？</h2><p>不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范， Java 虚拟机规范规定的区域分为以下 5 个部分：</p><p>程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；<br>Java 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作数栈、动态链接、方法出口等信息；<br>本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；<br>Java 堆（Java Heap）：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；<br>方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</p><h2 id="196-说一下堆栈的区别？"><a href="#196-说一下堆栈的区别？" class="headerlink" title="196.说一下堆栈的区别？"></a>196.说一下堆栈的区别？</h2><p>功能方面：堆是用来存放对象的，栈是用来执行程序的。<br>共享性：堆是线程共享的，栈是线程私有的。<br>空间大小：堆大小远远大于栈。</p><h2 id="197-队列和栈是什么？有什么区别？"><a href="#197-队列和栈是什么？有什么区别？" class="headerlink" title="197.队列和栈是什么？有什么区别？"></a>197.队列和栈是什么？有什么区别？</h2><p>队列和栈都是被用来预存储数据的。<br>队列允许先进先出检索元素，但也有例外的情况，Deque 接口允许从两端检索元素。<br>栈和队列很相似，但它运行对元素进行后进先出进行检索。</p><h2 id="198-什么是双亲委派模型？"><a href="#198-什么是双亲委派模型？" class="headerlink" title="198.什么是双亲委派模型？"></a>198.什么是双亲委派模型？</h2><p>在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身统一确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。<br>类加载器分类：</p><p>启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；<br>其他类加载器：<br>扩展类加载器（Extension ClassLoader）：负责加载\lib\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；<br>应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。<br>双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。</p><h2 id="199-说一下类装载的执行过程？"><a href="#199-说一下类装载的执行过程？" class="headerlink" title="199.说一下类装载的执行过程？"></a>199.说一下类装载的执行过程？</h2><p>类装载分为以下 5 个步骤：</p><p>加载：根据查找路径找到相应的 class 文件然后导入；<br>检查：检查加载的 class 文件的正确性；<br>准备：给类中的静态变量分配内存空间；<br>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；<br>初始化：对静态变量和静态代码块执行初始化工作。</p><h2 id="200-怎么判断对象是否可以被回收？"><a href="#200-怎么判断对象是否可以被回收？" class="headerlink" title="200.怎么判断对象是否可以被回收？"></a>200.怎么判断对象是否可以被回收？</h2><p>一般有两种方法来判断：</p><p>引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，<br>引用被释放时计数 -1，当计数器为 0 时就可以被回收。<br>它有一个缺点不能解决循环引用的问题；<br>可达性分析：从 GC Roots 开始向下搜索，<br>搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，<br>则证明此对象是可以被回收的。</p><h2 id="201-Java-中都有哪些引用类型？"><a href="#201-Java-中都有哪些引用类型？" class="headerlink" title="201.Java 中都有哪些引用类型？"></a>201.Java 中都有哪些引用类型？</h2><p>强引用：发生 gc 的时候不会被回收。<br>软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。<br>弱引用：有用但不是必须的对象，在下一次GC时会被回收。<br>虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 现虚引用，虚引用的用途是在 gc 时返回一个通知。</p><h2 id="202-说一下-JVM-有哪些垃圾回收算法？"><a href="#202-说一下-JVM-有哪些垃圾回收算法？" class="headerlink" title="202.说一下 JVM 有哪些垃圾回收算法？"></a>202.说一下 JVM 有哪些垃圾回收算法？</h2><p>标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。<br>标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，<br>然后直接清除掉端边界以外的内存。<br>复制算法：按照容量划分二个大小相等的内存区域，<br>当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。<br>缺点：内存使用率不高，只有原来的一半。<br>分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，<br>新生代基本采用复制算法，老年代采用标记整理算法。</p><h2 id="203-说一下-JVM-有哪些垃圾回收器？"><a href="#203-说一下-JVM-有哪些垃圾回收器？" class="headerlink" title="203.说一下 JVM 有哪些垃圾回收器？"></a>203.说一下 JVM 有哪些垃圾回收器？</h2><p>Serial：最早的单线程串行垃圾回收器。<br>Serial Old：Serial 垃圾回收器的老年版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案。<br>ParNew：是 Serial 的多线程版本。<br>Parallel 和 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。<br>Parallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内存回收算法，Parallel Old 使用的是标记-整理的内存回收算法。<br>CMS：一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统。<br>G1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。</p><h2 id="204-详细介绍一下-CMS-垃圾回收器？"><a href="#204-详细介绍一下-CMS-垃圾回收器？" class="headerlink" title="204.详细介绍一下 CMS 垃圾回收器？"></a>204.详细介绍一下 CMS 垃圾回收器？</h2><p>CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。<br>CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。</p><h2 id="205-新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？"><a href="#205-新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？" class="headerlink" title="205.新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？"></a>205.新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？</h2><p>新生代回收器：Serial、ParNew、Parallel Scavenge<br>老年代回收器：Serial Old、Parallel Old、CMS<br>整堆回收器：G1<br>新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。</p><h2 id="206-简述分代垃圾回收器是怎么工作的？"><a href="#206-简述分代垃圾回收器是怎么工作的？" class="headerlink" title="206.简述分代垃圾回收器是怎么工作的？"></a>206.简述分代垃圾回收器是怎么工作的？</h2><p>分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。<br>新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：</p><p>把 Eden + From Survivor 存活的对象放入 To Survivor 区；<br>清空 Eden 和 From Survivor 分区；<br>From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。<br>每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。<br>老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</p><h2 id="207-说一下-JVM-调优的工具？"><a href="#207-说一下-JVM-调优的工具？" class="headerlink" title="207.说一下 JVM 调优的工具？"></a>207.说一下 JVM 调优的工具？</h2><p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。</p><p>jconsole：用于对 JVM 中的内存、线程和类等进行监控；<br>jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。</p><h2 id="208-常用的-JVM-调优的参数都有哪些？"><a href="#208-常用的-JVM-调优的参数都有哪些？" class="headerlink" title="208.常用的 JVM 调优的参数都有哪些？"></a>208.常用的 JVM 调优的参数都有哪些？</h2><p>-Xms2g：初始化推大小为 2g；<br>-Xmx2g：堆最大内存为 2g；<br>-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；<br>-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；<br>–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；<br>-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；<br>-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；<br>-XX:+PrintGC：开启打印 gc 信息；<br>-XX:+PrintGCDetails：打印 gc 详细信息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;================================&lt;br&gt;&lt;/p&gt;
&lt;h4 id=&quot;设计模式分为：创建型模式（单例、工厂、抽象工厂）、结构型模式（代理、组合、装饰）、行为型模式（策略、模板方法、迭代器）&quot;&gt;&lt;a href=&quot;#设计模式分为：创建型模式（单例、工
      
    
    </summary>
    
    
      <category term="Java" scheme="http://gilgameshzzz.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>理解Go位运算符</title>
    <link href="http://gilgameshzzz.github.io/2019/07/08/%E7%90%86%E8%A7%A3Go%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>http://gilgameshzzz.github.io/2019/07/08/理解Go位运算符/</id>
    <published>2019-07-07T16:00:00.000Z</published>
    <updated>2020-04-19T15:06:33.479Z</updated>
    
    <content type="html"><![CDATA[<p>假定A = 14, B = 11,转换为二进制：A = 1110， B = 1011。</p><table><thead><tr><th style="text-align:center">A</th><th style="text-align:center">1</th><th style="text-align:center">1</th><th style="text-align:center">1</th><th style="text-align:center">0</th></tr></thead><tbody><tr><td style="text-align:center">B</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td></td></tr><tr><td style="text-align:center">A&amp;B</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td></td></tr><tr><td style="text-align:center">A\</td><td style="text-align:center">B</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td>1</td></tr><tr><td style="text-align:center">A^B</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr></tbody></table><p>A&amp;B 转换为十进制等于10;<br>A|B 转换为十进制等于15;<br>A^B 转换为十进制等于5;<br>&amp; 是求与，两个数都为1才为1，其余情况为0；<br>| 是求或，两个数都为0才为0，其余情况为1；<br>^ 是求异，两个数相同时为0，不同时为1；<br>还有 &lt;&lt; 左移运算，将数字的二进制左移n位，或是将数字的十进制乘以2的n次方，由”&lt;&lt;”右边的数指定移动的位数，高位丢弃，低位补0；</p><p>N * 2 等同于  N &lt;&lt; ㏒₂2  =   N  &lt;&lt;  1</p><p>“&gt;&gt;” 右移运算，将数字的二进制右移n位，或是将数字的十进制除以2的n次方，由”&gt;&gt;”右边的数指定移动的位数；</p><p>N / 2 等同于  N &gt;&gt; ㏒₂2  =   N  &gt;&gt;  1</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;假定A = 14, B = 11,转换为二进制：A = 1110， B = 1011。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;A&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;1
      
    
    </summary>
    
    
      <category term="Golang" scheme="http://gilgameshzzz.github.io/tags/Golang/"/>
    
      <category term="位移" scheme="http://gilgameshzzz.github.io/tags/%E4%BD%8D%E7%A7%BB/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB删除重复数据和唯一索引</title>
    <link href="http://gilgameshzzz.github.io/2019/06/03/MongoDB%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E6%95%B0%E6%8D%AE%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95/"/>
    <id>http://gilgameshzzz.github.io/2019/06/03/MongoDB删除重复数据和唯一索引/</id>
    <published>2019-06-02T16:00:00.000Z</published>
    <updated>2020-04-16T02:26:19.270Z</updated>
    
    <content type="html"><![CDATA[<p>MongoDB 版本V4.0.9</p><h2 id="删除MongoDB删除重复数据"><a href="#删除MongoDB删除重复数据" class="headerlink" title="删除MongoDB删除重复数据"></a>删除MongoDB删除重复数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.CompanyId.aggregate([&#123;$group:&#123; _id:&#123;&apos;pid&apos;:&apos;$pid&apos;&#125;,count:&#123;$sum: 1&#125;,dups: &#123;$addToSet: &apos;$_id&apos;&#125;&#125;&#125;, &#123;$match: &#123;count: &#123;$gt: 1&#125;&#125;&#125;]).forEach(function(doc)&#123;</span><br><span class="line">doc.dups.shift();db.CompanyId.remove(&#123;_id: &#123;$in: doc.dups&#125;&#125;);&#125;)</span><br></pre></td></tr></table></figure><p>1.根据pid分组并统计数量，$group只会返回参与分组的字段，使用$addToSet在返回结果数组中增加_id字段</p><p>2.使用$match匹配数量大于1的数据</p><p>3.doc.dups.shift();表示从数组第一个值开始删除；作用是踢除重复数据其中一个_id，让后面的删除语句不会删除所有数据</p><p>4.使用forEach循环根据_id删除数据，$addToSet 操作符只有在值没有存在于数组中时才会向数组中添加一个值。如果值已经存在于数组中，$addToSet返回，不会修改数组。</p><p>注意：forEach和$addToSet的驼峰写法不能全部写成小写，因为mongodb严格区分大小写、mongodb严格区分大小写、mongodb严格区分大小写，重要的事情说三遍！</p><p>聚合框架它是数据聚合的一个新框架，其概念类似于数据处理的管道。 每个文档通过一个由多个节点组成的管道，每个节点有自己特殊的功能（分组、过滤等），文档经过管道处理后，最后输出相应的结果。</p><p>管道基本的功能有两个：<br>一是对文档进行“过滤”，也就是筛选出符合条件的文档;<br>二是对文档进行“变换”，也就是改变文档的输出形式。</p><h2 id="MongoDB唯一索引"><a href="#MongoDB唯一索引" class="headerlink" title="MongoDB唯一索引"></a>MongoDB唯一索引</h2><p>在ensureIndex 命令中指定”unique:true”即可创建唯一索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.CompanyId.ensureIndex(&#123;字段1: 1, 字段2: 1&#125;, &#123;unique: true&#125;);</span><br></pre></td></tr></table></figure></p><p>字段1：1，中的1表示升序，-1表示降序</p><h2 id="MongoDB-查询两个字段的值相同的数据"><a href="#MongoDB-查询两个字段的值相同的数据" class="headerlink" title="MongoDB 查询两个字段的值相同的数据"></a>MongoDB 查询两个字段的值相同的数据</h2><p>因为MongoDB 不是关系型数据库，不可以直接使用”…Where 字段A=字段B”的方式来查找字段相同的条目，但可以使用“$where”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">db.foo.find(&#123;&quot;$where&quot;:function()&#123;</span><br><span class="line"> for(var current in this)&#123;</span><br><span class="line">   for(var other in this)&#123;</span><br><span class="line">     if(current != other &amp;&amp; this[current] == this[other])&#123;</span><br><span class="line">       return true;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> return false;</span><br><span class="line">&#125;&#125;)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MongoDB 版本V4.0.9&lt;/p&gt;
&lt;h2 id=&quot;删除MongoDB删除重复数据&quot;&gt;&lt;a href=&quot;#删除MongoDB删除重复数据&quot; class=&quot;headerlink&quot; title=&quot;删除MongoDB删除重复数据&quot;&gt;&lt;/a&gt;删除MongoDB删除重复数据&lt;/
      
    
    </summary>
    
    
      <category term="MongoDB" scheme="http://gilgameshzzz.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>Redis Sentinel哨兵</title>
    <link href="http://gilgameshzzz.github.io/2019/05/09/Redis_Sentinel/"/>
    <id>http://gilgameshzzz.github.io/2019/05/09/Redis_Sentinel/</id>
    <published>2019-05-08T16:00:00.000Z</published>
    <updated>2020-04-16T02:37:18.907Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis-Sentinel是Redis官方推荐的高可用性-HA-解决方案"><a href="#Redis-Sentinel是Redis官方推荐的高可用性-HA-解决方案" class="headerlink" title="Redis-Sentinel是Redis官方推荐的高可用性(HA)解决方案"></a>Redis-Sentinel是Redis官方推荐的高可用性(HA)解决方案</h2><p>&emsp;&emsp;该方案由一个或多个Sentinel实例组成的Sentinel系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进行下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。Redis提供的sentinel（哨兵）机制，通过sentinel模式启动redis后，自动监控master/slave的运行状态，基本原理是：心跳机制+投票裁决，主要功能：</p><ul><li><strong>监控</strong>，Sentinel不断地监控redis是否按照预期良好地运行;</li><li><strong>提醒</strong>，如果发现某个redis节点运行出现状况，Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。或能够通知另外一个进程(例如它的客户端)。</li><li><strong>自动故障迁移</strong>，当一个master节点不可用时，能够选举出master的多个slave(如果有超过一个slave的话)中的一个来作为新的master,其它的slave节点会将它所追随的master的地址改为被提升为master的slave的新地址。</li><li><strong>自动更新配置信息</strong>：哨兵提供了认证和服务发现，客户端连接到哨兵去获取当前redis主服务器地址，如果发生故障转移，哨兵将会汇报新的服务器地址。每次进行主从切换时，sentinel配置文件自动更新。</li></ul><h2 id="运行Sentinel"><a href="#运行Sentinel" class="headerlink" title="运行Sentinel"></a>运行Sentinel</h2><p>第一种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel /path/to/sentinel.conf</span><br></pre></td></tr></table></figure></p><p>第二种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server /path/to/sentinel.conf --sentinel</span><br></pre></td></tr></table></figure></p><p>无论使用哪种都需要指定一个配置文件，sentinel默认26379端口。</p><h2 id="Sentinel配置"><a href="#Sentinel配置" class="headerlink" title="Sentinel配置"></a>Sentinel配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@DB ~]# vim /sentinel.conf </span><br><span class="line">port 26379</span><br><span class="line">daemonize yes #程序后台执行</span><br><span class="line">logfile &quot;/var/log/sentinel.log&quot;</span><br><span class="line">dir &quot;/tmp&quot;</span><br><span class="line">#第一次设置哨兵时此ip一定要设置为redis集群中的主ip</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2 </span><br><span class="line">sentinel down-after-milliseconds mymaster 5000</span><br><span class="line">sentinel failover-timeout mymaster 6000</span><br><span class="line">sentinel config-epoch mymaster 7</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br></pre></td></tr></table></figure><p><strong>sentinel monitor mymaster 127.0.0.1 6379 2</strong><br>&emsp;&emsp;这一行代表sentinel监控的master的名字叫做mymaster,地址为127.0.0.1:6379，行尾最后的一个2代表,当集群中有2个sentinel认为master死了时，才能真正认为该master已经不可用了。（sentinel集群中各个sentinel也有互相通信，通过gossip协议）。</p><p>除了第一行配置，剩下的配置都有一个统一的格式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel &lt;option_name&gt; &lt;master_name&gt; &lt;option_value&gt;</span><br></pre></td></tr></table></figure></p><ul><li>down-after-milliseconds </li></ul><p>&emsp;&emsp;表示：如果master在“一定时间范围”内不回应PONG 或者是回复了一个错误消息，那么这个sentinel会主观地(单方面地)认为这个master已经不可用了(subjectively down, 也简称为SDOWN)。而这个down-after-milliseconds就是用来指定这个“一定时间范围”的，单位是毫秒。</p><ul><li>parallel-syncs</li></ul><p>&emsp;&emsp;在发生failover主备切换时，这个选项指定了最多可以有多少个slave同时对新的master进行同步，这个数字越小，完成failover所需的时间就越长，但是如果这个数字越大，就意味着越多的slave因为replication而不可用。可以通过将这个值设为 1 来保证每次只有一个slave处于不能处理命令请求的状态。</p><p>​                   <a href="https://segmentfault.com/a/1190000002685515" target="_blank" rel="noopener">Redis Sentinel机制与用法(二)</a></p><h2 id="python访问Sentinel集群"><a href="#python访问Sentinel集群" class="headerlink" title="python访问Sentinel集群"></a>python访问Sentinel集群</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> redis.sentinel <span class="keyword">import</span> Sentinel <span class="comment">#加载redis模块</span></span><br><span class="line"><span class="comment"># 连接哨兵服务器</span></span><br><span class="line">sentinel = Sentinel([(<span class="string">'192.168.221.160'</span>, <span class="number">26379</span>),</span><br><span class="line">       (<span class="string">'192.168.221.161'</span>, <span class="number">26379</span>)], socket_timeout=<span class="number">0.1</span>)</span><br><span class="line">       </span><br><span class="line">sentinel.discover_master(<span class="string">'mymaster'</span>) <span class="comment">#获取主redis服务器地址</span></span><br><span class="line"></span><br><span class="line">sentinel.discover_slaves(<span class="string">'mymaster'</span>)<span class="comment">#获取从redis服务区地址</span></span><br><span class="line"></span><br><span class="line">master = sentinel.master_for(<span class="string">'mymaster'</span>, socket_timeout=<span class="number">0.1</span>)</span><br><span class="line">master.set(<span class="string">'foo'</span>,<span class="string">'bar'</span>) <span class="comment">#获取主redis服务器并进行写入</span></span><br><span class="line"></span><br><span class="line">slave = sentinel.slave_for(<span class="string">'mymaster'</span>, socket_timeout=<span class="number">0.1</span>)</span><br><span class="line">slave.get(<span class="string">'foo'</span>)<span class="comment">#获取从redis服务器进行获取</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Redis-Sentinel是Redis官方推荐的高可用性-HA-解决方案&quot;&gt;&lt;a href=&quot;#Redis-Sentinel是Redis官方推荐的高可用性-HA-解决方案&quot; class=&quot;headerlink&quot; title=&quot;Redis-Sentinel是Red
      
    
    </summary>
    
    
      <category term="Redis" scheme="http://gilgameshzzz.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>request_cookie</title>
    <link href="http://gilgameshzzz.github.io/2019/04/19/request_cookie/"/>
    <id>http://gilgameshzzz.github.io/2019/04/19/request_cookie/</id>
    <published>2019-04-18T16:00:00.000Z</published>
    <updated>2020-04-16T02:30:05.139Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天调用百度接口时，postman只需要传入BDUSS的内容就能获取数据，但在python-requests的请求时，也传入BDUSS部分cookie，却不能获取数据。"><a href="#今天调用百度接口时，postman只需要传入BDUSS的内容就能获取数据，但在python-requests的请求时，也传入BDUSS部分cookie，却不能获取数据。" class="headerlink" title="今天调用百度接口时，postman只需要传入BDUSS的内容就能获取数据，但在python requests的请求时，也传入BDUSS部分cookie，却不能获取数据。"></a>今天调用百度接口时，postman只需要传入BDUSS的内容就能获取数据，但在python requests的请求时，也传入BDUSS部分cookie，却不能获取数据。</h1><h1 id="折腾半天，把浏览器上cookie全部复制传入，就能获取数据了。也不知道咋回事，知道的老哥请解答一下。"><a href="#折腾半天，把浏览器上cookie全部复制传入，就能获取数据了。也不知道咋回事，知道的老哥请解答一下。" class="headerlink" title="折腾半天，把浏览器上cookie全部复制传入，就能获取数据了。也不知道咋回事，知道的老哥请解答一下。"></a>折腾半天，把浏览器上cookie全部复制传入，就能获取数据了。也不知道咋回事，知道的老哥请解答一下。</h1><p>================================</p><h1 id="解决了，是因为postman-除了自己填写的BDUSS还添加了BDPPN-所以python代码加上BDUSS和BDPPN也能获取数据。（BDUSS和BDPPN是百度自己设置的名字，也不知道postman是怎么知道要带上这个。）"><a href="#解决了，是因为postman-除了自己填写的BDUSS还添加了BDPPN-所以python代码加上BDUSS和BDPPN也能获取数据。（BDUSS和BDPPN是百度自己设置的名字，也不知道postman是怎么知道要带上这个。）" class="headerlink" title="解决了，是因为postman 除了自己填写的BDUSS还添加了BDPPN,所以python代码加上BDUSS和BDPPN也能获取数据。（BDUSS和BDPPN是百度自己设置的名字，也不知道postman是怎么知道要带上这个。）"></a>解决了，是因为postman 除了自己填写的BDUSS还添加了BDPPN,所以python代码加上BDUSS和BDPPN也能获取数据。（BDUSS和BDPPN是百度自己设置的名字，也不知道postman是怎么知道要带上这个。）</h1><p>================================</p><h1 id="把postman上的cookie删除后，第一次访问，拿不到内容，但是会设置cookie，第二次访问，就有数据了（可能是第一次访问后，postman获取了BDPPN。第二次再访问时，就带上了BDPPN。）"><a href="#把postman上的cookie删除后，第一次访问，拿不到内容，但是会设置cookie，第二次访问，就有数据了（可能是第一次访问后，postman获取了BDPPN。第二次再访问时，就带上了BDPPN。）" class="headerlink" title="把postman上的cookie删除后，第一次访问，拿不到内容，但是会设置cookie，第二次访问，就有数据了（可能是第一次访问后，postman获取了BDPPN。第二次再访问时，就带上了BDPPN。）"></a>把postman上的cookie删除后，第一次访问，拿不到内容，但是会设置cookie，第二次访问，就有数据了（可能是第一次访问后，postman获取了BDPPN。第二次再访问时，就带上了BDPPN。）</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;今天调用百度接口时，postman只需要传入BDUSS的内容就能获取数据，但在python-requests的请求时，也传入BDUSS部分cookie，却不能获取数据。&quot;&gt;&lt;a href=&quot;#今天调用百度接口时，postman只需要传入BDUSS的内容就能获取数据
      
    
    </summary>
    
    
      <category term="问题" scheme="http://gilgameshzzz.github.io/tags/%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>python定时运行代码</title>
    <link href="http://gilgameshzzz.github.io/2019/03/01/python%E6%AF%8F%E6%97%A5%E5%AE%9A%E6%97%B6/"/>
    <id>http://gilgameshzzz.github.io/2019/03/01/python每日定时/</id>
    <published>2019-02-28T16:00:00.000Z</published>
    <updated>2020-04-16T02:36:44.668Z</updated>
    
    <content type="html"><![CDATA[<h1 id="循环-sleep"><a href="#循环-sleep" class="headerlink" title="循环 sleep"></a>循环 sleep</h1><p>&emsp;&emsp;这种方式最简单，只要在循环里加入需要执行的代码，然后sleep后在执行。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每n秒执行一次</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        function(*args,**kargs)</span><br><span class="line">        time.sleep(n)</span><br><span class="line"><span class="comment"># 5s</span></span><br><span class="line">timer(<span class="number">5</span>)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这个方法的缺点：只能执行固定间隔时间的任务，如果有定时任务就无法完成。并且sleep是一个阻塞函数，也就是说sleep这一段时间，啥都不能做。</p><hr><h1 id="threading模块中的Timer"><a href="#threading模块中的Timer" class="headerlink" title="threading模块中的Timer"></a>threading模块中的Timer</h1><p>&emsp;&emsp;threading模块中的Timer是一个非阻塞函数，比sleep稍好一点。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Timer</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Timertion</span><span class="params">(second)</span>:</span></span><br><span class="line">    function(*args, **kargs)</span><br><span class="line">    t = Timer(second, printTime, (*args, **kargs))</span><br><span class="line">    t.start()</span><br><span class="line"><span class="comment"># 5s</span></span><br><span class="line">Timertion(<span class="number">5</span>)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;Timer 函数第一个参数是时间间隔（单位是秒），第二个参数是要调用的函数名，第三个参数是调用函数的参数(tuple)</p><hr><h1 id="sched模块"><a href="#sched模块" class="headerlink" title="sched模块"></a>sched模块</h1><p>&emsp;&emsp;sched 模块是 Python 内置的模块，它是一个调度（延时处理机制），每次想要定时执行某任务都必须写入一个调度。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sched</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化sched模块的 scheduler 类</span></span><br><span class="line"><span class="comment"># 第一个参数是一个可以返回时间戳的函数，第二个参数可以在定时未到达之前阻塞。</span></span><br><span class="line">schedule = sched.scheduler(time.time, time.sleep)</span><br><span class="line"><span class="comment"># 被周期性调度触发的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Timertion</span><span class="params">(second)</span>:</span></span><br><span class="line">    function(*args, **kargs)</span><br><span class="line">    schedule.enter(second, <span class="number">0</span>, function, (*args, **kargs))</span><br><span class="line"><span class="comment"># 默认参数60s</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(second=<span class="number">60</span>)</span>:</span></span><br><span class="line">    <span class="comment"># enter四个参数分别为：间隔时间、优先级（用于同时间到达的两个事件同时执行时定序）、被调用触发的函数，</span></span><br><span class="line">    <span class="comment"># 第四个：给该触发函数的参数（tuple形式）</span></span><br><span class="line">    schedule.enter(<span class="number">0</span>, <span class="number">0</span>, function, (*args, **kargs))</span><br><span class="line">    schedule.run()</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 10s 输出一次</span></span><br><span class="line">main(<span class="number">10</span>)</span><br></pre></td></tr></table></figure></p><h2 id="使用注意："><a href="#使用注意：" class="headerlink" title="使用注意："></a>使用注意：</h2><p>&emsp;&emsp;（1）传调用函数的参数时，一定要以 tuple 给，如果只有一个参数就(xx,)<br>&emsp;&emsp;（2）sched 模块不是循环的，一次调度被执行后就 Over 了，如果想再执行，请再次 enter</p><hr><h1 id="APScheduler定时框架"><a href="#APScheduler定时框架" class="headerlink" title="APScheduler定时框架"></a>APScheduler定时框架</h1><p>&emsp;&emsp;终于找到了可以每天定时运行指定代码的方式了<br>&emsp;&emsp;<a href="https://apscheduler.readthedocs.io/en/latest/userguide.html" target="_blank" rel="noopener">APScheduler</a>是一个 Python 定时任务框架，使用起来十分方便。提供了基于日期、固定时间间隔以及 crontab 类型的任务，并且可以持久化任务、并以 daemon 方式运行应用。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> apscheduler.schedulers.blocking <span class="keyword">import</span> BlockingScheduler</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">every_job</span><span class="params">()</span>:</span></span><br><span class="line">    function(*args, **kargs)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># BlockingScheduler</span></span><br><span class="line">scheduler = BlockingScheduler()</span><br><span class="line">scheduler.add_job(every_job, <span class="string">'cron'</span>, day_of_week=<span class="string">'1-6'</span>, hour=<span class="number">16</span>, minute=<span class="number">40</span>)</span><br><span class="line">scheduler.start()</span><br></pre></td></tr></table></figure></p><p>代码中的 BlockingScheduler 是什么呢？</p><p>&emsp;&emsp;BlockingScheduler 是 APScheduler 中的调度器，APScheduler 中有两种常用的调度器，BlockingScheduler 和 BackgroundScheduler，当调度器是应用中唯一要运行的任务时，使用 BlockingSchedule，如果希望调度器在后台执行，使用 BackgroundScheduler。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. BlockingScheduler: use when the scheduler is the only thing running in your process</span><br><span class="line">2. BackgroundScheduler: use when you’re not using any of the frameworks below, and want the scheduler to run in the background inside your application</span><br><span class="line">3. AsyncIOScheduler: use if your application uses the asyncio module</span><br><span class="line">4. GeventScheduler: use if your application uses gevent</span><br><span class="line">5. TornadoScheduler: use if you’re building a Tornado application</span><br><span class="line">6. TwistedScheduler: use if you’re building a Twisted application</span><br><span class="line">7. QtScheduler: use if you’re building a Qt application</span><br></pre></td></tr></table></figure></p><h2 id="APScheduler四个组件"><a href="#APScheduler四个组件" class="headerlink" title="APScheduler四个组件"></a>APScheduler四个组件</h2><p>&emsp;&emsp;APScheduler 四个组件分别为：触发器(trigger)，作业存储(job store)，执行器(executor)，调度器(scheduler)。</p><h3 id="触发器-trigger"><a href="#触发器-trigger" class="headerlink" title="触发器(trigger)"></a>触发器(trigger)</h3><p>&emsp;&emsp;包含调度逻辑，每一个作业有它自己的触发器，用于决定接下来哪一个作业会运行。除了他们自己初始配置意外，触发器完全是无状态的。<br>APScheduler 有三种内建的 trigger:</p><ul><li>date: 特定的时间点触发</li><li>interval: 固定时间间隔触发</li><li>cron: 在特定时间周期性地触发</li></ul><h3 id="作业存储-job-store"><a href="#作业存储-job-store" class="headerlink" title="作业存储(job store)"></a>作业存储(job store)</h3><p>&emsp;&emsp;存储被调度的作业，默认的作业存储是简单地把作业保存在内存中，其他的作业存储是将作业保存在数据库中。一个作业的数据讲在保存在持久化作业存储时被序列化，并在加载时被反序列化。调度器不能分享同一个作业存储。<br>APScheduler 默认使用 MemoryJobStore，可以修改使用 DB 存储方案</p><h3 id="执行器-executor"><a href="#执行器-executor" class="headerlink" title="执行器(executor)"></a>执行器(executor)</h3><p>&emsp;&emsp;处理作业的运行，他们通常通过在作业中提交制定的可调用对象到一个线程或者进城池来进行。当作业完成时，执行器将会通知调度器。<br>最常用的 executor 有两种：</p><ul><li>ProcessPoolExecutor</li><li>ThreadPoolExecutor</li></ul><h3 id="调度器-scheduler"><a href="#调度器-scheduler" class="headerlink" title="调度器(scheduler)"></a>调度器(scheduler)</h3><p>&emsp;&emsp;通常在应用中只有一个调度器，应用的开发者通常不会直接处理作业存储、调度器和触发器，相反，调度器提供了处理这些的合适的接口。配置作业存储和执行器可以在调度器中完成，例如添加、修改和移除作业。</p><h2 id="配置调度器"><a href="#配置调度器" class="headerlink" title="配置调度器"></a>配置调度器</h2><p>&emsp;&emsp;APScheduler提供了许多不同的方式来配置调度器，灵活性强<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> apscheduler.schedulers.blocking <span class="keyword">import</span> BlockingScheduler</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job</span><span class="params">()</span>:</span></span><br><span class="line">   function(*args, **kargs)</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 定义BlockingScheduler</span></span><br><span class="line">sched = BlockingScheduler()</span><br><span class="line">sched.add_job(job, <span class="string">'interval'</span>, seconds=<span class="number">5</span>)</span><br><span class="line">sched.start()</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;上述代码创建了一个 BlockingScheduler，并使用默认内存存储和默认执行器。(默认选项分别是 MemoryJobStore 和 ThreadPoolExecutor，其中线程池的最大线程数为10)。配置完成后使用 start() 方法来启动。</p><p>如果想要显式设置 job store(使用mongo存储)和 executor 可以这样写：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pymongo <span class="keyword">import</span> MongoClient</span><br><span class="line"><span class="keyword">from</span> apscheduler.schedulers.blocking <span class="keyword">import</span> BlockingScheduler</span><br><span class="line"><span class="keyword">from</span> apscheduler.jobstores.memory <span class="keyword">import</span> MemoryJobStore</span><br><span class="line"><span class="keyword">from</span> apscheduler.jobstores.mongodb <span class="keyword">import</span> MongoDBJobStore</span><br><span class="line"><span class="keyword">from</span> apscheduler.executors.pool <span class="keyword">import</span> ThreadPoolExecutor, ProcessPoolExecutor</span><br><span class="line"><span class="comment"># MongoDB 参数</span></span><br><span class="line">host = <span class="string">'127.0.0.1'</span></span><br><span class="line">port = <span class="number">27017</span></span><br><span class="line">client = MongoClient(host, port)</span><br><span class="line"><span class="comment"># 输出时间</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job</span><span class="params">()</span>:</span></span><br><span class="line">    function(*args, **kargs)</span><br><span class="line"><span class="comment"># 存储方式</span></span><br><span class="line">jobstores = &#123;</span><br><span class="line">    <span class="string">'mongo'</span>: MongoDBJobStore(collection=<span class="string">'job'</span>, database=<span class="string">'test'</span>, client=client),</span><br><span class="line">    <span class="string">'default'</span>: MemoryJobStore()</span><br><span class="line">&#125;</span><br><span class="line">executors = &#123;</span><br><span class="line">    <span class="string">'default'</span>: ThreadPoolExecutor(<span class="number">10</span>),</span><br><span class="line">    <span class="string">'processpool'</span>: ProcessPoolExecutor(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line">job_defaults = &#123;</span><br><span class="line">    <span class="string">'coalesce'</span>: <span class="keyword">False</span>,</span><br><span class="line">    <span class="string">'max_instances'</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">scheduler = BlockingScheduler(jobstores=jobstores, executors=executors, job_defaults=job_defaults)</span><br><span class="line">scheduler.add_job(job, <span class="string">'interval'</span>, seconds=<span class="number">5</span>, jobstore=<span class="string">'mongo'</span>)</span><br><span class="line">scheduler.start()</span><br></pre></td></tr></table></figure></p><p>在 MongoDB 中可以看到 job 的状态</p><h2 id="对-job-的操作"><a href="#对-job-的操作" class="headerlink" title="对 job 的操作"></a>对 job 的操作</h2><h3 id="添加-job"><a href="#添加-job" class="headerlink" title="添加 job"></a>添加 job</h3><ol><li>add_job()</li><li>scheduled_job()<br>第二种方法只适用于应用运行期间不会改变的 job，而第一种方法返回一个<a href="https://apscheduler.readthedocs.io/en/latest/modules/job.html#apscheduler.job.Job" target="_blank" rel="noopener">apscheduler.job.Job</a> 的实例，可以用来改变或者移除 job。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> apscheduler.schedulers.blocking <span class="keyword">import</span> BlockingScheduler</span><br><span class="line">sched = BlockingScheduler()</span><br><span class="line"><span class="comment"># 装饰器</span></span><br><span class="line"><span class="meta">@sched.scheduled_job('interval', id='my_job_id', seconds=5)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job_function</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"Hello World"</span>)</span><br><span class="line"><span class="comment"># 开始</span></span><br><span class="line">sched.start()</span><br></pre></td></tr></table></figure></li></ol><h3 id="删除-job"><a href="#删除-job" class="headerlink" title="删除 job"></a>删除 job</h3><ol><li>remove_job()</li><li>job.remove()<br>remove_job 使用 jobID 移除<br>job.remove() 使用 add_job() 返回的实例<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">job = scheduler.add_job(myfunc, <span class="string">'interval'</span>, minutes=<span class="number">2</span>)</span><br><span class="line">job.remove()</span><br><span class="line"><span class="comment"># id</span></span><br><span class="line">scheduler.add_job(myfunc, <span class="string">'interval'</span>, minutes=<span class="number">2</span>, id=<span class="string">'my_job_id'</span>)</span><br><span class="line">scheduler.remove_job(<span class="string">'my_job_id'</span>)</span><br></pre></td></tr></table></figure></li></ol><h3 id="暂停和恢复-job"><a href="#暂停和恢复-job" class="headerlink" title="暂停和恢复 job"></a>暂停和恢复 job</h3><p>暂停:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apscheduler.job.Job.pause()</span><br><span class="line">apscheduler.schedulers.base.BaseScheduler.pause_job()</span><br></pre></td></tr></table></figure></p><p>恢复:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apscheduler.job.Job.resume()</span><br><span class="line">apscheduler.schedulers.base.BaseScheduler.resume_job()</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;希望你还记得 apscheduler.job.Job 是 add_job() 返回的实例</p><h3 id="获取-job-列表"><a href="#获取-job-列表" class="headerlink" title="获取 job 列表"></a>获取 job 列表</h3><p>获得可调度 job 列表，可以使用<a href="https://apscheduler.readthedocs.io/en/latest/modules/schedulers/base.html#apscheduler.schedulers.base.BaseScheduler.get_jobs" target="_blank" rel="noopener">get_jobs()</a> 来完成，它会返回所有的 job 实例.也可以使用<a href="https://apscheduler.readthedocs.io/en/latest/modules/schedulers/base.html#apscheduler.schedulers.base.BaseScheduler.print_jobs" target="_blank" rel="noopener">print_jobs()</a> 来输出所有格式化的 job 列表。</p><h3 id="修改-job"><a href="#修改-job" class="headerlink" title="修改 job"></a>修改 job</h3><p>&emsp;&emsp;除了 jobID 之外 job 的所有属性都可以修改，使用 apscheduler.job.Job.modify() 或者 modify_job() 修改一个 job 的属性<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">job.modify(max_instances=<span class="number">6</span>, name=<span class="string">'Alternate name'</span>)</span><br><span class="line">modify_job(<span class="string">'my_job_id'</span>, trigger=<span class="string">'cron'</span>, minute=<span class="string">'*/5'</span>)</span><br></pre></td></tr></table></figure></p><h3 id="关闭-job"><a href="#关闭-job" class="headerlink" title="关闭 job"></a>关闭 job</h3><p>&emsp;&emsp;默认情况下调度器会等待所有的 job 完成后，关闭所有的调度器和作业存储。将 wait 选项设置为 False 可以立即关闭。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scheduler.shutdown()</span><br><span class="line">scheduler.shutdown(wait=<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure></p><h3 id="scheduler-事件"><a href="#scheduler-事件" class="headerlink" title="scheduler 事件"></a>scheduler 事件</h3><p>&emsp;&emsp;scheduler 可以添加事件监听器，并在特殊的时间触发。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_listener</span><span class="params">(event)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> event.exception:</span><br><span class="line">        print(<span class="string">'The job crashed :('</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'The job worked :)'</span>)</span><br><span class="line"><span class="comment"># 添加监听器</span></span><br><span class="line">scheduler.add_listener(my_listener, EVENT_JOB_EXECUTED | EVENT_JOB_ERROR)</span><br></pre></td></tr></table></figure></p><h2 id="trigger-规则"><a href="#trigger-规则" class="headerlink" title="trigger 规则"></a>trigger 规则</h2><p><a href="https://apscheduler.readthedocs.io/en/latest/modules/triggers/date.html" target="_blank" rel="noopener">date</a><br>&emsp;&emsp;最基本的一种调度，作业只会执行一次。它的参数如下：</p><ul><li>run_date (datetime|str) – the date/time to run the job at</li><li>timezone (datetime.tzinfo|str) – time zone for run_date if it doesn’t have one already<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date</span><br><span class="line"><span class="keyword">from</span> apscheduler.schedulers.blocking <span class="keyword">import</span> BlockingScheduler</span><br><span class="line">sched = BlockingScheduler()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_job</span><span class="params">(text)</span>:</span></span><br><span class="line">    print(text)</span><br><span class="line"><span class="comment"># The job will be executed on November 6th, 2009</span></span><br><span class="line">sched.add_job(my_job, <span class="string">'date'</span>, run_date=date(<span class="number">2009</span>, <span class="number">11</span>, <span class="number">6</span>), args=[<span class="string">'text'</span>])</span><br><span class="line">sched.add_job(my_job, <span class="string">'date'</span>, run_date=datetime(<span class="number">2009</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">16</span>, <span class="number">30</span>, <span class="number">5</span>), args=[<span class="string">'text'</span>])</span><br><span class="line">sched.add_job(my_job, <span class="string">'date'</span>, run_date=<span class="string">'2009-11-06 16:30:05'</span>, args=[<span class="string">'text'</span>])</span><br><span class="line"><span class="comment"># The 'date' trigger and datetime.now() as run_date are implicit</span></span><br><span class="line">sched.add_job(my_job, args=[<span class="string">'text'</span>])</span><br><span class="line">sched.start()</span><br></pre></td></tr></table></figure></li></ul><p><a href="https://apscheduler.readthedocs.io/en/latest/modules/triggers/cron.html" target="_blank" rel="noopener">cron</a></p><ul><li>year (int|str) – 4-digit year</li><li>month (int|str) – month (1-12)</li><li>day (int|str) – day of the (1-31)</li><li>week (int|str) – ISO week (1-53)</li><li>day_of_week (int|str) – number or name of weekday (0-6 or mon,tue,wed,thu,fri,sat,sun)</li><li>hour (int|str) – hour (0-23)</li><li>minute (int|str) – minute (0-59)</li><li>second (int|str) – second (0-59)</li><li>start_date (datetime|str) – earliest possible date/time to trigger on (inclusive)</li><li>end_date (datetime|str) – latest possible date/time to trigger on (inclusive)</li><li>timezone (datetime.tzinfo|str) – time zone to use for the date/time calculations (defaults to scheduler timezone)</li></ul><p>表达式:<br><img src="\img\python_timer_expression.png" alt="python_timer_expression"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> apscheduler.schedulers.blocking <span class="keyword">import</span> BlockingScheduler</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job_function</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"Hello World"</span>)</span><br><span class="line"><span class="comment"># BlockingScheduler</span></span><br><span class="line">sched = BlockingScheduler()</span><br><span class="line"><span class="comment"># Schedules job_function to be run on the third Friday</span></span><br><span class="line"><span class="comment"># of June, July, August, November and December at 00:00, 01:00, 02:00 and 03:00</span></span><br><span class="line">sched.add_job(job_function, <span class="string">'cron'</span>, month=<span class="string">'6-8,11-12'</span>, day=<span class="string">'3rd fri'</span>, hour=<span class="string">'0-3'</span>)</span><br><span class="line"><span class="comment"># Runs from Monday to Friday at 5:30 (am) until 2014-05-30 00:00:00</span></span><br><span class="line">sched.add_job(job_function, <span class="string">'cron'</span>, day_of_week=<span class="string">'mon-fri'</span>, hour=<span class="number">5</span>, minute=<span class="number">30</span>, end_date=<span class="string">'2014-05-30'</span>)</span><br><span class="line">sched.start()</span><br></pre></td></tr></table></figure><p><a href="https://apscheduler.readthedocs.io/en/latest/modules/triggers/interval.html" target="_blank" rel="noopener">interval</a><br>参数：</p><ul><li>weeks (int) – number of weeks to wait</li><li>days (int) – number of days to wait</li><li>hours (int) – number of hours to wait</li><li>minutes (int) – number of minutes to wait</li><li>seconds (int) – number of seconds to wait</li><li>start_date (datetime|str) – starting point for the interval calculation</li><li>end_date (datetime|str) – latest possible date/time to trigger on</li><li>timezone (datetime.tzinfo|str) – time zone to use for the date/time calculations</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> apscheduler.schedulers.blocking <span class="keyword">import</span> BlockingScheduler</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job_function</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"Hello World"</span>)</span><br><span class="line"><span class="comment"># BlockingScheduler</span></span><br><span class="line">sched = BlockingScheduler()</span><br><span class="line"><span class="comment"># Schedule job_function to be called every two hours</span></span><br><span class="line">sched.add_job(job_function, <span class="string">'interval'</span>, hours=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># The same as before, but starts on 2010-10-10 at 9:30 and stops on 2014-06-15 at 11:00</span></span><br><span class="line">sched.add_job(job_function, <span class="string">'interval'</span>, hours=<span class="number">2</span>, start_date=<span class="string">'2010-10-10 09:30:00'</span>, end_date=<span class="string">'2014-06-15 11:00:00'</span>)</span><br><span class="line">sched.start()</span><br></pre></td></tr></table></figure><p><a href="https://lz5z.com/Python%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/" target="_blank" rel="noopener">参考文章</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;循环-sleep&quot;&gt;&lt;a href=&quot;#循环-sleep&quot; class=&quot;headerlink&quot; title=&quot;循环 sleep&quot;&gt;&lt;/a&gt;循环 sleep&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;这种方式最简单，只要在循环里加入需要执行的代码，然后sleep后在执
      
    
    </summary>
    
    
      <category term="python" scheme="http://gilgameshzzz.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="http://gilgameshzzz.github.io/2019/02/28/Docker/"/>
    <id>http://gilgameshzzz.github.io/2019/02/28/Docker/</id>
    <published>2019-02-27T16:00:00.000Z</published>
    <updated>2020-04-16T02:35:51.819Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p>Docker - Debian - cgroup / nameplace</p><p>RabbitMQ - 消息服务 -Ruby</p><p>ElasticSearch / Solr - 搜索引擎 - Java</p><p>虚拟机 - 屏蔽软硬件环境的差异  - VMware / virtual Box</p><p>重量级容器（占用的系统资源多）</p><p>Nginx / MySQL / Redis / RabbitMQ</p><h4 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h4><p>yum -y intsall docker-io</p><ul><li><p>启动Docker 服务</p><p>systemctl start docker</p></li><li><p>查看镜像</p><p>docker images</p><p>下载mysql5.7 镜像(安装盘)</p></li></ul><p>Docker pull mysql:5.7（镜像名：版本号）</p><h4 id="创建容器（nginx"><a href="#创建容器（nginx" class="headerlink" title="创建容器（nginx)"></a>创建容器（nginx)</h4><p>  docker run -d -p 80:80 –name  nginx(容器名字)  nginx</p><p>​    创建容器（mysql)</p><p> docker run -d -p 3306:3306 –name mysql57 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7</p><p>查看进程信息</p><p>netstat -nap | grep </p><p>查看所有容器</p><p>docker container ls -a</p><p>查看已经启动的容器</p><p>docker ps</p><p>启动/停止容器</p><p>docker start /stop 容器名</p><h4 id="Redis-基于内存的kv的数据库"><a href="#Redis-基于内存的kv的数据库" class="headerlink" title="Redis - 基于内存的kv的数据库"></a>Redis - 基于内存的kv的数据库</h4><p>Redis提供了两种持久化方法</p><p>​        RDB - 内存中的数据放入一个二进制的dump文件中</p><p>​        AOF - 用一个文件记录用户操作的命令 - 每秒记录一次用户操作</p><p>docker run -d -p  6379:6379 –name redis-master redis</p><p>redis-server –appendonly  yes  –requirepass tmz55555</p><p>docker run -d –link redis-master:redis-master –name redis-slave-1 redis:latest redis-server – slaveof redis-mater 6379 –masterauth tmz55555 </p><p>docker run -d –link redis-master:redis-master –name redis-slave-2 redis:latest redis-server – slaveof redis-mater 6379 –masterauth tmz55555 </p><p>docker run -d –link redis-master:redis-master –name redis-slave-3 redis:latest redis-server – slaveof redis-mater 6379 –masterauth tmz55555 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Docker&quot;&gt;&lt;a href=&quot;#Docker&quot; class=&quot;headerlink&quot; title=&quot;Docker&quot;&gt;&lt;/a&gt;Docker&lt;/h1&gt;&lt;p&gt;Docker - Debian - cgroup / nameplace&lt;/p&gt;
&lt;p&gt;RabbitMQ -
      
    
    </summary>
    
    
      <category term="Docker" scheme="http://gilgameshzzz.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>boolmfilter</title>
    <link href="http://gilgameshzzz.github.io/2019/02/28/bloomfilter/"/>
    <id>http://gilgameshzzz.github.io/2019/02/28/bloomfilter/</id>
    <published>2019-02-27T16:00:00.000Z</published>
    <updated>2020-04-16T02:28:02.489Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Bloom-Filter的算法"><a href="#Bloom-Filter的算法" class="headerlink" title="Bloom Filter的算法"></a>Bloom Filter的算法</h2><p>&emsp;&emsp;在Bloom Filter 中使用位数组来辅助实现检测判断。在初始状态下，我们声明一个包含m位的位数组，它的所有位都是0，如图14-7所示。<br>​                    <img src="/img/14-7.png" alt></p><p>&emsp;&emsp;现在我们有了一个待检测集合，其表示为S={x1, h ,…, Xn ｝ 。接下来需要做的就是检测一个x是否已经存在于集合S中。在Bloom Filter 算法中，首先使用k个相互独立、随机的散列函数来将集合S中的每个元素X1,X2,…Xn，映射到长度为m的位数组上，散列函数得到的结果记作位置索引，然后将位数组该位置索引的位置l 。例如，我们取k为3，表示有三个散列函数，x1经过三个散列函数映射得到的结果分别为l 、4 、8, X2 经过三个散列函数映射得到的结果分别为4 、6 、10 ，那么位数组的1、4、6、8、10。这五位就会置为1，如图14-8所示。<br>                      <img src="/img/14-8.png" alt></p><p>&emsp;&emsp;如果有一个新的元素x，我们要判断x是否属于S集合，我们仍然用k个散列函数对x求映射结果。如果所有结果对应的位数组位置均为l，那么x属于S这个集合，如果有一个不为1，则x不属于S集合。<br>&emsp;&emsp;例如，新元素x 经过三个散列函数映射的结果为4、6、8，对应的位置均为1，则x属于S集合。如果结果为4、6、7，而7对应的位置为0，则x不属于S集合。<br>&emsp;&emsp;注意，这里m、n、k满足的关系是m＞nk时，也就是说位数组的长度m要比集合元素n和散列函数k的乘积还要大。<br>&emsp;&emsp;这样的判定方法很高效，但是也是有代价的，它可能把不属于这个集合的元素误认为属于这个集合。<br>&emsp;&emsp;当k值确定时，随着m/n的增大，误判概率逐渐变小。当m/n的值确定时，当k越靠近最优K值，误判概率越小。（计算公式不展示）</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashMap</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># 实现基本的散列算法，将一个值经过散列运算后映射到一个m位数组的某一位上</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, m, seed)</span>:</span></span><br><span class="line">        self.m = m</span><br><span class="line">        self.seed = seed</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hash</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        哈希算法</span></span><br><span class="line"><span class="string">        :param value: value</span></span><br><span class="line"><span class="string">        :return: Hash value</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(value)):</span><br><span class="line">            ret += self.seed * ret + ord(value[i])</span><br><span class="line">        <span class="comment"># print((self.m - 1) &amp; ret)</span></span><br><span class="line">        <span class="keyword">return</span> (self.m - <span class="number">1</span>) &amp; ret</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;value 是要被处理的内容。这里遍历了value的每一位，并利用ord( )方法取到每一位的ASCII码值，然后混淆seed进行迭代求和运算，最终得到一个数值。这个数值的结果就由value和seed唯一确定。再将这个数值和m进行按位与运算，即可获取到m位数组的映射结果，这样就实现了一个由字符串和seed来确定的散列函数。当m固定时，只要seed值相同，散列函数就是相同的，相同value必然会映射到相同的位置。所以如果想要构造几个不同的散列函数，只需要改变其seed就好了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  seed取值范围</span></span><br><span class="line">BLOOMFILTER_HASH_NUMBER = <span class="number">6</span></span><br><span class="line"><span class="comment">#  需要的位数m</span></span><br><span class="line">BLOOMFILTER_BIT = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BloomFilter</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Bloom Filter 里面需要用到k个散列函数，这里要对这几个散列</span></span><br><span class="line"><span class="string">    函数指定相同的m值和不同的seed值</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, server)</span>:</span></span><br><span class="line">        self.block_num = <span class="number">1</span>,</span><br><span class="line">        self.key = <span class="string">'BloomFilter'</span></span><br><span class="line">        self.m = <span class="number">1</span> &lt;&lt; BLOOMFILTER_BIT</span><br><span class="line">        self.seeds = range(BLOOMFILTER_HASH_NUMBER)</span><br><span class="line">        self.server = server</span><br><span class="line">        <span class="comment">#  散列函数列表</span></span><br><span class="line">        self.maps = [HashMap(self.m, seed) <span class="keyword">for</span> seed <span class="keyword">in</span> self.seeds]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exists</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="comment"># 判断元素是否重复</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> value:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        exist = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> map <span class="keyword">in</span> self.maps:</span><br><span class="line">            offset = map.hash(value)</span><br><span class="line">            exist = exist &amp; self.server.getbit(self.key, offset)</span><br><span class="line">        <span class="keyword">return</span> exist</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> f <span class="keyword">in</span> self.maps:</span><br><span class="line">            offset = f.hash(value)</span><br><span class="line">            print(offset)</span><br><span class="line">            self.server.setbit(self.key, offset, <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;传入散列函数的个数，用它来生成几个不同的seed。用不同的seed来定义不同的散列原函数，这样我们就可以构造一个散列函数列表。遍历seed，构造带有不同seed值的HashMap对象，然后将HashMap对象保存成变量maps供后续使用。另外，server就是Redis连接对象，key就是这个m位数组的名称。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Bloom-Filter的算法&quot;&gt;&lt;a href=&quot;#Bloom-Filter的算法&quot; class=&quot;headerlink&quot; title=&quot;Bloom Filter的算法&quot;&gt;&lt;/a&gt;Bloom Filter的算法&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在Bloom
      
    
    </summary>
    
    
      <category term="布隆过滤器" scheme="http://gilgameshzzz.github.io/tags/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>装饰器、函数、一条语句实现阶乘</title>
    <link href="http://gilgameshzzz.github.io/2019/02/28/day02-%E8%A3%85%E9%A5%B0%E5%99%A8%E3%80%81%E5%87%BD%E6%95%B0%E3%80%81%E4%B8%80%E6%9D%A1%E8%AF%AD%E5%8F%A5%E5%AE%9E%E7%8E%B0%E9%98%B6%E4%B9%98/"/>
    <id>http://gilgameshzzz.github.io/2019/02/28/day02-装饰器、函数、一条语句实现阶乘/</id>
    <published>2019-02-27T16:00:00.000Z</published>
    <updated>2020-04-16T02:27:18.763Z</updated>
    
    <content type="html"><![CDATA[<p>filter –&gt;map –&gt;  reduce</p><p>过滤       映射       归约</p><p>过滤      映射     </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a =[<span class="number">12</span>, <span class="number">95</span>, <span class="number">88</span>, <span class="number">45</span>]</span><br><span class="line">sum([x**x <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">if</span> x % <span class="number">2</span>]) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn = <span class="keyword">lambda</span> x,y :x**y</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line">fn =foo</span><br></pre></td></tr></table></figure><p>在python中函数式一等对象（一定公民）</p><ol><li>函数可以赋值给变量</li><li>函数可以作为函数的参数   —&gt;fillter</li><li>函数可以作为函数的返回值 —&gt;装饰器</li></ol><p>函数参数:</p><ol><li><p>位置参数</p></li><li><p>可变参数 -tuple</p></li><li><p>关键字参数 - dict</p></li><li><p>命名关键字参数</p></li></ol><p>自定义装饰器 - 装饰函数 / 装饰类  –设计模式（代理模式）</p><p>代理模式</p><p>用代理对象（装饰器函数）去执行被代理对象（被装饰的函数）的行为</p><p>面向切面编程 —AOP</p><p>在程序中跟正常业务逻辑没有必然联系而且会重复使用的功能通常被称为横切关注功能，这种横切关注功能不应该写在业务逻辑代码是上，而应该使用装饰器或中间件来完成</p><p>指令式编程（汇编语言） /过程式语言（c语言）</p><p>Python既支持面向对象编程，也支持函数式编程</p><p>一条语句求阶乘</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn = <span class="keyword">lambda</span> n: functools.reduce(int.__mul__, range(<span class="number">1</span>,n+<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>heapq内置模块  提供基于堆的优先排序算法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line">list1[<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">63</span>,<span class="number">24</span>]</span><br><span class="line">heapq.nsmallest(list1,n)  <span class="comment">#最小的n个</span></span><br><span class="line">heapq.nlargest(list1,<span class="number">3</span>)<span class="comment">#最大的n个</span></span><br></pre></td></tr></table></figure><p>全排列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import itertools</span><br><span class="line">for val in itertools.combinations(&apos;abcde&apos;, 3):</span><br><span class="line">print (val)</span><br></pre></td></tr></table></figure><p>笛卡尔积</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for val in itertools.product(&apos;ABCD&apos;,123):</span><br><span class="line">print(val)</span><br></pre></td></tr></table></figure><p>装饰器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">record</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">@wraps(func)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line"></span><br><span class="line">ret_value = func(*args, *kwargs)</span><br><span class="line"><span class="keyword">return</span> ret_value</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><p>带参数的装饰器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps </span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">record_time</span><span class="params">(output)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(function)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 装饰器函数，计算函数执行时间</span></span><br><span class="line"><span class="meta">        @wraps(function)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">timeCount</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            timestart = time.time()</span><br><span class="line">            result = function(*args, **kwargs)</span><br><span class="line">            timesend= time.time()</span><br><span class="line">            output(function.__name__, timesend - timestart) </span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">return</span> timeCount</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_to_file</span><span class="params">(fn, duration)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'result.txt'</span>, <span class="string">'a'</span>)<span class="keyword">as</span> fs:</span><br><span class="line">        fs.write(<span class="string">'%s: %.3f秒\n'</span> %(fn,duration))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@record_time(log_to_file)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fool</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        <span class="comment"># 此处调用foo并不是真正执行分两类而是执行了wrpper</span></span><br><span class="line">        fool()</span><br><span class="line">    <span class="comment"># 取消装饰器 </span></span><br><span class="line">    foo2 = fool.__wrapped__</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        <span class="comment"># 此处调用被装饰之前写的函数</span></span><br><span class="line">        foo2()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;filter –&amp;gt;map –&amp;gt;  reduce&lt;/p&gt;
&lt;p&gt;过滤       映射       归约&lt;/p&gt;
&lt;p&gt;过滤      映射     &lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas
      
    
    </summary>
    
    
      <category term="python" scheme="http://gilgameshzzz.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python的技巧和方法</title>
    <link href="http://gilgameshzzz.github.io/2019/02/28/python%E6%8A%80%E5%B7%A7/"/>
    <id>http://gilgameshzzz.github.io/2019/02/28/python技巧/</id>
    <published>2019-02-27T16:00:00.000Z</published>
    <updated>2020-04-16T02:36:23.387Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-路径操作"><a href="#1-路径操作" class="headerlink" title="1. 路径操作"></a>1. 路径操作</h1><p>比起os模块的path方法，python3标准库的pathlib模块的Path处理起路径更加的容易。</p><p>l例如：获取当前文件路径。<br>os版：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(os.path.dirname(__file__))</span><br><span class="line">print(os.getcwd())</span><br></pre></td></tr></table></figure></p><p>pathlib版：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(pathlib.Path.cwd())</span><br></pre></td></tr></table></figure></p><p>看着好像没啥区别，然后看下面这个。</p><h2 id="获取上两级文件目录"><a href="#获取上两级文件目录" class="headerlink" title="获取上两级文件目录"></a>获取上两级文件目录</h2><p>os版：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(os.path.dirname(os.path.dirname(os.getcwd())))</span><br></pre></td></tr></table></figure></p><p>pathlib版:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(pathlib.Path.cwd().parent.parent)</span><br></pre></td></tr></table></figure></p><h2 id="拼接路径"><a href="#拼接路径" class="headerlink" title="拼接路径"></a>拼接路径</h2><p>os版:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(os.path.join(os.path.dirname(os.path.dirname(os.getcwd())),<span class="string">"yamls"</span>,<span class="string">"a.yaml"</span>))</span><br></pre></td></tr></table></figure></p><p>pathlib版:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parts=[<span class="string">"yamls"</span>,<span class="string">"a.yaml"</span>]</span><br><span class="line">print(pathlib.Path.cwd().parent.parent.joinpath(*parts))</span><br></pre></td></tr></table></figure></p><h2 id="运行时拼接路径"><a href="#运行时拼接路径" class="headerlink" title="运行时拼接路径"></a>运行时拼接路径</h2><p>os版:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), <span class="string">'yamls'</span>,<span class="string">f'<span class="subst">&#123;site_name&#125;</span>.yaml'</span>)</span><br></pre></td></tr></table></figure></p><p>pathlib版:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parts=[<span class="string">"yamls"</span>,<span class="string">"a.yaml"</span>]</span><br><span class="line">print(pathlib.Path(__file__).resolve().parent.parent.joinpath(*parts))</span><br></pre></td></tr></table></figure></p><p>另外pathlib生成的是个对象，在open文件操作中可以直接运行的但是如果当作字符串操作会出现错误，此时需要对其进行转换，使用os.fspath()即可，不过一般很少有操作路径字符串的习惯。<br>综合起来，还是pathlib拼接路径方便。</p><h1 id="2-保存标准格式的yaml文件"><a href="#2-保存标准格式的yaml文件" class="headerlink" title="2. 保存标准格式的yaml文件"></a>2. 保存标准格式的yaml文件</h1><p>编程免不了要写配置文件，怎么写配置也是一门学问。<br>YAML 是专门用来写配置文件的语言，非常简洁和强大，远比 JSON 格式方便。<br>YAML在python语言中有PyYAML安装包。<br>前提安装第三方库<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install pyaml</span><br><span class="line">pip install ruamel.yaml</span><br></pre></td></tr></table></figure></p><p>关于yaml的读取知识网上一堆了我就不说了，这里主要说写入。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ruamel <span class="keyword">import</span> yaml</span><br><span class="line">data=&#123;<span class="string">"age"</span>:<span class="number">23</span>,<span class="string">"sex"</span>:<span class="string">"男"</span>,<span class="string">"name"</span>:<span class="string">"牛皮"</span>&#125;</span><br><span class="line"><span class="keyword">with</span> open(conf_file, <span class="string">"w"</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> fs:</span><br><span class="line">    yaml.dump(data, fs, Dumper=yaml.RoundTripDumper, allow_unicode=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure></p><p>yaml写文件和json一样也是使用dump。</p><h1 id="3-同时迭代两个列表"><a href="#3-同时迭代两个列表" class="headerlink" title="3. 同时迭代两个列表"></a>3. 同时迭代两个列表</h1><p>以前的时候我是这么解决的<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>]</span><br><span class="line">b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]  <span class="comment"># 空的补充None</span></span><br><span class="line"><span class="keyword">for</span> index, a_item <span class="keyword">in</span> enumerate(a):</span><br><span class="line">    b_item = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">if</span> len(b) - <span class="number">1</span> &lt;= index:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        b_item = b[index]</span><br><span class="line">    print(&#123;a_item:b_item&#125;)</span><br></pre></td></tr></table></figure></p><p>现在通过itertools标准库的zip升级版zip_longest解决，可以通过fillvalue参数补充缺失值。当然如果比较的元素个数相同可以直接用zip。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> zip_longest</span><br><span class="line"></span><br><span class="line">a = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>,<span class="string">"e"</span>]</span><br><span class="line">b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]  <span class="comment"># 空的补充None</span></span><br><span class="line"><span class="keyword">for</span> a_item, b_item <span class="keyword">in</span> zip_longest(a,b,fillvalue=<span class="number">0</span>):</span><br><span class="line">    print(&#123;a_item:b_item&#125;)</span><br></pre></td></tr></table></figure></p><h1 id="4-三元表达式还能这么用？"><a href="#4-三元表达式还能这么用？" class="headerlink" title="4. 三元表达式还能这么用？"></a>4. 三元表达式还能这么用？</h1><p>一般的我们这样写<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="string">"hello"</span> <span class="keyword">if</span> <span class="number">2</span>&gt;<span class="number">1</span> <span class="keyword">else</span> <span class="string">"bye"</span></span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure></p><p>我们知道python中false实际式0，true是1，所以对于上面的式子我们就可以这么写了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="string">"hello"</span>,<span class="string">"bye"</span>][<span class="number">2</span>&lt;<span class="number">1</span>]</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure></p><p>因为2&lt;1是false也就是0，所以输出了第一个元素hello。</p><h1 id="5-简单的类使用namedtuple代替"><a href="#5-简单的类使用namedtuple代替" class="headerlink" title="5.简单的类使用namedtuple代替"></a>5.简单的类使用namedtuple代替</h1><p>先来一个简单的例子<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="comment"># Person=collections.namedtuple('Person','name age')</span></span><br><span class="line"><span class="comment"># 如果使用python中的关键字会出现错误,此时使用rename字段。</span></span><br><span class="line"><span class="comment"># 按照元素在元组中的下标赋值。class就是_2,def是_3</span></span><br><span class="line">Person = collections.namedtuple(<span class="string">'Person'</span>, [<span class="string">'name'</span>, <span class="string">'age'</span>, <span class="string">'class'</span>, <span class="string">'def'</span>, <span class="string">'name'</span>, <span class="string">'name'</span>], rename=<span class="keyword">True</span>)</span><br><span class="line">p = Person(name=<span class="string">'lisa'</span>, age=<span class="string">'12'</span>, _2=<span class="string">"class2"</span>, _3=<span class="string">"def"</span>, _4=<span class="string">"name2"</span>, _5=<span class="string">"name3"</span>)</span><br><span class="line">print(p)</span><br><span class="line"><span class="comment"># 如果出现相同的字段第二次出现的时候也是用其下标，参考上面的例子。</span></span><br><span class="line"><span class="comment"># _fields查看字段名,可以发现内置模块和重复的字段标记为_加下标的形式</span></span><br><span class="line">print(p._fields)</span><br><span class="line"><span class="comment"># 使用_asdict将namedtuple转为OrderedDict。</span></span><br><span class="line">od = p._asdict()</span><br><span class="line">print(od)</span><br><span class="line"><span class="comment"># 然后可以转为字典</span></span><br><span class="line">print(dict(od))</span><br><span class="line"><span class="comment"># _replace()方法构建一个新实例，因为namedtuple是不可变类型所以这个方法可以返回一个新的对象。</span></span><br><span class="line">new_p = p._replace(name=<span class="string">"samJ"</span>)</span><br><span class="line">print(new_p)</span><br><span class="line">print(new_p <span class="keyword">is</span> p)  <span class="comment"># 可以看到不是同一个对象。</span></span><br></pre></td></tr></table></figure></p><p>一个实用的例子pyppeteer的例子感受下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> pyppeteer</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Response = namedtuple(<span class="string">"rs"</span>, <span class="string">"title url html cookies headers history status"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(url, timeout=<span class="number">30</span>)</span>:</span></span><br><span class="line">    <span class="comment"># 默认30s</span></span><br><span class="line">    browser = <span class="keyword">await</span> pyppeteer.launch(headless=<span class="keyword">True</span>, args=[<span class="string">'--no-sandbox'</span>])</span><br><span class="line">    page = <span class="keyword">await</span>  browser.newPage()</span><br><span class="line">    res = <span class="keyword">await</span> page.goto(url, options=&#123;<span class="string">'timeout'</span>: int(timeout * <span class="number">1000</span>)&#125;)</span><br><span class="line">    data = <span class="keyword">await</span> page.content()</span><br><span class="line">    title = <span class="keyword">await</span> page.title()</span><br><span class="line">    resp_cookies = <span class="keyword">await</span> page.cookies()</span><br><span class="line">    resp_headers = res.headers</span><br><span class="line">    resp_history = <span class="keyword">None</span></span><br><span class="line">    resp_status = res.status</span><br><span class="line">    response = Response(title=title, url=url,</span><br><span class="line">                        html=data,</span><br><span class="line">                        cookies=resp_cookies,</span><br><span class="line">                        headers=resp_headers,</span><br><span class="line">                        history=resp_history,</span><br><span class="line">                        status=resp_status)</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    url_list = [<span class="string">"http://www.10086.cn/index/tj/index_220_220.html"</span>, <span class="string">"http://www.10010.com/net5/011/"</span>,</span><br><span class="line">                <span class="string">"http://python.jobbole.com/87541/"</span>]</span><br><span class="line">    task = (get_html(url) <span class="keyword">for</span> url <span class="keyword">in</span> url_list)</span><br><span class="line"></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    results = loop.run_until_complete(asyncio.gather(*task))</span><br><span class="line">    <span class="keyword">for</span> res <span class="keyword">in</span> results:</span><br><span class="line">        print(res.title)</span><br></pre></td></tr></table></figure></p><h1 id="6-使用枚举让数字变得更易懂。"><a href="#6-使用枚举让数字变得更易懂。" class="headerlink" title="6 使用枚举让数字变得更易懂。"></a>6 使用枚举让数字变得更易懂。</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> enum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 枚举</span></span><br><span class="line"><span class="meta">@enum.unique</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sex</span><span class="params">(enum.Enum)</span>:</span></span><br><span class="line">    man = <span class="number">12</span></span><br><span class="line">    woman = <span class="number">13</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 因为加了唯一值的装饰器所以下面添加属性会报错</span></span><br><span class="line">    <span class="comment"># boy=12</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(Sex.man.name)</span><br><span class="line">print(Sex.woman.value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> Sex:</span><br><span class="line">    print(item.name)</span><br><span class="line">    print(item.value)</span><br><span class="line">print(<span class="string">"-"</span> * <span class="number">40</span>)</span><br><span class="line"><span class="comment"># 其他使用方式</span></span><br><span class="line">words = enum.Enum(</span><br><span class="line">    value=<span class="string">'item'</span>,</span><br><span class="line">    names=(<span class="string">'a b c d e f'</span>),</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 输出元素c，必须是上面names里含有的值</span></span><br><span class="line">print(words.c)</span><br><span class="line">print(words.f)</span><br><span class="line"><span class="comment"># 因为names不含有w所以报错</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(words.w)</span><br><span class="line"><span class="keyword">except</span> AttributeError <span class="keyword">as</span> e:</span><br><span class="line">    print(e.args)</span><br><span class="line">print(<span class="string">"-"</span> * <span class="number">40</span>)</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    print(word.name, word.value)  <span class="comment"># 默认赋值为、从1开始自增。</span></span><br><span class="line">print(<span class="string">"-"</span> * <span class="number">40</span>)</span><br><span class="line"><span class="comment"># 如果自定义元素的值啧改为一下元组的形式</span></span><br><span class="line">words2 = enum.Enum(</span><br><span class="line">    value=<span class="string">'item2'</span>,</span><br><span class="line">    names=[(<span class="string">'a'</span>, <span class="number">23</span>), (<span class="string">'b'</span>, <span class="number">56</span>), (<span class="string">"c"</span>, <span class="number">12</span>), (<span class="string">"d"</span>, <span class="number">333</span>)]</span><br><span class="line">)</span><br><span class="line"><span class="keyword">for</span> word2 <span class="keyword">in</span> words2:</span><br><span class="line">    print(word2.name, word2.value)</span><br></pre></td></tr></table></figure><h1 id="7-链式合并字典chainmap的使用"><a href="#7-链式合并字典chainmap的使用" class="headerlink" title="7 链式合并字典chainmap的使用"></a>7 链式合并字典chainmap的使用</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> ChainMap</span><br><span class="line"></span><br><span class="line"><span class="comment"># ChainMap</span></span><br><span class="line"></span><br><span class="line">d1 = &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;</span><br><span class="line">d2 = &#123;<span class="string">'a2'</span>: <span class="number">3</span>, <span class="string">'b2'</span>: <span class="number">4</span>&#125;</span><br><span class="line">d3 = &#123;<span class="string">'a3'</span>: <span class="number">5</span>, <span class="string">'b3'</span>: <span class="number">6</span>&#125;</span><br><span class="line">d4 = &#123;<span class="string">'a4'</span>: <span class="number">7</span>, <span class="string">'b4'</span>: <span class="number">8</span>&#125;</span><br><span class="line">c = ChainMap(d1, d2, d3, d4)  <span class="comment"># 多个字典合并为一个</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> c.items():</span><br><span class="line">    print(k, v)</span><br><span class="line">print(c.maps)  <span class="comment"># 要搜索的索引列表</span></span><br><span class="line"></span><br><span class="line">c.maps = list(reversed(c.maps))  <span class="comment"># 逆转映射列表</span></span><br><span class="line">print(c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为c和d1-d4对应的索引位置实际是一个所以，修改c的时候会影响到d1到d4其中饿的一个值，同理修改</span></span><br><span class="line"><span class="comment"># d1-d4的时候也会影响到c。</span></span><br><span class="line"><span class="comment"># 所以使用new_child创建一个新的映射。再修改就影响不到底层的数据了。</span></span><br><span class="line">c2 = c.new_child()</span><br><span class="line">c2[<span class="string">"a4"</span>] = <span class="number">100</span></span><br><span class="line">print(c)</span><br><span class="line">print(c2)</span><br><span class="line"><span class="comment"># 输出发现c的值没有发生变化，只要c2变化。</span></span><br><span class="line">d5 = &#123;<span class="string">"a5"</span>: <span class="number">34</span>, <span class="string">"b5"</span>: <span class="number">78</span>&#125;</span><br><span class="line">c2 = c2.new_child(d5)  <span class="comment"># 可以在原来的映射基础上添加新的映射</span></span><br><span class="line">print(c2)</span><br></pre></td></tr></table></figure><h1 id="8-在不打乱列表顺序的基础上插入元素"><a href="#8-在不打乱列表顺序的基础上插入元素" class="headerlink" title="8 在不打乱列表顺序的基础上插入元素"></a>8 在不打乱列表顺序的基础上插入元素</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">bisect 模块，用于维护有序列表。</span></span><br><span class="line"><span class="string">bisect 模块实现了一个算法用于插入元素到有序列表。</span></span><br><span class="line"><span class="string">在一些情况下，这比反复排序列表或构造一个大的列表再排序的效率更高。</span></span><br><span class="line"><span class="string">Bisect 是二分法的意思，这里使用二分法来排序，它会将一个元素插入到一个有序列表的合适位置，</span></span><br><span class="line"><span class="string">这使得不需要每次调用 sort 的方式维护有序列表。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">values = [<span class="number">14</span>, <span class="number">85</span>, <span class="number">77</span>, <span class="number">26</span>, <span class="number">50</span>, <span class="number">45</span>, <span class="number">66</span>, <span class="number">79</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">84</span>, <span class="number">77</span>, <span class="number">1</span>]</span><br><span class="line">print(<span class="string">"New Pos Content"</span>)</span><br><span class="line">print(<span class="string">"--- --- -------"</span>)</span><br><span class="line">l = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> values:</span><br><span class="line">    postion = bisect.bisect(l, i)  <span class="comment"># 返回插入的位置</span></span><br><span class="line">    bisect.insort(l, i)  <span class="comment"># 等于insort_right</span></span><br><span class="line">    print(<span class="string">'&#123;:3&#125;&#123;:3&#125;'</span>.format(i, postion), l)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Bisect模块提供的函数有：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">bisect.bisect_left(a,x, lo=0, hi=len(a)) :</span></span><br><span class="line"><span class="string">查找在有序列表 a 中插入 x 的index。lo 和 hi 用于指定列表的区间，默认是使用整个列表。如果 x 已经存在，在其左边插入。返回值为 index。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">bisect.bisect_right(a,x, lo=0, hi=len(a))</span></span><br><span class="line"><span class="string">bisect.bisect(a, x,lo=0, hi=len(a)) ：</span></span><br><span class="line"><span class="string">这2个函数和 bisect_left 类似，但如果 x 已经存在，在其右边插入。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">bisect.insort_left(a,x, lo=0, hi=len(a)) ：</span></span><br><span class="line"><span class="string">在有序列表 a 中插入 x。和 a.insert(bisect.bisect_left(a,x, lo, hi), x) 的效果相同。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">bisect.insort_right(a,x, lo=0, hi=len(a))</span></span><br><span class="line"><span class="string">bisect.insort(a, x,lo=0, hi=len(a)) :</span></span><br><span class="line"><span class="string">和 insort_left 类似，但如果 x 已经存在，在其右边插入。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Bisect 模块提供的函数可以分两类： bisect* 只用于查找 index， 不进行实际的插入；</span></span><br><span class="line"><span class="string">而 insort* 则用于实际插入。该模块比较典型的应用是计算分数等级：</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h1 id="9-关于字典的逻辑运算你了解多少"><a href="#9-关于字典的逻辑运算你了解多少" class="headerlink" title="9 关于字典的逻辑运算你了解多少"></a>9 关于字典的逻辑运算你了解多少</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用&amp;操作符查看字典的相同之处</span></span><br><span class="line"><span class="comment">#字典键支持常见的集合操作，并集交集差集。</span></span><br><span class="line">a = &#123;<span class="string">'x'</span>: <span class="number">1</span>, <span class="string">'y'</span>: <span class="number">2</span>, <span class="string">'z'</span>: <span class="number">3</span>&#125;</span><br><span class="line">b = &#123;<span class="string">'w'</span>: <span class="number">2</span>, <span class="string">'z'</span>: <span class="number">4</span>, <span class="string">'x'</span>: <span class="number">3</span>, <span class="string">'z'</span>: <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取相同的键</span></span><br><span class="line">c = a.keys() &amp; b.keys()</span><br><span class="line">print(c)</span><br><span class="line"><span class="comment"># 获取相同的键值对</span></span><br><span class="line">d = a.items() &amp; b.items()</span><br><span class="line">print(d)</span><br><span class="line"><span class="comment"># 创建一个新的字典并删除某些键</span></span><br><span class="line"></span><br><span class="line">e = &#123;k: a[k] <span class="keyword">for</span> k <span class="keyword">in</span> a.keys() - &#123;<span class="string">'z'</span>, <span class="string">'x'</span>&#125;&#125;</span><br><span class="line">print(e)</span><br></pre></td></tr></table></figure><h1 id="10-给切片起个名字"><a href="#10-给切片起个名字" class="headerlink" title="10 给切片起个名字"></a>10 给切片起个名字</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="string">"safr3.14"</span></span><br><span class="line">print(a[<span class="number">-4</span>:])</span><br><span class="line"><span class="comment">#上面可以改为</span></span><br><span class="line">pie=slice(len(a)<span class="number">-4</span>,len(a))</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><h1 id="11-获取出现频率高的元素"><a href="#11-获取出现频率高的元素" class="headerlink" title="11 获取出现频率高的元素"></a>11 获取出现频率高的元素</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">text = <span class="string">"abcdfegtehto;grgtgjri"</span>  <span class="comment"># 可迭代对象</span></span><br><span class="line">lis = [<span class="string">"a"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"t"</span>, <span class="string">"b"</span>]</span><br><span class="line">dic = &#123;<span class="string">"a"</span>: <span class="number">1</span>, <span class="string">"b"</span>: <span class="number">4</span>, <span class="string">"c"</span>: <span class="number">2</span>, <span class="string">"d"</span>: <span class="number">9</span>&#125;  <span class="comment"># 字典也可以</span></span><br><span class="line">c = Counter()  <span class="comment"># 可以定义空容器然后update</span></span><br><span class="line">c.update(text)</span><br><span class="line">c2 = Counter()</span><br><span class="line">c2.update(dic)</span><br><span class="line"></span><br><span class="line">c3 = Counter(lis)  <span class="comment"># 也可以直接传入对象</span></span><br><span class="line">print(c)</span><br><span class="line">print(c2)</span><br><span class="line">print(c3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用c.most_comman(n)获取前n出现频率最高的元素,列表元组类型</span></span><br><span class="line">print(c.most_common(<span class="number">4</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-路径操作&quot;&gt;&lt;a href=&quot;#1-路径操作&quot; class=&quot;headerlink&quot; title=&quot;1. 路径操作&quot;&gt;&lt;/a&gt;1. 路径操作&lt;/h1&gt;&lt;p&gt;比起os模块的path方法，python3标准库的pathlib模块的Path处理起路径更加的容易。&lt;/
      
    
    </summary>
    
    
      <category term="python" scheme="http://gilgameshzzz.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>redis订阅python代码</title>
    <link href="http://gilgameshzzz.github.io/2019/02/28/redis%E8%AE%A2%E9%98%85python%E4%BB%A3%E7%A0%81/"/>
    <id>http://gilgameshzzz.github.io/2019/02/28/redis订阅python代码/</id>
    <published>2019-02-27T16:00:00.000Z</published>
    <updated>2020-04-16T02:31:17.785Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Listener</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    监听器，用于监听Redis订阅的data</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># self.r = redis.Redis(host='139.198.4.56', port='6379')</span></span><br><span class="line">        <span class="comment"># redis_client为redis连接设置</span></span><br><span class="line">        self.redis_client = redis_client</span><br><span class="line">        self.crawl_seeds = self.redis_client.pubsub()</span><br><span class="line">        self.crawl_seeds.subscribe(<span class="string">'content'</span>)</span><br><span class="line">        logging.info(<span class="string">"连接到Redis..."</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">listen</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> self.crawl_seeds.listen():</span><br><span class="line">            <span class="keyword">if</span> item[<span class="string">'type'</span>] != <span class="string">'message'</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            meta = str(item[<span class="string">'data'</span>], encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">            logging.info(<span class="string">'收:%s '</span> % json.loads(meta).get(<span class="string">'content'</span>, <span class="string">''</span>).strip())</span><br></pre></td></tr></table></figure><p>用日志打印接受结果</p><p>Redis不是专门做消息队列的，建议使用RabbitMQ、Kafka</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas
      
    
    </summary>
    
    
      <category term="Redis" scheme="http://gilgameshzzz.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>哈希算法-加密-编码</title>
    <link href="http://gilgameshzzz.github.io/2019/02/28/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%20-%20%E5%8A%A0%E5%AF%86%20-%20%E7%BC%96%E7%A0%81/"/>
    <id>http://gilgameshzzz.github.io/2019/02/28/哈希算法 - 加密 - 编码/</id>
    <published>2019-02-27T16:00:00.000Z</published>
    <updated>2020-04-19T15:03:07.397Z</updated>
    
    <content type="html"><![CDATA[<h1 id="哈希算法-加密-编码"><a href="#哈希算法-加密-编码" class="headerlink" title="哈希算法 - 加密 - 编码"></a>哈希算法 - 加密 - 编码</h1><p>哈希算法 - 哈希摘要 - 数字签名 - 防篡改/保护敏感信息<br>哈希算法是一个单向运算的函数（单向哈希函数）<br>通过哈希算法可以将对象计算出哈希摘要但是哈希摘要无法还原成原来的对</p><p>Martin flower -代码有很多味道重复是最坏的一种<br>重构(refactor)</p><p>策略模式<br>加密解密 - 明文 —- 加密 —–&gt; 密文 —- 解密 —–&gt; 明文<br>对称加密 - 加密和解密使用同一个密钥 - AES<br>非对称加密 - 加密和解密使用不同的密钥（公钥和私钥）- RSA<br>pip install pycrypto</p><p>编码和解码 - 将内存中的二进制数据处理成其他的格式 - BASE64<br>BASE64 - 用64个字符(a-zA-Z0-9/+)表二进制数据示所有的</p><p>编码黑洞</p><p>中文/日文 –&gt;iso -8859 -1 Latin –&gt; ??</p><p>乱码 –&gt;编码和解码的时候没用使用相同的字符集</p><p>utf-8 -Unicode的一种变长实现方案</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StreamHasher</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""docstring for streamHasher"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, algorithm=<span class="string">'md5'</span>, size=<span class="number">4096</span>)</span>:</span></span><br><span class="line">        self.size = size</span><br><span class="line">        alg = algorithm.lower()</span><br><span class="line">        <span class="keyword">if</span> alg ==<span class="string">'md5'</span>:</span><br><span class="line">            self.hasher = hashlib.md5()</span><br><span class="line">        <span class="keyword">elif</span> alg == <span class="string">'sha1'</span>:</span><br><span class="line">            self.hasher = hashlib.sha1()</span><br><span class="line">        <span class="keyword">elif</span> alg == <span class="string">'sha256'</span>:</span><br><span class="line">            self.hasher = hashlib.sha256()</span><br><span class="line">        <span class="keyword">elif</span> alg == sha512:</span><br><span class="line">            self.hasher = hashlib.sha512()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'不支持指定的哈希算法'</span>)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># __call__ -魔术方法，调用对象的时候调用该方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self,stream)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.to_digest(stream)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_digest</span><span class="params">(self, stream)</span>:</span></span><br><span class="line">        <span class="string">'''生成MD5摘要'''</span></span><br><span class="line">        <span class="comment"># b" 终止符，读文本文件终止符 ''</span></span><br><span class="line">        hasher = self.hasher</span><br><span class="line">        <span class="keyword">for</span> buf <span class="keyword">in</span> iter(<span class="keyword">lambda</span>:stream.read(self.size), <span class="string">b''</span>):</span><br><span class="line">            hasher.update(b)</span><br><span class="line">            <span class="comment"># 16进制的md摘要</span></span><br><span class="line">        <span class="keyword">return</span> hasher.hexdigest()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_sha256_digest</span><span class="params">(stream, block_size = <span class="number">4096</span>)</span>:</span></span><br><span class="line">    <span class="string">'''生成MD5摘要'''</span></span><br><span class="line">    <span class="comment"># b" 终止符，读文本文件终止符 ''</span></span><br><span class="line">    hasher = hashlib.sha256()</span><br><span class="line">    <span class="keyword">for</span> buf <span class="keyword">in</span> iter(<span class="keyword">lambda</span>:stream.read(<span class="number">4096</span>), <span class="string">b''</span>):</span><br><span class="line">        hasher.update(b)</span><br><span class="line">        <span class="comment"># 16进制的md摘要</span></span><br><span class="line">    <span class="keyword">return</span> hasher.hexdigest()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    hasher = hashlib.md5()</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'aaa.png'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f:     </span><br><span class="line">        sh = StreamHasher()</span><br><span class="line">        print(sh.to_digest(f))</span><br><span class="line">                </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;哈希算法-加密-编码&quot;&gt;&lt;a href=&quot;#哈希算法-加密-编码&quot; class=&quot;headerlink&quot; title=&quot;哈希算法 - 加密 - 编码&quot;&gt;&lt;/a&gt;哈希算法 - 加密 - 编码&lt;/h1&gt;&lt;p&gt;哈希算法 - 哈希摘要 - 数字签名 - 防篡改/保护敏感信
      
    
    </summary>
    
    
      <category term="python" scheme="http://gilgameshzzz.github.io/tags/python/"/>
    
      <category term="hash" scheme="http://gilgameshzzz.github.io/tags/hash/"/>
    
  </entry>
  
  <entry>
    <title>多并发编程-多线程</title>
    <link href="http://gilgameshzzz.github.io/2019/02/28/%E5%A4%9A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://gilgameshzzz.github.io/2019/02/28/多并发编程-多线程/</id>
    <published>2019-02-27T16:00:00.000Z</published>
    <updated>2020-04-22T04:54:07.199Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多并发编程-多线程"><a href="#多并发编程-多线程" class="headerlink" title="多并发编程-多线程"></a>多并发编程-多线程</h1><h4 id="守护线程-守护进程-daemon"><a href="#守护线程-守护进程-daemon" class="headerlink" title="守护线程/守护进程 - daemon"></a>守护线程/守护进程 - daemon</h4><p>如果主线程结束了守护线程也不再保留即使守护线程还在执行（没有结束）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_message</span><span class="params">(content)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        print(content, end=<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    threading.Thread(</span><br><span class="line">        target=show_message, args=(<span class="string">'Ping'</span>, ), daemon=<span class="keyword">True</span></span><br><span class="line">    ).start()</span><br><span class="line">    threading.Thread(</span><br><span class="line">        target=show_message, args=(<span class="string">'Pong'</span>, ), daemon=<span class="keyword">True</span></span><br><span class="line">    ).start()</span><br><span class="line">    sleep(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p><strong>Lock</strong> - 多个线程竞争临界资源（资源只有1个） - 获得锁才能操作资源</p><p><strong>Condition </strong>-  基于Lock对象可以创建它 - wait() / notify_all()</p><p><strong>实现线程调度</strong></p><p>Semaphore - 多个线程竞争资源（资源有多个，但线程数量大于资源数量）</p><ul><li>多个线程通信比较简单因为可以共享内存</li></ul><ul><li>多个进程通信相对比较困难，可以使用multiprocessing.Queue，通过多个进程共享一个队列来实现进程间的通信</li></ul><p>生产者消费者模型 / 哲学家进餐模型 - 多线程编程模型</p><h4 id="三种方式实现多线程"><a href="#三种方式实现多线程" class="headerlink" title="三种方式实现多线程"></a>三种方式实现多线程</h4><p>多线程程序如果没有竞争资源的场景那么通常会比较简单</p><p>临界资源 - 被多个线程竞争的资源</p><p>当多个线程竞争临界资源的时候如果缺乏必要的保护措施就会导致数据错乱</p><h5 id="1-定义线程类"><a href="#1-定义线程类" class="headerlink" title="1.  定义线程类"></a>1.  定义线程类</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""银行账户"""</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.balance = <span class="number">0.0</span></span><br><span class="line">        self.lock = threading.Lock()</span><br><span class="line">     </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">deposit</span><span class="params">(self, money)</span>:</span></span><br><span class="line">        <span class="comment"># 通过锁保护临界资源</span></span><br><span class="line">        <span class="comment"># 可以写try-finally也可以使用上下文语法</span></span><br><span class="line">        <span class="comment"># self.lock.acquire()</span></span><br><span class="line">        <span class="comment"># try:</span></span><br><span class="line">        <span class="comment">#     pass</span></span><br><span class="line">        <span class="comment"># finally:</span></span><br><span class="line">        <span class="comment">#     self.lock.release()</span></span><br><span class="line">        <span class="keyword">with</span> self.lock:</span><br><span class="line">            new_balance = self.balance + money</span><br><span class="line">            time.sleep(<span class="number">0.001</span>)</span><br><span class="line">            self.balance = new_balance         </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddMoneyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, account, money)</span>:</span></span><br><span class="line">        self.account = account</span><br><span class="line">        self.money = money</span><br><span class="line">        <span class="comment"># 自定义线程的初始化方法中必须调用父类的初始化方法</span></span><br><span class="line">        super().__init__()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># run方法是线程启动之后要执行的回调方法（钩子函数）</span></span><br><span class="line">    <span class="comment"># 所以启动线程不能够直接调用run方法而是通过start方法启动线程</span></span><br><span class="line">    <span class="comment"># 什么时候需要使用回调式编程？</span></span><br><span class="line">    <span class="comment"># 你知道要做什么但不知道什么时候会做这件事情</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 线程启动之后要执行的操作</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line"> a1 = Account()</span><br><span class="line">    threads=[]</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        <span class="comment"># time.sleep(0.1)</span></span><br><span class="line">        t = AddMoneyThread(a1,<span class="number">1</span>)</span><br><span class="line">        threads.append(t)</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">    <span class="comment">#等待线程执行完</span></span><br><span class="line">        t.join()</span><br><span class="line"></span><br><span class="line">    print(a1.balance)</span><br></pre></td></tr></table></figure><h5 id="2-直接通过threading-Thread"><a href="#2-直接通过threading-Thread" class="headerlink" title="2. 直接通过threading.Thread"></a>2. 直接通过threading.Thread</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">threads = []</span><br><span class="line">account = Acount()</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">t = threading.Thread(target=add_money, args=(account, <span class="number">1</span>))</span><br><span class="line">threads.append(t)</span><br><span class="line">t.start()</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">t.join()</span><br><span class="line">print(account.banlnce)</span><br></pre></td></tr></table></figure><h5 id="3-调用线程池中的线程执行特定任务"><a href="#3-调用线程池中的线程执行特定任务" class="headerlink" title="3.调用线程池中的线程执行特定任务"></a>3.调用线程池中的线程执行特定任务</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建线程池</span></span><br><span class="line">pool = ThreadpoolExcutor(max_workers=<span class="number">10</span>)</span><br><span class="line">futures = []</span><br><span class="line"><span class="comment"># 调用线程池中的线程来执行特定的任务</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">future = pool.submit(add_money,account,<span class="number">1</span>)</span><br><span class="line">futures.append(future)</span><br><span class="line">pool.shoutdown()</span><br><span class="line"><span class="keyword">for</span> future <span class="keyword">in</span> futures:</span><br><span class="line">future.result()</span><br><span class="line">print(account.banlance)</span><br><span class="line"></span><br><span class="line"><span class="comment">#也可以用上下文方法</span></span><br><span class="line">futures = []</span><br><span class="line"><span class="keyword">with</span> ThreadpoolExcutor(max_workers=<span class="number">10</span>) <span class="keyword">as</span> pool:</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">      futures.append(pool.submit(add_money,account,<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> futures:</span><br><span class="line">        <span class="comment"># 获取函数add_money的返回值</span></span><br><span class="line">        future.result()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;多并发编程-多线程&quot;&gt;&lt;a href=&quot;#多并发编程-多线程&quot; class=&quot;headerlink&quot; title=&quot;多并发编程-多线程&quot;&gt;&lt;/a&gt;多并发编程-多线程&lt;/h1&gt;&lt;h4 id=&quot;守护线程-守护进程-daemon&quot;&gt;&lt;a href=&quot;#守护线程-守护进程
      
    
    </summary>
    
    
      <category term="python" scheme="http://gilgameshzzz.github.io/tags/python/"/>
    
      <category term="并发" scheme="http://gilgameshzzz.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
</feed>
