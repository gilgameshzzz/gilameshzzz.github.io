<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gilgameshzzz.github.io/"/>
  <updated>2019-02-26T07:07:38.735Z</updated>
  <id>http://gilgameshzzz.github.io/</id>
  
  <author>
    <name>Amadeus</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>redis订阅python代码</title>
    <link href="http://gilgameshzzz.github.io/2019/02/28/redis%E8%AE%A2%E9%98%85python%E4%BB%A3%E7%A0%81/"/>
    <id>http://gilgameshzzz.github.io/2019/02/28/redis订阅python代码/</id>
    <published>2019-02-28T09:34:07.677Z</published>
    <updated>2019-02-26T07:07:38.735Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Listener</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    监听器，用于监听Redis订阅的data</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># self.r = redis.Redis(host='139.198.4.56', port='6379')</span></span><br><span class="line">        <span class="comment"># redis_client为redis连接设置</span></span><br><span class="line">        self.redis_client = redis_client</span><br><span class="line">        self.crawl_seeds = self.redis_client.pubsub()</span><br><span class="line">        self.crawl_seeds.subscribe(<span class="string">'content'</span>)</span><br><span class="line">        logging.info(<span class="string">"连接到Redis..."</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">listen</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> self.crawl_seeds.listen():</span><br><span class="line">            <span class="keyword">if</span> item[<span class="string">'type'</span>] != <span class="string">'message'</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            meta = str(item[<span class="string">'data'</span>], encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">            logging.info(<span class="string">'收:%s '</span> % json.loads(meta).get(<span class="string">'content'</span>, <span class="string">''</span>).strip())</span><br></pre></td></tr></table></figure><p>用日志打印接受结果</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>boolmfilter</title>
    <link href="http://gilgameshzzz.github.io/2019/02/28/bloomfilter/"/>
    <id>http://gilgameshzzz.github.io/2019/02/28/bloomfilter/</id>
    <published>2019-02-28T09:34:07.600Z</published>
    <updated>2019-03-01T03:09:10.254Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Bloom-Filter的算法"><a href="#Bloom-Filter的算法" class="headerlink" title="Bloom Filter的算法"></a>Bloom Filter的算法</h2><p>&emsp;&emsp;在Bloom Filter 中使用位数组来辅助实现检测判断。在初始状态下，我们声明一个包含m位的位数组，它的所有位都是0，如图14-7所示。<br>​                    <img src="/img/14-7.png" alt=""></p><p>&emsp;&emsp;现在我们有了一个待检测集合，其表示为S={x1, h ,…, Xn ｝ 。接下来需要做的就是检测一个x是否已经存在于集合S中。在Bloom Filter 算法中，首先使用k个相互独立、随机的散列函数来将集合S中的每个元素X1,X2,…Xn，映射到长度为m的位数组上，散列函数得到的结果记作位置索引，然后将位数组该位置索引的位置l 。例如，我们取k为3，表示有三个散列函数，x1经过三个散列函数映射得到的结果分别为l 、4 、8, X2 经过三个散列函数映射得到的结果分别为4 、6 、10 ，那么位数组的1、4、6、8、10。这五位就会置为1，如图14-8所示。<br>                      <img src="/img/14-8.png" alt=""></p><p>&emsp;&emsp;如果有一个新的元素x，我们要判断x是否属于S集合，我们仍然用k个散列函数对x求映射结果。如果所有结果对应的位数组位置均为l，那么x属于S这个集合，如果有一个不为1，则x不属于S集合。<br>&emsp;&emsp;例如，新元素x 经过三个散列函数映射的结果为4、6、8，对应的位置均为1，则x属于S集合。如果结果为4、6、7，而7对应的位置为0，则x不属于S集合。<br>&emsp;&emsp;注意，这里m、n、k满足的关系是m＞nk时，也就是说位数组的长度m要比集合元素n和散列函数k的乘积还要大。<br>&emsp;&emsp;这样的判定方法很高效，但是也是有代价的，它可能把不属于这个集合的元素误认为属于这个集合。<br>&emsp;&emsp;当k值确定时，随着m/n的增大，误判概率逐渐变小。当m/n的值确定时，当k越靠近最优K值，误判概率越小。（计算公式不展示）</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashMap</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># 实现基本的散列算法，将一个值经过散列运算后映射到一个m位数组的某一位上</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, m, seed)</span>:</span></span><br><span class="line">        self.m = m</span><br><span class="line">        self.seed = seed</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hash</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        哈希算法</span></span><br><span class="line"><span class="string">        :param value: value</span></span><br><span class="line"><span class="string">        :return: Hash value</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(value)):</span><br><span class="line">            ret += self.seed * ret + ord(value[i])</span><br><span class="line">        <span class="comment"># print((self.m - 1) &amp; ret)</span></span><br><span class="line">        <span class="keyword">return</span> (self.m - <span class="number">1</span>) &amp; ret</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;value 是要被处理的内容。这里遍历了value的每一位，并利用ord( )方法取到每一位的ASCII码值，然后混淆seed进行迭代求和运算，最终得到一个数值。这个数值的结果就由value和seed唯一确定。再将这个数值和m进行按位与运算，即可获取到m位数组的映射结果，这样就实现了一个由字符串和seed来确定的散列函数。当m固定时，只要seed值相同，散列函数就是相同的，相同value必然会映射到相同的位置。所以如果想要构造几个不同的散列函数，只需要改变其seed就好了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  seed取值范围</span></span><br><span class="line">BLOOMFILTER_HASH_NUMBER = <span class="number">6</span></span><br><span class="line"><span class="comment">#  需要的位数m</span></span><br><span class="line">BLOOMFILTER_BIT = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BloomFilter</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Bloom Filter 里面需要用到k个散列函数，这里要对这几个散列</span></span><br><span class="line"><span class="string">    函数指定相同的m值和不同的seed值</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, server)</span>:</span></span><br><span class="line">        self.block_num = <span class="number">1</span>,</span><br><span class="line">        self.key = <span class="string">'BloomFilter'</span></span><br><span class="line">        self.m = <span class="number">1</span> &lt;&lt; BLOOMFILTER_BIT</span><br><span class="line">        self.seeds = range(BLOOMFILTER_HASH_NUMBER)</span><br><span class="line">        self.server = server</span><br><span class="line">        <span class="comment">#  散列函数列表</span></span><br><span class="line">        self.maps = [HashMap(self.m, seed) <span class="keyword">for</span> seed <span class="keyword">in</span> self.seeds]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exists</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="comment"># 判断元素是否重复</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> value:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        exist = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> map <span class="keyword">in</span> self.maps:</span><br><span class="line">            offset = map.hash(value)</span><br><span class="line">            exist = exist &amp; self.server.getbit(self.key, offset)</span><br><span class="line">        <span class="keyword">return</span> exist</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> f <span class="keyword">in</span> self.maps:</span><br><span class="line">            offset = f.hash(value)</span><br><span class="line">            print(offset)</span><br><span class="line">            self.server.setbit(self.key, offset, <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;传入散列函数的个数，用它来生成几个不同的seed。用不同的seed来定义不同的散列原函数，这样我们就可以构造一个散列函数列表。遍历seed，构造带有不同seed值的HashMap对象，然后将HashMap对象保存成变量maps供后续使用。另外，server就是Redis连接对象，key就是这个m位数组的名称。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Bloom-Filter的算法&quot;&gt;&lt;a href=&quot;#Bloom-Filter的算法&quot; class=&quot;headerlink&quot; title=&quot;Bloom Filter的算法&quot;&gt;&lt;/a&gt;Bloom Filter的算法&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在Bloom
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>类和类之间的关系</title>
    <link href="http://gilgameshzzz.github.io/2019/02/28/%E7%B1%BB%E5%92%8C%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <id>http://gilgameshzzz.github.io/2019/02/28/类和类之间的关系/</id>
    <published>2019-02-28T09:31:39.730Z</published>
    <updated>2019-02-26T06:38:10.203Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类和类之间的关系"><a href="#类和类之间的关系" class="headerlink" title="类和类之间的关系"></a>类和类之间的关系</h1><p>-is-a 关系：（继承）<br>-has-a 关系（关联/聚合/合成）<br>-use-a 关系（依赖）</p><pre><code>Python解释器搜索一个变量会按照LEGB的顺序进行搜索 LEGB - Local -&gt;Embedded -&gt;Global -&gt; BUilt-in       局部     嵌套       全局      内置 在函数中定义的变量正常情况下属于局部作用域 但是可以通过nolocal或global关键字将其放到嵌套或全局作用域</code></pre><p>UML -Unified Modeling Language - 统一建模语言<br>标准化的图形符号 - 便于沟通交流</p><p>重要的三种图：用例图 / 类图 / 时序图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum,unique</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义枚举（定义符号常量的最佳选择，符号常量总是优于字面常量）</span></span><br><span class="line"><span class="comment"># @unique 限定唯一性</span></span><br><span class="line"><span class="meta">@unique</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Suite</span><span class="params">(Enum)</span>:</span></span><br><span class="line">    <span class="string">"""docstring for suite"""</span></span><br><span class="line"></span><br><span class="line">    SPADE = <span class="number">0</span></span><br><span class="line">    HEART = <span class="number">1</span></span><br><span class="line">    CLUB = <span class="number">2</span></span><br><span class="line">    DIAMOND = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Card</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""docstring for ClassName"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, suite, face)</span>:</span></span><br><span class="line">        self.suite =suite</span><br><span class="line">        self.face = face</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'显示牌面'</span></span><br><span class="line">        suites = [<span class="string">'黑桃'</span>, <span class="string">'红心'</span>, <span class="string">'梅花'</span>, <span class="string">'方块'</span>]</span><br><span class="line">        face = [<span class="string">''</span>, <span class="string">'A'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>, <span class="string">'10'</span>, <span class="string">'J'</span>, <span class="string">'Q'</span>,<span class="string">'k'</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f'<span class="subst">&#123;suites[self.suite.value]&#125;</span> <span class="subst">&#123;face[self.face]&#125;</span>'</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.show()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.show()  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Poker</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""扑克"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.index = <span class="number">0</span></span><br><span class="line">        self.cards = [Card(suite,face) </span><br><span class="line">                      <span class="keyword">for</span> suite <span class="keyword">in</span> Suite </span><br><span class="line">                      <span class="keyword">for</span> face <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">14</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shuffle</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''洗牌（随机乱序）'''</span></span><br><span class="line">        random.shuffle(self.cards)</span><br><span class="line">        self.index = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deal</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''发牌'''</span></span><br><span class="line">        card = self.cards[self.index]</span><br><span class="line">        self.index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> card</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_more</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.index &lt; len(self.cards)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.card = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_one</span><span class="params">(self,card)</span>:</span></span><br><span class="line">        <span class="string">'''摸一张牌'''</span></span><br><span class="line">        self.card.append(card)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sort</span><span class="params">(self, comp=lambda card: card.face)</span>:</span></span><br><span class="line">        self.card.sort(key= comp)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    poker = Poker()</span><br><span class="line">    print(poker.cards)    </span><br><span class="line">    poker.shuffle()</span><br><span class="line">   </span><br><span class="line">    <span class="comment"># print(poker.deal())</span></span><br><span class="line">    players= [Player(<span class="string">'东邪'</span>),Player(<span class="string">'西毒'</span>), Player(<span class="string">'南帝'</span>), Player(<span class="string">'北丐'</span>)]</span><br><span class="line">    <span class="keyword">while</span> poker.has_more:</span><br><span class="line">        <span class="keyword">for</span> player <span class="keyword">in</span> players:</span><br><span class="line">            player.get_one(poker.deal())</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">for</span> player <span class="keyword">in</span> players:</span><br><span class="line">        player.sort()</span><br><span class="line">        print(player.name, end=<span class="string">''</span>)</span><br><span class="line">        print(player.card)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;类和类之间的关系&quot;&gt;&lt;a href=&quot;#类和类之间的关系&quot; class=&quot;headerlink&quot; title=&quot;类和类之间的关系&quot;&gt;&lt;/a&gt;类和类之间的关系&lt;/h1&gt;&lt;p&gt;-is-a 关系：（继承）&lt;br&gt;-has-a 关系（关联/聚合/合成）&lt;br&gt;-use-a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>面向对象-OOP</title>
    <link href="http://gilgameshzzz.github.io/2019/02/28/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%20-OOP(Object%20Oriendted%20Programming)%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E6%94%AF%E6%9F%B1%EF%BC%9A/"/>
    <id>http://gilgameshzzz.github.io/2019/02/28/面向对象 -OOP(Object Oriendted Programming)面向对象的四大支柱：/</id>
    <published>2019-02-28T09:31:39.730Z</published>
    <updated>2019-02-26T06:38:10.203Z</updated>
    
    <content type="html"><![CDATA[<p>面向对象 -OOP(Object Oriendted Programming)<br>面向对象的四大支柱：</p><ul><li><p>抽象：类是抽象的，对象是具体的，定义类的过程就是一个抽象过程，  需要最</p><p>数据抽象(发现静态特征（属性）)和行为抽象（发现动态特征（方法））</p></li><li><p>封装: 把数据和操作数据的方法绑定到一起形成对象，这是一个隐藏实现细节暴露<br> 简单的调用接口的过程。</p></li><li><p>继承：从已有的类创建新类的过程，提供继承信息的称为父类（基类/超类）得到继<br> 承信息的称为子类（派生类）</p></li><li><p>多态：子类在继承父类的过程中可以重写（override）父类已有的方法<br> 不同的子类可以给出不同放任实现版本，那么在调用该方法时会表现出多态</p></li></ul><p>面向对象七原则：<br>1.单一职责原则 -SRP- 一个类只该做的事情<br>2.开闭原则 - 软件实体应该对扩展开放，对修改关闭<br>3.依赖倒转原则<br>4.里氏替换原则 - 任何可以用子类对象替换父类对象<br>5.接口隔离原则<br>6.合成聚合复用原则 - 优先使用强关联关系而不是继承关系复用代码<br>7.最少知识原则（迪米特法则） - 不要给没有必然联系的对象发消息</p><p>GoF设计模式 -23种场景：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta,abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="comment"># 元类 - 描述类</span></span><br><span class="line"><span class="comment"># 通过 metaclass=ABCmeta可以将一个类声明为抽象类</span></span><br><span class="line"><span class="comment"># 通过abstractment装饰器可以将方法装饰成抽象方法</span></span><br><span class="line"><span class="comment"># 抽象类不能实例化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Employee</span><span class="params">(object, metaclass=ABCMeta)</span>:</span></span><br><span class="line">    <span class="string">"""员工  """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__salary__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span><span class="params">(Employee)</span>:</span></span><br><span class="line">    <span class="string">"""部门经理"""</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 重写父类的抽象方法（如果没有重写抽象方法，也不能实例化）</span></span><br><span class="line">    <span class="comment"># 不同的子类都会重写这个抽象方法所以这个，所以这个方法是现了多态</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_salary</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">15000</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span><span class="params">(Employee)</span>:</span></span><br><span class="line">    <span class="string">"""程序员"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        super ().__init__(name)</span><br><span class="line">        self.working_hour = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_salary</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">200</span> * self.working_hour</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Saleman</span><span class="params">(Employee)</span>:</span></span><br><span class="line">    <span class="string">"""docstring for Saleman"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        super().__init__(name)</span><br><span class="line">        self.sale = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_salary</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.05</span> * self.sale + <span class="number">1800</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""主函数"""</span></span><br><span class="line">    emps = [Manager(<span class="string">'曹操'</span>), Programmer(<span class="string">'司马懿'</span>),</span><br><span class="line">    Saleman(<span class="string">'郭嘉'</span>)</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">for</span> emp <span class="keyword">in</span> emps:</span><br><span class="line">        <span class="comment"># 通过isinstance函数可以进行类型识别</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(emp,Programmer):</span><br><span class="line">            hour = int(input(<span class="string">f'<span class="subst">&#123;emp.name&#125;</span>本月工作时间：'</span>)) </span><br><span class="line">            emp.working_hour =hour</span><br><span class="line">        <span class="keyword">elif</span> isinstance(emp,Saleman):</span><br><span class="line">            sale = float(input(<span class="string">f'<span class="subst">&#123;emp.name&#125;</span>本月销售额：'</span>))</span><br><span class="line">            emp.sale = sale</span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;emp.name&#125;</span>本月工资：<span class="subst">&#123;emp.get_salary()&#125;</span>元'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;面向对象 -OOP(Object Oriendted Programming)&lt;br&gt;面向对象的四大支柱：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;抽象：类是抽象的，对象是具体的，定义类的过程就是一个抽象过程，  需要最&lt;/p&gt;
&lt;p&gt;数据抽象(发现静态特征（属性）)和行为抽象（发
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>web安全，celery</title>
    <link href="http://gilgameshzzz.github.io/2019/02/28/%E7%AC%94%E8%AE%B0/"/>
    <id>http://gilgameshzzz.github.io/2019/02/28/笔记/</id>
    <published>2019-02-28T09:31:39.729Z</published>
    <updated>2019-02-26T06:38:10.202Z</updated>
    
    <content type="html"><![CDATA[<h2 id="生成用户令牌（token）"><a href="#生成用户令牌（token）" class="headerlink" title="生成用户令牌（token）"></a>生成用户令牌（token）</h2><p> -哈希码 - MD5/SHA1<br> -UUID - 全局唯一标识符<br> -JWT - Json web Token - djangorestframework-jwt</p><p>1、防表单重复，每一次请求刷新令牌<br>2、跨站身份网站伪造 - CSRF、XSRF</p><p>##XSS - 跨站脚本攻击 - 消毒<br>用户评论时输入的是 js脚本代码，发送后就会执行，所以要将特殊字符转换<br> 1、清理用户输入，过滤js代码，过滤特殊字符<br>​          [1] &lt;&gt;（尖括号）     [5] ;（分号）<br>​          [2] “（引号）           [6] ()（括号）<br>​          [3] ‘（单引号）         [7] &amp;（&amp; 符号）<br>​          [4] %（百分比符号）    [8] +（加号）<br> 2、使用HttpUitility及AntiXSSLibrary类库中的方法对html代码进行处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">赋值不会弹框 this.lblName.Text = Encoder.HtmlEncode(&lt;script&gt;alert(&apos;OK&apos;);&lt;/script&gt;&quot;);</span><br></pre></td></tr></table></figure></p><p>浏览器自作聪明识别  设置nosniff</p><h2 id="SQL注入攻击"><a href="#SQL注入攻击" class="headerlink" title="SQL注入攻击"></a>SQL注入攻击</h2><p>不允许单引号拼接SQL语句,不要使用管理员权限的数据库连接，不要使用动态拼接sql</p><h2 id="点劫持攻击-click-hacking-X-FRAME-OPTIONS-DENY"><a href="#点劫持攻击-click-hacking-X-FRAME-OPTIONS-DENY" class="headerlink" title="点劫持攻击 - click-hacking - X_FRAME_OPTIONS = DENY"></a>点劫持攻击 - click-hacking - X_FRAME_OPTIONS = DENY</h2><p>浏览器iframe标签嵌套其他网页，并社会透明度为0</p><p>密码原文——&gt;加盐  —–&gt;生成哈希摘要</p><p>SPA - 单页应用 -Single Page Application</p><p><a href="http://www.cnblogs.com/derek1184405959/p/8722212.html" target="_blank" rel="noopener">http://www.cnblogs.com/derek1184405959/p/8722212.html</a></p><h2 id="web应用优化的两大定律："><a href="#web应用优化的两大定律：" class="headerlink" title="web应用优化的两大定律："></a>web应用优化的两大定律：</h2><p>-1、使用缓存 - 缓存数据特点 ：数据量不大，热点数据，数据的值不会频繁修改<br>-2、能推迟的事情都不马上做 - 消息队列 - 削峰/上下游节点解耦合</p><h3 id="消息队列使得任务可以异步化的处理"><a href="#消息队列使得任务可以异步化的处理" class="headerlink" title="消息队列使得任务可以异步化的处理"></a>消息队列使得任务可以异步化的处理</h3><p>同步 - 阻塞<br>异步 - 非阻塞</p><h3 id="Celery-既可以充当消息的生产者也可以充当消息的消费者"><a href="#Celery-既可以充当消息的生产者也可以充当消息的消费者" class="headerlink" title="Celery - 既可以充当消息的生产者也可以充当消息的消费者"></a>Celery - 既可以充当消息的生产者也可以充当消息的消费者</h3><p>要使用Celery（有汉化文档）需要为其配置队列服务 - RabbitMQ(推荐)/Redis<br>定时任务 + 异步任务</p><p>下订单就是一个可以推迟执行的任务  不需要马上返回订单受理的结果 而且下订单的系统和受理订单的系统可以是两套程序（消息的生产者和消息的消费者）分别运转在不同的服务器上</p><p>项目中可能会遇到执行时间无法预期的任务（比如调用三方平台）和不需要马上给出执行结果的任务，这两种任务都应该放到消息队列中，受理用户请求的程序作为消息的生产者将用户请求放入消息队列，稍后由消息的消费者会从消息队列中取出任务进行处理</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;生成用户令牌（token）&quot;&gt;&lt;a href=&quot;#生成用户令牌（token）&quot; class=&quot;headerlink&quot; title=&quot;生成用户令牌（token）&quot;&gt;&lt;/a&gt;生成用户令牌（token）&lt;/h2&gt;&lt;p&gt; -哈希码 - MD5/SHA1&lt;br&gt; -UUID
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据库优化</title>
    <link href="http://gilgameshzzz.github.io/2019/02/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/"/>
    <id>http://gilgameshzzz.github.io/2019/02/28/数据库优化/</id>
    <published>2019-02-28T09:31:39.728Z</published>
    <updated>2019-02-26T06:38:10.200Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-SQL语句优化"><a href="#1-SQL语句优化" class="headerlink" title="1.SQL语句优化"></a>1.SQL语句优化</h2><p>1）应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。<br>2）应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：<br>select id from t where num is null<br>可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：<br>select id from t where num=0<br>3）很多时候用 exists 代替 in 是一个好的选择<br>4）用Where子句替换HAVING 子句，因为HAVING 只会在检索出所有记录之后才对结果集进行过滤</p><h2 id="2-索引优化"><a href="#2-索引优化" class="headerlink" title="2.索引优化"></a>2.索引优化</h2><p>  数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。<br>  为表设置索引要付出代价的：一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)。<br>  创建索引可以大大提高系统的性能。<br>  第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。<br>  第二，可以大大加快数据的检索速度，这也是创建索引的最主要的原因。<br>  第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。<br>  第四，在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。<br>  第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</p><p>  也许会有人要问：增加索引有如此多的优点，为什么不对表中的每一个列创建一个索引呢？因为，增加索引也有许多不利的方面。<br>  第一，创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。<br>  第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。<br>  第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</p><h2 id="3-数据库结构优化"><a href="#3-数据库结构优化" class="headerlink" title="3.数据库结构优化"></a>3.数据库结构优化</h2><p>1）范式优化： 比如消除冗余（节省空间。。）<br>2）反范式优化：比如适当加冗余等（减少join）<br>3）拆分表： 分区将数据在物理上分隔开，不同分区的数据可以制定保存在处于不同磁盘上的数据文件里。这样，当对这个表进行查询时，只需要在表分区中进行扫描，而不必进行全表扫描，明显缩短了查询时间，另外处于不同磁盘的分区也将对这个表的数据传输分散在不同的磁盘I/O，一个精心设置的分区可以将数据传输对磁盘I/O竞争均匀地分散开。对数据量大的时时表可采取此方法。可按月自动建表分区。<br>4）拆分，又分垂直拆分和水平拆分：<br>   案例： 简单购物系统暂设涉及如下表：<br>   1.产品表（数据量10w，稳定） 2.订单表（数据量200w，且有增长趋势） 3.用户表 （数据量100w，且有增长趋势） 以mysql为例讲述下水平拆分和垂直拆分，mysql能容忍的数量级在百万静态数据可以到千万</p><p>​    垂直拆分：<br>解决问题：表与表之间的io竞争，不解决问题：单表中数据量增长出现的压力<br>方案: 把产品表和用户表放到一个server上 订单表单独放到一个server上 </p><p>​  水平拆分：<br>解决问题：单表中数据量增长出现的压力， 不解决问题：表与表之间的io争夺<br>方案: 用户表通过性别拆分为男用户表和女用户表 订单表通过已完成和完成中拆分为已完成订单和未完成订单 产品表 未完成订单放一个server上 已完成订单表盒男用户表放一个server上 女用户表放一个server上(女的爱购物 哈哈)</p><h2 id="4-服务器硬件优化"><a href="#4-服务器硬件优化" class="headerlink" title="4.服务器硬件优化"></a>4.服务器硬件优化</h2><h1 id="面试回答数据库优化问题从以下几个层面入手"><a href="#面试回答数据库优化问题从以下几个层面入手" class="headerlink" title="面试回答数据库优化问题从以下几个层面入手"></a>面试回答数据库优化问题从以下几个层面入手</h1><p>（1）、根据服务层面：配置mysql性能优化参数；<br>（2）、从系统层面增强mysql的性能：优化数据表结构、字段类型、字段索引、分表，分库、读写分离等等。<br>（3）、从数据库层面增强性能：优化SQL语句，合理使用字段索引。<br>（4）、从代码层面增强性能：使用缓存和NoSQL数据库方式存储，如MongoDB/Memcached/Redis来缓解高并发下数据库查询的压力。<br>（5）、减少数据库操作次数，尽量使用数据库访问驱动的批处理方法。<br>（6）、不常使用的数据迁移备份，避免每次都在海量数据中去检索。<br>（7）、提升数据库服务器硬件配置，或者搭建数据库集群。<br>（8）、编程手段防止SQL注入：使用JDBC PreparedStatement按位插入或查询；正则表达式过滤（非法字符串过滤）；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-SQL语句优化&quot;&gt;&lt;a href=&quot;#1-SQL语句优化&quot; class=&quot;headerlink&quot; title=&quot;1.SQL语句优化&quot;&gt;&lt;/a&gt;1.SQL语句优化&lt;/h2&gt;&lt;p&gt;1）应尽量避免在 where 子句中使用!=或&amp;lt;&amp;gt;操作符，否则将引擎放弃
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深拷贝和浅拷贝</title>
    <link href="http://gilgameshzzz.github.io/2019/02/28/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://gilgameshzzz.github.io/2019/02/28/深拷贝和浅拷贝/</id>
    <published>2019-02-28T09:31:39.728Z</published>
    <updated>2019-02-26T06:38:10.201Z</updated>
    
    <content type="html"><![CDATA[<h2 id="可变和不可变"><a href="#可变和不可变" class="headerlink" title="可变和不可变"></a>可变和不可变</h2><p>可变类型（mutable）：列表，字典；value值改变，id值不变；<br>不可变类型（unmutable）：数字，字符串，元组；value值改变，id值也随之改变。</p><h2 id="赋值，拷贝和深拷贝"><a href="#赋值，拷贝和深拷贝" class="headerlink" title="赋值，拷贝和深拷贝"></a>赋值，拷贝和深拷贝</h2><p><strong>赋值</strong>，只是创建一个变量，该变量指向原来内存地址，如下例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n4 = n3 = n2 = n1 = <span class="string">"123/'Wu'"</span></span><br></pre></td></tr></table></figure></p><p><img src="/img/fuzhi.png" alt="&quot;赋值&quot;"></p><p><strong>浅拷贝</strong>，在内存中只额外创建第一层数据，如下图<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">n1 = &#123;<span class="string">"k1"</span>: <span class="string">"wu"</span>, <span class="string">"k2"</span>: <span class="number">123</span>, <span class="string">"k3"</span>: [<span class="string">"alex"</span>, <span class="number">456</span>]&#125;</span><br><span class="line">n3 = copy.copy(n1)</span><br></pre></td></tr></table></figure></p><p><img src="/img/copy.png" alt="浅拷贝"></p><p><strong>深拷贝</strong>，在内存中将所有的数据重新创建一份（递归拷贝，排除最后一层，即：python内部对字符串和数字的优化），如下图：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">n1 = &#123;<span class="string">"k1"</span>: <span class="string">"wu"</span>, <span class="string">"k2"</span>: <span class="number">123</span>, <span class="string">"k3"</span>: [<span class="string">"alex"</span>, <span class="number">456</span>]&#125;</span><br><span class="line">n4 = copy.deepcopy(n1)</span><br></pre></td></tr></table></figure></p><p><img src="/img/deepcopy.png" alt="深拷贝"></p><h2 id="字符串-数字-元祖拷贝"><a href="#字符串-数字-元祖拷贝" class="headerlink" title="字符串 数字 元祖拷贝"></a>字符串 数字 元祖拷贝</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字符串</span></span><br><span class="line">a = <span class="string">'copytest'</span></span><br><span class="line">b = copy.copy(a)</span><br><span class="line">c = copy.deepcopy(a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(a, id(a))</span><br><span class="line">    print(b, id(b))</span><br><span class="line">    print(c, id(c))</span><br><span class="line">    </span><br><span class="line"><span class="comment">#============输出结果===============#</span></span><br><span class="line">copytest <span class="number">49797384</span></span><br><span class="line">copytest <span class="number">49797384</span></span><br><span class="line">copytest <span class="number">49797384</span></span><br></pre></td></tr></table></figure><p>整型数字，浮点型数字和元祖拷贝结果与字符串拷贝结果相同</p><h2 id="列表拷贝"><a href="#列表拷贝" class="headerlink" title="列表拷贝"></a>列表拷贝</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]]</span><br><span class="line">b = copy.copy(a)</span><br><span class="line">c = copy.deepcopy(a)</span><br><span class="line">b[<span class="number">-1</span>].pop()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(a, id(a))</span><br><span class="line">    print(b, id(b))</span><br><span class="line">    print(c, id(c))</span><br><span class="line"><span class="comment">#============输出结果===============#</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, [<span class="number">1</span>, <span class="number">3</span>]] <span class="number">50059904</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, [<span class="number">1</span>, <span class="number">3</span>]] <span class="number">50007496</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]] <span class="number">50059584</span></span><br></pre></td></tr></table></figure><p><img src="/img/process.png" alt=""></p><h2 id="单例模式下的类的拷贝"><a href="#单例模式下的类的拷贝" class="headerlink" title="单例模式下的类的拷贝"></a>单例模式下的类的拷贝</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleton</span><span class="params">(cls)</span>:</span></span><br><span class="line">    <span class="comment"># 单例装饰器</span></span><br><span class="line">    instances = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">    @wraps(cls)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_instances</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instances:</span><br><span class="line">            instances[cls] = cls(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> instances[cls]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> get_instances</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">aloud</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.name + <span class="string">'123568'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = Animal(<span class="string">'cat'</span>)</span><br><span class="line">b = copy.copy(a)</span><br><span class="line">c = copy.deepcopy(a)</span><br><span class="line">c.name = <span class="string">'dog'</span></span><br><span class="line">d = Animal(<span class="string">'adas'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(a, id(a))</span><br><span class="line">    a.aloud()</span><br><span class="line">    print(b, id(b))</span><br><span class="line">    b.aloud()</span><br><span class="line">    print(c, id(c))</span><br><span class="line">    c.aloud()</span><br><span class="line">    print(d, id(d))</span><br><span class="line">    d.aloud()</span><br><span class="line"></span><br><span class="line"><span class="comment">#============输出结果===============#</span></span><br><span class="line">&lt;__main__.Animal object at <span class="number">0x02F67DD0</span>&gt; <span class="number">49708496</span></span><br><span class="line">cat123568</span><br><span class="line">&lt;__main__.Animal object at <span class="number">0x02FACD90</span>&gt; <span class="number">49991056</span></span><br><span class="line">cat123568</span><br><span class="line">&lt;__main__.Animal object at <span class="number">0x02FACAD0</span>&gt; <span class="number">49990352</span></span><br><span class="line">dog123568</span><br><span class="line">&lt;__main__.Animal object at <span class="number">0x02F67DD0</span>&gt; <span class="number">49708496</span></span><br><span class="line">cat123568</span><br></pre></td></tr></table></figure><p>不可变对象类型，没有被拷贝的说法，即便是用深拷贝，查看id的话也是一样的，如果对其重新赋值，也只是新创建一个对象，替换掉旧的而已。<br>一句话就是，不可变类型，不管是深拷贝还是浅拷贝，地址值和拷贝后的值都是一样的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1，深浅拷贝都是对源对象的复制，占用不同的内存空间。<br>2，不可变类型的对象，对于深浅拷贝毫无影响，最终的地址值和值都是相等的。<br>3，可变类型：<br>=浅拷贝： 值相等，地址相等<br>copy浅拷贝：值相等，地址不相等<br>deepcopy深拷贝：值相等，地址不相等</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;可变和不可变&quot;&gt;&lt;a href=&quot;#可变和不可变&quot; class=&quot;headerlink&quot; title=&quot;可变和不可变&quot;&gt;&lt;/a&gt;可变和不可变&lt;/h2&gt;&lt;p&gt;可变类型（mutable）：列表，字典；value值改变，id值不变；&lt;br&gt;不可变类型（unmutable
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>哈希算法-加密-编码</title>
    <link href="http://gilgameshzzz.github.io/2019/02/28/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%20-%20%E5%8A%A0%E5%AF%86%20-%20%E7%BC%96%E7%A0%81/"/>
    <id>http://gilgameshzzz.github.io/2019/02/28/哈希算法 - 加密 - 编码/</id>
    <published>2019-02-28T09:31:39.727Z</published>
    <updated>2019-02-26T06:38:10.199Z</updated>
    
    <content type="html"><![CDATA[<h1 id="哈希算法-加密-编码"><a href="#哈希算法-加密-编码" class="headerlink" title="哈希算法 - 加密 - 编码"></a>哈希算法 - 加密 - 编码</h1><p>哈希算法 - 哈希摘要 - 数字签名 - 防篡改/保护敏感信息<br>哈希算法是一个单向运算的函数（单向哈希函数）<br>通过哈希算法可以将对象计算出哈希摘要但是哈希摘要无法还原成原来的对</p><p>Martin flower -代码有很多味道重复是最坏的一种<br>重构(refactor)</p><p>策略模式<br>加密解密 - 明文 —- 加密 —–&gt; 密文 —- 解密 —–&gt; 明文<br>对称加密 - 加密和解密使用同一个密钥 - AES<br>非对称加密 - 加密和解密使用不同的密钥（公钥和私钥）- RSA<br>pip install pycrypto</p><p>编码和解码 - 将内存中的二进制数据处理成其他的格式 - BASE64<br>BASE64 - 用64个字符(a-zA-Z0-9/+)表二进制数据示所有的</p><p>编码黑洞</p><p>中文/日文 –&gt;iso -8859 -1 Latin –&gt; ??</p><p>乱码 –&gt;编码和解码的时候没用使用相同的字符集</p><p>utf-8 -Unicode的一种变长实现方案</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StreamHasher</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""docstring for streamHasher"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, algorithm=<span class="string">'md5'</span>, size=<span class="number">4096</span>)</span>:</span></span><br><span class="line">        self.size = size</span><br><span class="line">        alg = algorithm.lower()</span><br><span class="line">        <span class="keyword">if</span> alg ==<span class="string">'md5'</span>:</span><br><span class="line">            self.hasher = hashlib.md5()</span><br><span class="line">        <span class="keyword">elif</span> alg == <span class="string">'sha1'</span>:</span><br><span class="line">            self.hasher = hashlib.sha1()</span><br><span class="line">        <span class="keyword">elif</span> alg == <span class="string">'sha256'</span>:</span><br><span class="line">            self.hasher = hashlib.sha256()</span><br><span class="line">        <span class="keyword">elif</span> alg == sha512:</span><br><span class="line">            self.hasher = hashlib.sha512()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'不支持指定的哈希算法'</span>)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># __call__ -魔术方法，调用对象的时候调用该方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self,stream)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.to_digest(stream)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_digest</span><span class="params">(self, stream)</span>:</span></span><br><span class="line">        <span class="string">'''生成MD5摘要'''</span></span><br><span class="line">        <span class="comment"># b" 终止符，读文本文件终止符 ''</span></span><br><span class="line">        hasher = self.hasher</span><br><span class="line">        <span class="keyword">for</span> buf <span class="keyword">in</span> iter(<span class="keyword">lambda</span>:stream.read(self.size), <span class="string">b''</span>):</span><br><span class="line">            hasher.update(b)</span><br><span class="line">            <span class="comment"># 16进制的md摘要</span></span><br><span class="line">        <span class="keyword">return</span> hasher.hexdigest()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_sha256_digest</span><span class="params">(stream, block_size = <span class="number">4096</span>)</span>:</span></span><br><span class="line">    <span class="string">'''生成MD5摘要'''</span></span><br><span class="line">    <span class="comment"># b" 终止符，读文本文件终止符 ''</span></span><br><span class="line">    hasher = hashlib.sha256()</span><br><span class="line">    <span class="keyword">for</span> buf <span class="keyword">in</span> iter(<span class="keyword">lambda</span>:stream.read(<span class="number">4096</span>), <span class="string">b''</span>):</span><br><span class="line">        hasher.update(b)</span><br><span class="line">        <span class="comment"># 16进制的md摘要</span></span><br><span class="line">    <span class="keyword">return</span> hasher.hexdigest()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    hasher = hashlib.md5()</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'aaa.png'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f:     </span><br><span class="line">        sh = StreamHasher()</span><br><span class="line">        print(sh.to_digest(f))</span><br><span class="line">                </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;哈希算法-加密-编码&quot;&gt;&lt;a href=&quot;#哈希算法-加密-编码&quot; class=&quot;headerlink&quot; title=&quot;哈希算法 - 加密 - 编码&quot;&gt;&lt;/a&gt;哈希算法 - 加密 - 编码&lt;/h1&gt;&lt;p&gt;哈希算法 - 哈希摘要 - 数字签名 - 防篡改/保护敏感信
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>多并发编程-多线程</title>
    <link href="http://gilgameshzzz.github.io/2019/02/28/%E5%A4%9A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://gilgameshzzz.github.io/2019/02/28/多并发编程-多线程/</id>
    <published>2019-02-28T09:31:39.727Z</published>
    <updated>2019-02-26T06:38:10.199Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多并发编程-多线程"><a href="#多并发编程-多线程" class="headerlink" title="多并发编程-多线程"></a>多并发编程-多线程</h1><h4 id="守护线程-守护进程-daemon"><a href="#守护线程-守护进程-daemon" class="headerlink" title="守护线程/守护进程 - daemon"></a>守护线程/守护进程 - daemon</h4><p>如果主线程结束了守护线程也不再保留即使守护线程还在执行（没有结束）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_message</span><span class="params">(content)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        print(content, end=<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    threading.Thread(</span><br><span class="line">        target=show_message, args=(<span class="string">'Ping'</span>, ), daemon=<span class="keyword">True</span></span><br><span class="line">    ).start()</span><br><span class="line">    threading.Thread(</span><br><span class="line">        target=show_message, args=(<span class="string">'Pong'</span>, ), daemon=<span class="keyword">True</span></span><br><span class="line">    ).start()</span><br><span class="line">    sleep(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p><strong>Lock</strong> - 多个线程竞争临界资源（资源只有1个） - 获得锁才能操作资源</p><p><strong>Condition </strong>-  基于Lock对象可以创建它 - wait() / notify_all()</p><p><strong>实现线程调度</strong></p><p>Semaphore - 多个线程竞争资源（资源有多个，但线程数量大于资源数量）</p><ul><li>多个线程通信比较简单因为可以共享内存</li></ul><ul><li>多个进程通信相对比较困难，可以使用multiprocessing.Queue，通过多个进程共享一个队列来实现进程间的通信</li></ul><p>生产者消费者模型 / 哲学家进餐模型 - 多线程编程模型</p><h4 id="三种方式实现多线程"><a href="#三种方式实现多线程" class="headerlink" title="三种方式实现多线程"></a>三种方式实现多线程</h4><p>多线程程序如果没有竞争资源的场景那么通常会比较简单</p><p>临界资源 - 被多个线程竞争的资源</p><p>当多个线程竞争临界资源的时候如果缺乏必要的保护措施就会导致数据错乱</p><h5 id="1-定义线程类"><a href="#1-定义线程类" class="headerlink" title="1.  定义线程类"></a>1.  定义线程类</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""银行账户"""</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.balance = <span class="number">0.0</span></span><br><span class="line">        self.lock = threading.Lock()</span><br><span class="line">     </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">deposit</span><span class="params">(self, money)</span>:</span></span><br><span class="line">        <span class="comment"># 通过锁保护临界资源</span></span><br><span class="line">        <span class="comment"># 可以写try-finally也可以使用上下文语法</span></span><br><span class="line">        <span class="comment"># self.lock.acquire()</span></span><br><span class="line">        <span class="comment"># try:</span></span><br><span class="line">        <span class="comment">#     pass</span></span><br><span class="line">        <span class="comment"># finally:</span></span><br><span class="line">        <span class="comment">#     self.lock.release()</span></span><br><span class="line">        <span class="keyword">with</span> self.lock:</span><br><span class="line">            new_balance = self.balance + money</span><br><span class="line">            time.sleep(<span class="number">0.001</span>)</span><br><span class="line">            self.balance = new_balance         </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddMoneyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, account, money)</span>:</span></span><br><span class="line">        self.account = account</span><br><span class="line">        self.money = money</span><br><span class="line">        <span class="comment"># 自定义线程的初始化方法中必须调用父类的初始化方法</span></span><br><span class="line">        super().__init__()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># run方法是线程启动之后要执行的回调方法（钩子函数）</span></span><br><span class="line">    <span class="comment"># 所以启动线程不能够直接调用run方法而是通过start方法启动线程</span></span><br><span class="line">    <span class="comment"># 什么时候需要使用回调式编程？</span></span><br><span class="line">    <span class="comment"># 你知道要做什么但不知道什么时候会做这件事情</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 线程启动之后要执行的操作</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line"> a1 = Account()</span><br><span class="line">    threads=[]</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        <span class="comment"># time.sleep(0.1)</span></span><br><span class="line">        t = AddMoneyThread(a1,<span class="number">1</span>)</span><br><span class="line">        threads.append(t)</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">    <span class="comment">#等待线程执行完</span></span><br><span class="line">        t.join()</span><br><span class="line"></span><br><span class="line">    print(a1.balance)</span><br></pre></td></tr></table></figure><h5 id="2-直接通过threading-Thread"><a href="#2-直接通过threading-Thread" class="headerlink" title="2. 直接通过threading.Thread"></a>2. 直接通过threading.Thread</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">threads = []</span><br><span class="line">account = Acount()</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">t = threading.Thread(target=add_money, args=(account, <span class="number">1</span>))</span><br><span class="line">threads.append(t)</span><br><span class="line">t.start()</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">t.join()</span><br><span class="line">print(account.banlnce)</span><br></pre></td></tr></table></figure><h5 id="3-调用线程池中的线程执行特定任务"><a href="#3-调用线程池中的线程执行特定任务" class="headerlink" title="3.调用线程池中的线程执行特定任务"></a>3.调用线程池中的线程执行特定任务</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建线程池</span></span><br><span class="line">pool = ThreadpoolExcutor(max_workers=<span class="number">10</span>)</span><br><span class="line">futures = []</span><br><span class="line"><span class="comment"># 调用线程池中的线程来执行特定的任务</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">future = pool.submit(add_money,account,<span class="number">1</span>)</span><br><span class="line">futures.append(future)</span><br><span class="line">pool.shoutdown()</span><br><span class="line"><span class="keyword">for</span> future <span class="keyword">in</span> futures:</span><br><span class="line">future.result()</span><br><span class="line">print(account.banlance)</span><br><span class="line"></span><br><span class="line"><span class="comment">#也可以用上下文方法</span></span><br><span class="line">futures = []</span><br><span class="line"><span class="keyword">with</span> ThreadpoolExcutor(max_workers=<span class="number">10</span>) <span class="keyword">as</span> pool:</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">      futures.append(pool.submit(add_money,account,<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> futures:</span><br><span class="line">        <span class="comment"># 获取函数add_money的返回值</span></span><br><span class="line">        future.result()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;多并发编程-多线程&quot;&gt;&lt;a href=&quot;#多并发编程-多线程&quot; class=&quot;headerlink&quot; title=&quot;多并发编程-多线程&quot;&gt;&lt;/a&gt;多并发编程-多线程&lt;/h1&gt;&lt;h4 id=&quot;守护线程-守护进程-daemon&quot;&gt;&lt;a href=&quot;#守护线程-守护进程
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python的技巧和方法</title>
    <link href="http://gilgameshzzz.github.io/2019/02/28/python%E6%8A%80%E5%B7%A7/"/>
    <id>http://gilgameshzzz.github.io/2019/02/28/python技巧/</id>
    <published>2019-02-28T09:31:39.726Z</published>
    <updated>2019-02-26T06:38:10.198Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-路径操作"><a href="#1-路径操作" class="headerlink" title="1. 路径操作"></a>1. 路径操作</h1><p>比起os模块的path方法，python3标准库的pathlib模块的Path处理起路径更加的容易。</p><p>l例如：获取当前文件路径。<br>os版：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(os.path.dirname(__file__))</span><br><span class="line">print(os.getcwd())</span><br></pre></td></tr></table></figure></p><p>pathlib版：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(pathlib.Path.cwd())</span><br></pre></td></tr></table></figure></p><p>看着好像没啥区别，然后看下面这个。</p><h2 id="获取上两级文件目录"><a href="#获取上两级文件目录" class="headerlink" title="获取上两级文件目录"></a>获取上两级文件目录</h2><p>os版：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(os.path.dirname(os.path.dirname(os.getcwd())))</span><br></pre></td></tr></table></figure></p><p>pathlib版:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(pathlib.Path.cwd().parent.parent)</span><br></pre></td></tr></table></figure></p><h2 id="拼接路径"><a href="#拼接路径" class="headerlink" title="拼接路径"></a>拼接路径</h2><p>os版:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(os.path.join(os.path.dirname(os.path.dirname(os.getcwd())),<span class="string">"yamls"</span>,<span class="string">"a.yaml"</span>))</span><br></pre></td></tr></table></figure></p><p>pathlib版:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parts=[<span class="string">"yamls"</span>,<span class="string">"a.yaml"</span>]</span><br><span class="line">print(pathlib.Path.cwd().parent.parent.joinpath(*parts))</span><br></pre></td></tr></table></figure></p><h2 id="运行时拼接路径"><a href="#运行时拼接路径" class="headerlink" title="运行时拼接路径"></a>运行时拼接路径</h2><p>os版:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), <span class="string">'yamls'</span>,<span class="string">f'<span class="subst">&#123;site_name&#125;</span>.yaml'</span>)</span><br></pre></td></tr></table></figure></p><p>pathlib版:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parts=[<span class="string">"yamls"</span>,<span class="string">"a.yaml"</span>]</span><br><span class="line">print(pathlib.Path(__file__).resolve().parent.parent.joinpath(*parts))</span><br></pre></td></tr></table></figure></p><p>另外pathlib生成的是个对象，在open文件操作中可以直接运行的但是如果当作字符串操作会出现错误，此时需要对其进行转换，使用os.fspath()即可，不过一般很少有操作路径字符串的习惯。<br>综合起来，还是pathlib拼接路径方便。</p><h1 id="2-保存标准格式的yaml文件"><a href="#2-保存标准格式的yaml文件" class="headerlink" title="2. 保存标准格式的yaml文件"></a>2. 保存标准格式的yaml文件</h1><p>编程免不了要写配置文件，怎么写配置也是一门学问。<br>YAML 是专门用来写配置文件的语言，非常简洁和强大，远比 JSON 格式方便。<br>YAML在python语言中有PyYAML安装包。<br>前提安装第三方库<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install pyaml</span><br><span class="line">pip install ruamel.yaml</span><br></pre></td></tr></table></figure></p><p>关于yaml的读取知识网上一堆了我就不说了，这里主要说写入。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ruamel <span class="keyword">import</span> yaml</span><br><span class="line">data=&#123;<span class="string">"age"</span>:<span class="number">23</span>,<span class="string">"sex"</span>:<span class="string">"男"</span>,<span class="string">"name"</span>:<span class="string">"牛皮"</span>&#125;</span><br><span class="line"><span class="keyword">with</span> open(conf_file, <span class="string">"w"</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> fs:</span><br><span class="line">    yaml.dump(data, fs, Dumper=yaml.RoundTripDumper, allow_unicode=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure></p><p>yaml写文件和json一样也是使用dump。</p><h1 id="3-同时迭代两个列表"><a href="#3-同时迭代两个列表" class="headerlink" title="3. 同时迭代两个列表"></a>3. 同时迭代两个列表</h1><p>以前的时候我是这么解决的<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>]</span><br><span class="line">b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]  <span class="comment"># 空的补充None</span></span><br><span class="line"><span class="keyword">for</span> index, a_item <span class="keyword">in</span> enumerate(a):</span><br><span class="line">    b_item = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">if</span> len(b) - <span class="number">1</span> &lt;= index:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        b_item = b[index]</span><br><span class="line">    print(&#123;a_item:b_item&#125;)</span><br></pre></td></tr></table></figure></p><p>现在通过itertools标准库的zip升级版zip_longest解决，可以通过fillvalue参数补充缺失值。当然如果比较的元素个数相同可以直接用zip。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> zip_longest</span><br><span class="line"></span><br><span class="line">a = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>,<span class="string">"e"</span>]</span><br><span class="line">b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]  <span class="comment"># 空的补充None</span></span><br><span class="line"><span class="keyword">for</span> a_item, b_item <span class="keyword">in</span> zip_longest(a,b,fillvalue=<span class="number">0</span>):</span><br><span class="line">    print(&#123;a_item:b_item&#125;)</span><br></pre></td></tr></table></figure></p><h1 id="4-三元表达式还能这么用？"><a href="#4-三元表达式还能这么用？" class="headerlink" title="4. 三元表达式还能这么用？"></a>4. 三元表达式还能这么用？</h1><p>一般的我们这样写<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="string">"hello"</span> <span class="keyword">if</span> <span class="number">2</span>&gt;<span class="number">1</span> <span class="keyword">else</span> <span class="string">"bye"</span></span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure></p><p>我们知道python中false实际式0，true是1，所以对于上面的式子我们就可以这么写了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="string">"hello"</span>,<span class="string">"bye"</span>][<span class="number">2</span>&lt;<span class="number">1</span>]</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure></p><p>因为2&lt;1是false也就是0，所以输出了第一个元素hello。</p><h1 id="5-简单的类使用namedtuple代替"><a href="#5-简单的类使用namedtuple代替" class="headerlink" title="5.简单的类使用namedtuple代替"></a>5.简单的类使用namedtuple代替</h1><p>先来一个简单的例子<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="comment"># Person=collections.namedtuple('Person','name age')</span></span><br><span class="line"><span class="comment"># 如果使用python中的关键字会出现错误,此时使用rename字段。</span></span><br><span class="line"><span class="comment"># 按照元素在元组中的下标赋值。class就是_2,def是_3</span></span><br><span class="line">Person = collections.namedtuple(<span class="string">'Person'</span>, [<span class="string">'name'</span>, <span class="string">'age'</span>, <span class="string">'class'</span>, <span class="string">'def'</span>, <span class="string">'name'</span>, <span class="string">'name'</span>], rename=<span class="keyword">True</span>)</span><br><span class="line">p = Person(name=<span class="string">'lisa'</span>, age=<span class="string">'12'</span>, _2=<span class="string">"class2"</span>, _3=<span class="string">"def"</span>, _4=<span class="string">"name2"</span>, _5=<span class="string">"name3"</span>)</span><br><span class="line">print(p)</span><br><span class="line"><span class="comment"># 如果出现相同的字段第二次出现的时候也是用其下标，参考上面的例子。</span></span><br><span class="line"><span class="comment"># _fields查看字段名,可以发现内置模块和重复的字段标记为_加下标的形式</span></span><br><span class="line">print(p._fields)</span><br><span class="line"><span class="comment"># 使用_asdict将namedtuple转为OrderedDict。</span></span><br><span class="line">od = p._asdict()</span><br><span class="line">print(od)</span><br><span class="line"><span class="comment"># 然后可以转为字典</span></span><br><span class="line">print(dict(od))</span><br><span class="line"><span class="comment"># _replace()方法构建一个新实例，因为namedtuple是不可变类型所以这个方法可以返回一个新的对象。</span></span><br><span class="line">new_p = p._replace(name=<span class="string">"samJ"</span>)</span><br><span class="line">print(new_p)</span><br><span class="line">print(new_p <span class="keyword">is</span> p)  <span class="comment"># 可以看到不是同一个对象。</span></span><br></pre></td></tr></table></figure></p><p>一个实用的例子pyppeteer的例子感受下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> pyppeteer</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Response = namedtuple(<span class="string">"rs"</span>, <span class="string">"title url html cookies headers history status"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(url, timeout=<span class="number">30</span>)</span>:</span></span><br><span class="line">    <span class="comment"># 默认30s</span></span><br><span class="line">    browser = <span class="keyword">await</span> pyppeteer.launch(headless=<span class="keyword">True</span>, args=[<span class="string">'--no-sandbox'</span>])</span><br><span class="line">    page = <span class="keyword">await</span>  browser.newPage()</span><br><span class="line">    res = <span class="keyword">await</span> page.goto(url, options=&#123;<span class="string">'timeout'</span>: int(timeout * <span class="number">1000</span>)&#125;)</span><br><span class="line">    data = <span class="keyword">await</span> page.content()</span><br><span class="line">    title = <span class="keyword">await</span> page.title()</span><br><span class="line">    resp_cookies = <span class="keyword">await</span> page.cookies()</span><br><span class="line">    resp_headers = res.headers</span><br><span class="line">    resp_history = <span class="keyword">None</span></span><br><span class="line">    resp_status = res.status</span><br><span class="line">    response = Response(title=title, url=url,</span><br><span class="line">                        html=data,</span><br><span class="line">                        cookies=resp_cookies,</span><br><span class="line">                        headers=resp_headers,</span><br><span class="line">                        history=resp_history,</span><br><span class="line">                        status=resp_status)</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    url_list = [<span class="string">"http://www.10086.cn/index/tj/index_220_220.html"</span>, <span class="string">"http://www.10010.com/net5/011/"</span>,</span><br><span class="line">                <span class="string">"http://python.jobbole.com/87541/"</span>]</span><br><span class="line">    task = (get_html(url) <span class="keyword">for</span> url <span class="keyword">in</span> url_list)</span><br><span class="line"></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    results = loop.run_until_complete(asyncio.gather(*task))</span><br><span class="line">    <span class="keyword">for</span> res <span class="keyword">in</span> results:</span><br><span class="line">        print(res.title)</span><br></pre></td></tr></table></figure></p><h1 id="6-使用枚举让数字变得更易懂。"><a href="#6-使用枚举让数字变得更易懂。" class="headerlink" title="6 使用枚举让数字变得更易懂。"></a>6 使用枚举让数字变得更易懂。</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> enum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 枚举</span></span><br><span class="line"><span class="meta">@enum.unique</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sex</span><span class="params">(enum.Enum)</span>:</span></span><br><span class="line">    man = <span class="number">12</span></span><br><span class="line">    woman = <span class="number">13</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 因为加了唯一值的装饰器所以下面添加属性会报错</span></span><br><span class="line">    <span class="comment"># boy=12</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(Sex.man.name)</span><br><span class="line">print(Sex.woman.value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> Sex:</span><br><span class="line">    print(item.name)</span><br><span class="line">    print(item.value)</span><br><span class="line">print(<span class="string">"-"</span> * <span class="number">40</span>)</span><br><span class="line"><span class="comment"># 其他使用方式</span></span><br><span class="line">words = enum.Enum(</span><br><span class="line">    value=<span class="string">'item'</span>,</span><br><span class="line">    names=(<span class="string">'a b c d e f'</span>),</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 输出元素c，必须是上面names里含有的值</span></span><br><span class="line">print(words.c)</span><br><span class="line">print(words.f)</span><br><span class="line"><span class="comment"># 因为names不含有w所以报错</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(words.w)</span><br><span class="line"><span class="keyword">except</span> AttributeError <span class="keyword">as</span> e:</span><br><span class="line">    print(e.args)</span><br><span class="line">print(<span class="string">"-"</span> * <span class="number">40</span>)</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    print(word.name, word.value)  <span class="comment"># 默认赋值为、从1开始自增。</span></span><br><span class="line">print(<span class="string">"-"</span> * <span class="number">40</span>)</span><br><span class="line"><span class="comment"># 如果自定义元素的值啧改为一下元组的形式</span></span><br><span class="line">words2 = enum.Enum(</span><br><span class="line">    value=<span class="string">'item2'</span>,</span><br><span class="line">    names=[(<span class="string">'a'</span>, <span class="number">23</span>), (<span class="string">'b'</span>, <span class="number">56</span>), (<span class="string">"c"</span>, <span class="number">12</span>), (<span class="string">"d"</span>, <span class="number">333</span>)]</span><br><span class="line">)</span><br><span class="line"><span class="keyword">for</span> word2 <span class="keyword">in</span> words2:</span><br><span class="line">    print(word2.name, word2.value)</span><br></pre></td></tr></table></figure><h1 id="7-链式合并字典chainmap的使用"><a href="#7-链式合并字典chainmap的使用" class="headerlink" title="7 链式合并字典chainmap的使用"></a>7 链式合并字典chainmap的使用</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> ChainMap</span><br><span class="line"></span><br><span class="line"><span class="comment"># ChainMap</span></span><br><span class="line"></span><br><span class="line">d1 = &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;</span><br><span class="line">d2 = &#123;<span class="string">'a2'</span>: <span class="number">3</span>, <span class="string">'b2'</span>: <span class="number">4</span>&#125;</span><br><span class="line">d3 = &#123;<span class="string">'a3'</span>: <span class="number">5</span>, <span class="string">'b3'</span>: <span class="number">6</span>&#125;</span><br><span class="line">d4 = &#123;<span class="string">'a4'</span>: <span class="number">7</span>, <span class="string">'b4'</span>: <span class="number">8</span>&#125;</span><br><span class="line">c = ChainMap(d1, d2, d3, d4)  <span class="comment"># 多个字典合并为一个</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> c.items():</span><br><span class="line">    print(k, v)</span><br><span class="line">print(c.maps)  <span class="comment"># 要搜索的索引列表</span></span><br><span class="line"></span><br><span class="line">c.maps = list(reversed(c.maps))  <span class="comment"># 逆转映射列表</span></span><br><span class="line">print(c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为c和d1-d4对应的索引位置实际是一个所以，修改c的时候会影响到d1到d4其中饿的一个值，同理修改</span></span><br><span class="line"><span class="comment"># d1-d4的时候也会影响到c。</span></span><br><span class="line"><span class="comment"># 所以使用new_child创建一个新的映射。再修改就影响不到底层的数据了。</span></span><br><span class="line">c2 = c.new_child()</span><br><span class="line">c2[<span class="string">"a4"</span>] = <span class="number">100</span></span><br><span class="line">print(c)</span><br><span class="line">print(c2)</span><br><span class="line"><span class="comment"># 输出发现c的值没有发生变化，只要c2变化。</span></span><br><span class="line">d5 = &#123;<span class="string">"a5"</span>: <span class="number">34</span>, <span class="string">"b5"</span>: <span class="number">78</span>&#125;</span><br><span class="line">c2 = c2.new_child(d5)  <span class="comment"># 可以在原来的映射基础上添加新的映射</span></span><br><span class="line">print(c2)</span><br></pre></td></tr></table></figure><h1 id="8-在不打乱列表顺序的基础上插入元素"><a href="#8-在不打乱列表顺序的基础上插入元素" class="headerlink" title="8 在不打乱列表顺序的基础上插入元素"></a>8 在不打乱列表顺序的基础上插入元素</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">bisect 模块，用于维护有序列表。</span></span><br><span class="line"><span class="string">bisect 模块实现了一个算法用于插入元素到有序列表。</span></span><br><span class="line"><span class="string">在一些情况下，这比反复排序列表或构造一个大的列表再排序的效率更高。</span></span><br><span class="line"><span class="string">Bisect 是二分法的意思，这里使用二分法来排序，它会将一个元素插入到一个有序列表的合适位置，</span></span><br><span class="line"><span class="string">这使得不需要每次调用 sort 的方式维护有序列表。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">values = [<span class="number">14</span>, <span class="number">85</span>, <span class="number">77</span>, <span class="number">26</span>, <span class="number">50</span>, <span class="number">45</span>, <span class="number">66</span>, <span class="number">79</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">84</span>, <span class="number">77</span>, <span class="number">1</span>]</span><br><span class="line">print(<span class="string">"New Pos Content"</span>)</span><br><span class="line">print(<span class="string">"--- --- -------"</span>)</span><br><span class="line">l = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> values:</span><br><span class="line">    postion = bisect.bisect(l, i)  <span class="comment"># 返回插入的位置</span></span><br><span class="line">    bisect.insort(l, i)  <span class="comment"># 等于insort_right</span></span><br><span class="line">    print(<span class="string">'&#123;:3&#125;&#123;:3&#125;'</span>.format(i, postion), l)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Bisect模块提供的函数有：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">bisect.bisect_left(a,x, lo=0, hi=len(a)) :</span></span><br><span class="line"><span class="string">查找在有序列表 a 中插入 x 的index。lo 和 hi 用于指定列表的区间，默认是使用整个列表。如果 x 已经存在，在其左边插入。返回值为 index。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">bisect.bisect_right(a,x, lo=0, hi=len(a))</span></span><br><span class="line"><span class="string">bisect.bisect(a, x,lo=0, hi=len(a)) ：</span></span><br><span class="line"><span class="string">这2个函数和 bisect_left 类似，但如果 x 已经存在，在其右边插入。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">bisect.insort_left(a,x, lo=0, hi=len(a)) ：</span></span><br><span class="line"><span class="string">在有序列表 a 中插入 x。和 a.insert(bisect.bisect_left(a,x, lo, hi), x) 的效果相同。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">bisect.insort_right(a,x, lo=0, hi=len(a))</span></span><br><span class="line"><span class="string">bisect.insort(a, x,lo=0, hi=len(a)) :</span></span><br><span class="line"><span class="string">和 insort_left 类似，但如果 x 已经存在，在其右边插入。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Bisect 模块提供的函数可以分两类： bisect* 只用于查找 index， 不进行实际的插入；</span></span><br><span class="line"><span class="string">而 insort* 则用于实际插入。该模块比较典型的应用是计算分数等级：</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h1 id="9-关于字典的逻辑运算你了解多少"><a href="#9-关于字典的逻辑运算你了解多少" class="headerlink" title="9 关于字典的逻辑运算你了解多少"></a>9 关于字典的逻辑运算你了解多少</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用&amp;操作符查看字典的相同之处</span></span><br><span class="line"><span class="comment">#字典键支持常见的集合操作，并集交集差集。</span></span><br><span class="line">a = &#123;<span class="string">'x'</span>: <span class="number">1</span>, <span class="string">'y'</span>: <span class="number">2</span>, <span class="string">'z'</span>: <span class="number">3</span>&#125;</span><br><span class="line">b = &#123;<span class="string">'w'</span>: <span class="number">2</span>, <span class="string">'z'</span>: <span class="number">4</span>, <span class="string">'x'</span>: <span class="number">3</span>, <span class="string">'z'</span>: <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取相同的键</span></span><br><span class="line">c = a.keys() &amp; b.keys()</span><br><span class="line">print(c)</span><br><span class="line"><span class="comment"># 获取相同的键值对</span></span><br><span class="line">d = a.items() &amp; b.items()</span><br><span class="line">print(d)</span><br><span class="line"><span class="comment"># 创建一个新的字典并删除某些键</span></span><br><span class="line"></span><br><span class="line">e = &#123;k: a[k] <span class="keyword">for</span> k <span class="keyword">in</span> a.keys() - &#123;<span class="string">'z'</span>, <span class="string">'x'</span>&#125;&#125;</span><br><span class="line">print(e)</span><br></pre></td></tr></table></figure><h1 id="10-给切片起个名字"><a href="#10-给切片起个名字" class="headerlink" title="10 给切片起个名字"></a>10 给切片起个名字</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="string">"safr3.14"</span></span><br><span class="line">print(a[<span class="number">-4</span>:])</span><br><span class="line"><span class="comment">#上面可以改为</span></span><br><span class="line">pie=slice(len(a)<span class="number">-4</span>,len(a))</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><h1 id="11-获取出现频率高的元素"><a href="#11-获取出现频率高的元素" class="headerlink" title="11 获取出现频率高的元素"></a>11 获取出现频率高的元素</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">text = <span class="string">"abcdfegtehto;grgtgjri"</span>  <span class="comment"># 可迭代对象</span></span><br><span class="line">lis = [<span class="string">"a"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"t"</span>, <span class="string">"b"</span>]</span><br><span class="line">dic = &#123;<span class="string">"a"</span>: <span class="number">1</span>, <span class="string">"b"</span>: <span class="number">4</span>, <span class="string">"c"</span>: <span class="number">2</span>, <span class="string">"d"</span>: <span class="number">9</span>&#125;  <span class="comment"># 字典也可以</span></span><br><span class="line">c = Counter()  <span class="comment"># 可以定义空容器然后update</span></span><br><span class="line">c.update(text)</span><br><span class="line">c2 = Counter()</span><br><span class="line">c2.update(dic)</span><br><span class="line"></span><br><span class="line">c3 = Counter(lis)  <span class="comment"># 也可以直接传入对象</span></span><br><span class="line">print(c)</span><br><span class="line">print(c2)</span><br><span class="line">print(c3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用c.most_comman(n)获取前n出现频率最高的元素,列表元组类型</span></span><br><span class="line">print(c.most_common(<span class="number">4</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-路径操作&quot;&gt;&lt;a href=&quot;#1-路径操作&quot; class=&quot;headerlink&quot; title=&quot;1. 路径操作&quot;&gt;&lt;/a&gt;1. 路径操作&lt;/h1&gt;&lt;p&gt;比起os模块的path方法，python3标准库的pathlib模块的Path处理起路径更加的容易。&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="http://gilgameshzzz.github.io/2019/02/28/Docker/"/>
    <id>http://gilgameshzzz.github.io/2019/02/28/Docker/</id>
    <published>2019-02-28T09:31:39.725Z</published>
    <updated>2019-02-26T06:38:10.196Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p>Docker - Debian - cgroup / nameplace</p><p>RabbitMQ - 消息服务 -Ruby</p><p>ElasticSearch / Solr - 搜索引擎 - Java</p><p>虚拟机 - 屏蔽软硬件环境的差异  - VMware / virtual Box</p><p>重量级容器（占用的系统资源多）</p><p>Nginx / MySQL / Redis / RabbitMQ</p><h4 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h4><p>yum -y intsall docker-io</p><ul><li><p>启动Docker 服务</p><p>systemctl start docker</p></li><li><p>查看镜像</p><p>docker images</p><p>下载mysql5.7 镜像(安装盘)</p></li></ul><p>Docker pull mysql:5.7（镜像名：版本号）</p><h4 id="创建容器（nginx"><a href="#创建容器（nginx" class="headerlink" title="创建容器（nginx)"></a>创建容器（nginx)</h4><p>  docker run -d -p 80:80 –name  nginx(容器名字)  nginx</p><p>​    创建容器（mysql)</p><p> docker run -d -p 3306:3306 –name mysql57 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7</p><p>查看进程信息</p><p>netstat -nap | grep </p><p>查看所有容器</p><p>docker container ls -a</p><p>查看已经启动的容器</p><p>docker ps</p><p>启动/停止容器</p><p>docker start /stop 容器名</p><h4 id="Redis-基于内存的kv的数据库"><a href="#Redis-基于内存的kv的数据库" class="headerlink" title="Redis - 基于内存的kv的数据库"></a>Redis - 基于内存的kv的数据库</h4><p>Redis提供了两种持久化方法</p><p>​        RDB - 内存中的数据放入一个二进制的dump文件中</p><p>​        AOF - 用一个文件记录用户操作的命令 - 每秒记录一次用户操作</p><p>docker run -d -p  6379:6379 –name redis-master redis</p><p>redis-server –appendonly  yes  –requirepass tmz55555</p><p>docker run -d –link redis-master:redis-master –name redis-slave-1 redis:latest redis-server – slaveof redis-mater 6379 –masterauth tmz55555 </p><p>docker run -d –link redis-master:redis-master –name redis-slave-2 redis:latest redis-server – slaveof redis-mater 6379 –masterauth tmz55555 </p><p>docker run -d –link redis-master:redis-master –name redis-slave-3 redis:latest redis-server – slaveof redis-mater 6379 –masterauth tmz55555 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Docker&quot;&gt;&lt;a href=&quot;#Docker&quot; class=&quot;headerlink&quot; title=&quot;Docker&quot;&gt;&lt;/a&gt;Docker&lt;/h1&gt;&lt;p&gt;Docker - Debian - cgroup / nameplace&lt;/p&gt;
&lt;p&gt;RabbitMQ -
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>装饰器、函数、一条语句实现阶乘</title>
    <link href="http://gilgameshzzz.github.io/2019/02/28/day02-%E8%A3%85%E9%A5%B0%E5%99%A8%E3%80%81%E5%87%BD%E6%95%B0%E3%80%81%E4%B8%80%E6%9D%A1%E8%AF%AD%E5%8F%A5%E5%AE%9E%E7%8E%B0%E9%98%B6%E4%B9%98/"/>
    <id>http://gilgameshzzz.github.io/2019/02/28/day02-装饰器、函数、一条语句实现阶乘/</id>
    <published>2019-02-28T09:31:39.725Z</published>
    <updated>2019-02-26T06:38:10.197Z</updated>
    
    <content type="html"><![CDATA[<p>filter –&gt;map –&gt;  reduce</p><p>过滤       映射       归约</p><p>过滤      映射     </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a =[<span class="number">12</span>, <span class="number">95</span>, <span class="number">88</span>, <span class="number">45</span>]</span><br><span class="line">sum([x**x <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">if</span> x % <span class="number">2</span>]) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn = <span class="keyword">lambda</span> x,y :x**y</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line">fn =foo</span><br></pre></td></tr></table></figure><p>在python中函数式一等对象（一定公民）</p><ol><li>函数可以赋值给变量</li><li>函数可以作为函数的参数   —&gt;fillter</li><li>函数可以作为函数的返回值 —&gt;装饰器</li></ol><p>函数参数:</p><ol><li><p>位置参数</p></li><li><p>可变参数 -tuple</p></li><li><p>关键字参数 - dict</p></li><li><p>命名关键字参数</p><p>​</p></li></ol><p>自定义装饰器 - 装饰函数 / 装饰类  –设计模式（代理模式）</p><p>代理模式</p><p>用代理对象（装饰器函数）去执行被代理对象（被装饰的函数）的行为</p><p>面向切面编程 —AOP</p><p>在程序中跟正常业务逻辑没有必然联系而且会重复使用的功能通常被称为横切关注功能，这种横切关注功能不应该写在业务逻辑代码是上，而应该使用装饰器或中间件来完成</p><p>指令式编程（汇编语言） /过程式语言（c语言）</p><p>Python既支持面向对象编程，也支持函数式编程</p><p>一条语句求阶乘</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn = <span class="keyword">lambda</span> n: functools.reduce(int.__mul__, range(<span class="number">1</span>,n+<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>heapq内置模块  提供基于堆的优先排序算法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line">list1[<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">63</span>,<span class="number">24</span>]</span><br><span class="line">heapq.nsmallest(list1,n)  <span class="comment">#最小的n个</span></span><br><span class="line">heapq.nlargest(list1,<span class="number">3</span>)<span class="comment">#最大的n个</span></span><br></pre></td></tr></table></figure><p>全排列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import itertools</span><br><span class="line">for val in itertools.combinations(&apos;abcde&apos;, 3):</span><br><span class="line">print (val)</span><br></pre></td></tr></table></figure><p>笛卡尔积</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for val in itertools.product(&apos;ABCD&apos;,123):</span><br><span class="line">print(val)</span><br></pre></td></tr></table></figure><p>装饰器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">record</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">@wraps(func)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line"></span><br><span class="line">ret_value = func(*args, *kwargs)</span><br><span class="line"><span class="keyword">return</span> ret_value</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><p>带参数的装饰器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps </span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">record_time</span><span class="params">(output)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(function)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 装饰器函数，计算函数执行时间</span></span><br><span class="line"><span class="meta">        @wraps(function)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">timeCount</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            timestart = time.time()</span><br><span class="line">            result = function(*args, **kwargs)</span><br><span class="line">            timesend= time.time()</span><br><span class="line">            output(function.__name__, timesend - timestart) </span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">return</span> timeCount</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_to_file</span><span class="params">(fn, duration)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'result.txt'</span>, <span class="string">'a'</span>)<span class="keyword">as</span> fs:</span><br><span class="line">        fs.write(<span class="string">'%s: %.3f秒\n'</span> %(fn,duration))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@record_time(log_to_file)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fool</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        <span class="comment"># 此处调用foo并不是真正执行分两类而是执行了wrpper</span></span><br><span class="line">        fool()</span><br><span class="line">    <span class="comment"># 取消装饰器 </span></span><br><span class="line">    foo2 = fool.__wrapped__</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        <span class="comment"># 此处调用被装饰之前写的函数</span></span><br><span class="line">        foo2()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;filter –&amp;gt;map –&amp;gt;  reduce&lt;/p&gt;
&lt;p&gt;过滤       映射       归约&lt;/p&gt;
&lt;p&gt;过滤      映射     &lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas
      
    
    </summary>
    
    
  </entry>
  
</feed>
